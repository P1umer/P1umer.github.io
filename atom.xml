<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>P1umerのblog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://p1umer.club/"/>
  <updated>2019-03-19T17:39:26.637Z</updated>
  <id>http://p1umer.club/</id>
  
  <author>
    <name>P1umer sauce</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AFL 初探</title>
    <link href="http://p1umer.club/2019/03/20/AFL-%E5%88%9D%E6%8E%A2/"/>
    <id>http://p1umer.club/2019/03/20/AFL-初探/</id>
    <published>2019-03-19T17:39:12.000Z</published>
    <updated>2019-03-19T17:39:26.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AFL-初探"><a href="#AFL-初探" class="headerlink" title="AFL 初探"></a>AFL 初探</h2><p><img src="https://barro.github.io/2018/06/afl-fuzz-on-different-file-systems/afl-forkserver-visualization-2900.png" alt="image"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line">static void add_instrumentation(void) &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  static u8 line[MAX_LINE];</span><br><span class="line"></span><br><span class="line">  FILE* inf;</span><br><span class="line">  FILE* outf;</span><br><span class="line">  s32 outfd;</span><br><span class="line">  u32 ins_lines = 0;</span><br><span class="line"></span><br><span class="line">  u8  instr_ok = 0, skip_csect = 0, skip_next_label = 0,</span><br><span class="line">      skip_intel = 0, skip_app = 0, instrument_next = 0;</span><br><span class="line"></span><br><span class="line">#ifdef __APPLE__</span><br><span class="line"></span><br><span class="line">  u8* colon_pos;</span><br><span class="line"></span><br><span class="line">#endif /* __APPLE__ */</span><br><span class="line"></span><br><span class="line">//输入文件，gcc生成</span><br><span class="line">  if (input_file) &#123;</span><br><span class="line"></span><br><span class="line">    inf = fopen(input_file, &quot;r&quot;);</span><br><span class="line">    if (!inf) PFATAL(&quot;Unable to read &apos;%s&apos;&quot;, input_file);</span><br><span class="line"></span><br><span class="line">  &#125; else inf = stdin;</span><br><span class="line"></span><br><span class="line">//输出文件</span><br><span class="line">  outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, 0600);</span><br><span class="line"></span><br><span class="line">  if (outfd &lt; 0) PFATAL(&quot;Unable to write to &apos;%s&apos;&quot;, modified_file);</span><br><span class="line"></span><br><span class="line">  outf = fdopen(outfd, &quot;w&quot;);</span><br><span class="line"></span><br><span class="line">  if (!outf) PFATAL(&quot;fdopen() failed&quot;);  </span><br><span class="line"></span><br><span class="line">//对于inf进行每行的遍历插桩</span><br><span class="line">  while (fgets(line, MAX_LINE, inf)) &#123;</span><br><span class="line"></span><br><span class="line">    /* In some cases, we want to defer writing the instrumentation trampoline</span><br><span class="line">       until after all the labels, macros, comments, etc. If we&apos;re in this</span><br><span class="line">       mode, and if the line starts with a tab followed by a character, dump</span><br><span class="line">       the trampoline now. */</span><br><span class="line"></span><br><span class="line">//满足这些条件就插桩,条件由下面的扫描提供</span><br><span class="line">    if (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">        instrument_next &amp;&amp; line[0] == &apos;\t&apos; &amp;&amp; isalpha(line[1])) &#123;</span><br><span class="line"></span><br><span class="line">      fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">              R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">      instrument_next = 0;</span><br><span class="line">      ins_lines++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Output the actual line, call it a day in pass-thru mode. */</span><br><span class="line">//把原始的代码写入outf</span><br><span class="line">    fputs(line, outf);</span><br><span class="line"></span><br><span class="line">    if (pass_thru) continue;</span><br><span class="line"></span><br><span class="line">    /* All right, this is where the actual fun begins. For one, we only want to</span><br><span class="line">       instrument the .text section. So, let&apos;s keep track of that in processed</span><br><span class="line">       files - and let&apos;s set instr_ok accordingly. */</span><br><span class="line"></span><br><span class="line">//判断代码段，只插桩.text段</span><br><span class="line">    if (line[0] == &apos;\t&apos; &amp;&amp; line[1] == &apos;.&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      /* OpenBSD puts jump tables directly inline with the code, which is</span><br><span class="line">         a bit annoying. They use a specific format of p2align directives</span><br><span class="line">         around them, so we use that as a signal. */</span><br><span class="line"></span><br><span class="line">      if (!clang_mode &amp;&amp; instr_ok &amp;&amp; !strncmp(line + 2, &quot;p2align &quot;, 8) &amp;&amp;</span><br><span class="line">          isdigit(line[10]) &amp;&amp; line[11] == &apos;\n&apos;) skip_next_label = 1;</span><br><span class="line"></span><br><span class="line">      if (!strncmp(line + 2, &quot;text\n&quot;, 5) ||</span><br><span class="line">          !strncmp(line + 2, &quot;section\t.text&quot;, 13) ||</span><br><span class="line">          !strncmp(line + 2, &quot;section\t__TEXT,__text&quot;, 21) ||</span><br><span class="line">          !strncmp(line + 2, &quot;section __TEXT,__text&quot;, 21)) &#123;</span><br><span class="line">        instr_ok = 1;</span><br><span class="line">        continue; </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!strncmp(line + 2, &quot;section\t&quot;, 8) ||</span><br><span class="line">          !strncmp(line + 2, &quot;section &quot;, 8) ||</span><br><span class="line">          !strncmp(line + 2, &quot;bss\n&quot;, 4) ||</span><br><span class="line">          !strncmp(line + 2, &quot;data\n&quot;, 5)) &#123;</span><br><span class="line">        instr_ok = 0;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Detect off-flavor assembly (rare, happens in gdb). When this is</span><br><span class="line">       encountered, we set skip_csect until the opposite directive is</span><br><span class="line">       seen, and we do not instrument. */</span><br><span class="line"></span><br><span class="line">//判断位数</span><br><span class="line">    if (strstr(line, &quot;.code&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">      if (strstr(line, &quot;.code32&quot;)) skip_csect = use_64bit;</span><br><span class="line">      if (strstr(line, &quot;.code64&quot;)) skip_csect = !use_64bit;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Detect syntax changes, as could happen with hand-written assembly.</span><br><span class="line">       Skip Intel blocks, resume instrumentation when back to AT&amp;T. */</span><br><span class="line"></span><br><span class="line">    if (strstr(line, &quot;.intel_syntax&quot;)) skip_intel = 1;</span><br><span class="line">    if (strstr(line, &quot;.att_syntax&quot;)) skip_intel = 0;</span><br><span class="line"></span><br><span class="line">    /* Detect and skip ad-hoc __asm__ blocks, likewise skipping them. */</span><br><span class="line"></span><br><span class="line">    if (line[0] == &apos;#&apos; || line[1] == &apos;#&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      if (strstr(line, &quot;#APP&quot;)) skip_app = 1;</span><br><span class="line">      if (strstr(line, &quot;#NO_APP&quot;)) skip_app = 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* If we&apos;re in the right mood for instrumenting, check for function</span><br><span class="line">       names or conditional labels. This is a bit messy, but in essence,</span><br><span class="line">       we want to catch:</span><br><span class="line"></span><br><span class="line">         ^main:      - function entry point (always instrumented)</span><br><span class="line">         ^.L0:       - GCC branch label</span><br><span class="line">         ^.LBB0_0:   - clang branch label (but only in clang mode)</span><br><span class="line">         ^\tjnz foo  - conditional branches</span><br><span class="line"></span><br><span class="line">       ...but not:</span><br><span class="line"></span><br><span class="line">         ^# BB#0:    - clang comments</span><br><span class="line">         ^ # BB#0:   - ditto</span><br><span class="line">         ^.Ltmp0:    - clang non-branch labels</span><br><span class="line">         ^.LC0       - GCC non-branch labels</span><br><span class="line">         ^.LBB0_0:   - ditto (when in GCC mode)</span><br><span class="line">         ^\tjmp foo  - non-conditional jumps</span><br><span class="line"></span><br><span class="line">       Additionally, clang and GCC on MacOS X follow a different convention</span><br><span class="line">       with no leading dots on labels, hence the weird maze of #ifdefs</span><br><span class="line">       later on.</span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    if (skip_intel || skip_app || skip_csect || !instr_ok ||</span><br><span class="line">        line[0] == &apos;#&apos; || line[0] == &apos; &apos;) continue;</span><br><span class="line"></span><br><span class="line">    /* Conditional branch instruction (jnz, etc). We append the instrumentation</span><br><span class="line">       right after the branch (to instrument the not-taken path) and at the</span><br><span class="line">       branch destination label (handled later on). */</span><br><span class="line"></span><br><span class="line">//碰到jcc进行无条件插桩</span><br><span class="line">    if (line[0] == &apos;\t&apos;) &#123;</span><br><span class="line"></span><br><span class="line">      if (line[1] == &apos;j&apos; &amp;&amp; line[2] != &apos;m&apos; &amp;&amp; R(100) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line">        fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">                R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">        ins_lines++;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      continue;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//label中均包含&quot;:&quot;,下面的工作就是匹配各种label</span><br><span class="line">    /* Label of some sort. This may be a branch destination, but we need to</span><br><span class="line">       tread carefully and account for several different formatting</span><br><span class="line">       conventions. */</span><br><span class="line"></span><br><span class="line">#ifdef __APPLE__</span><br><span class="line"></span><br><span class="line">    /* Apple: L&lt;whatever&gt;&lt;digit&gt;: */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if ((colon_pos = strstr(line, &quot;:&quot;))) &#123;</span><br><span class="line"></span><br><span class="line">      if (line[0] == &apos;L&apos; &amp;&amp; isdigit(*(colon_pos - 1))) &#123;</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">    /* Everybody else: .L&lt;whatever&gt;: */</span><br><span class="line"></span><br><span class="line">//匹配[.L&lt;wtever&gt;:]</span><br><span class="line">    if (strstr(line, &quot;:&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">      if (line[0] == &apos;.&apos;) &#123;</span><br><span class="line"></span><br><span class="line">#endif /* __APPLE__ */</span><br><span class="line"></span><br><span class="line">        /* .L0: or LBB0_0: style jump destination */</span><br><span class="line"></span><br><span class="line">#ifdef __APPLE__</span><br><span class="line"></span><br><span class="line">        /* Apple: L&lt;num&gt; / LBB&lt;num&gt; */</span><br><span class="line"></span><br><span class="line">        if ((isdigit(line[1]) || (clang_mode &amp;&amp; !strncmp(line, &quot;LBB&quot;, 3)))</span><br><span class="line">            &amp;&amp; R(100) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">        /* Apple: .L&lt;num&gt; / .LBB&lt;num&gt; */</span><br><span class="line"></span><br><span class="line">        if ((isdigit(line[2]) || (clang_mode &amp;&amp; !strncmp(line + 1, &quot;LBB&quot;, 3)))</span><br><span class="line">            &amp;&amp; R(100) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line">#endif /* __APPLE__ */</span><br><span class="line"></span><br><span class="line">          /* An optimization is possible here by adding the code only if the</span><br><span class="line">             label is mentioned in the code in contexts other than call / jmp.</span><br><span class="line">             That said, this complicates the code by requiring two-pass</span><br><span class="line">             processing (messy with stdin), and results in a speed gain</span><br><span class="line">             typically under 10%, because compilers are generally pretty good</span><br><span class="line">             about not generating spurious intra-function jumps.</span><br><span class="line"></span><br><span class="line">             We use deferred output chiefly to avoid disrupting</span><br><span class="line">             .Lfunc_begin0-style exception handling calculations (a problem on</span><br><span class="line">             MacOS X). */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          if (!skip_next_label) instrument_next = 1; else skip_next_label = 0;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        /* Function label (always instrumented, deferred mode). */</span><br><span class="line">//匹配到一个label，instrument_next=1</span><br><span class="line">        instrument_next = 1;</span><br><span class="line">    </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//最后插入一个 main_payload</span><br><span class="line">  if (ins_lines)</span><br><span class="line">    fputs(use_64bit ? main_payload_64 : main_payload_32, outf);</span><br><span class="line"></span><br><span class="line">  if (input_file) fclose(inf);</span><br><span class="line">  fclose(outf);</span><br><span class="line"></span><br><span class="line">  if (!be_quiet) &#123;</span><br><span class="line"></span><br><span class="line">    if (!ins_lines) WARNF(&quot;No instrumentation targets found%s.&quot;,</span><br><span class="line">                          pass_thru ? &quot; (pass-thru mode)&quot; : &quot;&quot;);</span><br><span class="line">    else OKF(&quot;Instrumented %u locations (%s-bit, %s mode, ratio %u%%).&quot;,</span><br><span class="line">             ins_lines, use_64bit ? &quot;64&quot; : &quot;32&quot;,</span><br><span class="line">             getenv(&quot;AFL_HARDEN&quot;) ? &quot;hardened&quot; : </span><br><span class="line">             (sanitizer ? &quot;ASAN/MSAN&quot; : &quot;non-hardened&quot;),</span><br><span class="line">             inst_ratio);</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>afl-as.c文件中插桩的条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* In some cases, we want to defer writing the instrumentation trampoline</span><br><span class="line">   until after all the labels, macros, comments, etc. If we&apos;re in this</span><br><span class="line">   mode, and if the line starts with a tab followed by a character, dump</span><br><span class="line">   the trampoline now. */</span><br><span class="line">if (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">    instrument_next &amp;&amp; line[0] == &apos;\t&apos; &amp;&amp; isalpha(line[1])) &#123;</span><br><span class="line"></span><br><span class="line">  fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">          R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">  instrument_next = 0;</span><br><span class="line">  ins_lines++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体看一下插进去的代码是什么：</p><p>通过fprintf()将格式化字符串添加到汇编文件的相应位置，只分析32位的情况，trampoline_fmt_32的具体内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static const u8* trampoline_fmt_32 =</span><br><span class="line"></span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;.align 4\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;leal -16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;movl %%edi,  0(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%edx,  4(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%ecx,  8(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%eax, 12(%%esp)\n&quot;</span><br><span class="line">  &quot;movl $0x%08x, %%ecx\n&quot;</span><br><span class="line">  &quot;call __afl_maybe_log\n&quot;</span><br><span class="line">  &quot;movl 12(%%esp), %%eax\n&quot;</span><br><span class="line">  &quot;movl  8(%%esp), %%ecx\n&quot;</span><br><span class="line">  &quot;movl  4(%%esp), %%edx\n&quot;</span><br><span class="line">  &quot;movl  0(%%esp), %%edi\n&quot;</span><br><span class="line">  &quot;leal 16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;/* --- END --- */\n&quot;</span><br><span class="line">  &quot;\n&quot;;</span><br></pre></td></tr></table></figure></p><p>其中，<code>movl $0x%08x, %%ecx\n</code> 为将R(x)生成的随机数给ecx作为标识代码段的key。然后调用__afl_maybe_log，调用完之后，把栈上保存的值恢复回去，再把栈恢复。</p><p>main_payload_32:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line">static const u8* main_payload_32 = </span><br><span class="line"></span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;/* --- AFL MAIN PAYLOAD (32-BIT) --- */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;.text\n&quot;</span><br><span class="line">  &quot;.att_syntax\n&quot;</span><br><span class="line">  &quot;.code32\n&quot;</span><br><span class="line">  &quot;.align 8\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//__afl_maybe_log:</span><br><span class="line">  &quot;__afl_maybe_log:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  lahf\n&quot;</span><br><span class="line">  &quot;  seto %al\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  /* Check if SHM region is already mapped. */\n&quot;</span><br><span class="line">---</span><br><span class="line">//判断共享内存是否加载，edx中存储SHM(__afl_area_ptr)</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  movl  __afl_area_ptr, %edx\n&quot;</span><br><span class="line">  &quot;  testl %edx, %edx\n&quot;</span><br><span class="line">  &quot;  je    __afl_setup\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//__afl_store:</span><br><span class="line">  &quot;__afl_store:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  /* Calculate and store hit for the code location specified in ecx. There\n&quot;</span><br><span class="line">  &quot;     is a double-XOR way of doing this without tainting another register,\n&quot;</span><br><span class="line">  &quot;     and we use it on 64-bit systems; but it&apos;s slower for 32-bit ones. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//将pre和当前代码块的key进行异或，结果存储到edi</span><br><span class="line">#ifndef COVERAGE_ONLY</span><br><span class="line">  &quot;  movl __afl_prev_loc, %edi\n&quot;</span><br><span class="line">  &quot;  xorl %ecx, %edi\n&quot;</span><br><span class="line">  &quot;  shrl $1, %ecx\n&quot;</span><br><span class="line">  &quot;  movl %ecx, __afl_prev_loc\n&quot;</span><br><span class="line">#else</span><br><span class="line">  &quot;  movl %ecx, %edi\n&quot;</span><br><span class="line">#endif /* ^!COVERAGE_ONLY */</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//内存映射：edi为索引，edx为map，体现edge命中逻辑</span><br><span class="line">#ifdef SKIP_COUNTS</span><br><span class="line">  &quot;  orb  $1, (%edx, %edi, 1)\n&quot;</span><br><span class="line">#else</span><br><span class="line">  &quot;  incb (%edx, %edi, 1)\n&quot;</span><br><span class="line">#endif /* ^SKIP_COUNTS */</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//__afl_return</span><br><span class="line">  &quot;__afl_return:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  addb $127, %al\n&quot;</span><br><span class="line">  &quot;  sahf\n&quot;</span><br><span class="line">  &quot;  ret\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;.align 8\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//__afl_setup </span><br><span class="line">  &quot;__afl_setup:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  /* Do not retry setup if we had previous failures. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  cmpb $0, __afl_setup_failure\n&quot;</span><br><span class="line">  &quot;  jne  __afl_return\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  /* Map SHM, jumping to __afl_setup_abort if something goes wrong.\n&quot;</span><br><span class="line">  &quot;     We do not save FPU/MMX/SSE registers here, but hopefully, nobody\n&quot;</span><br><span class="line">  &quot;     will notice this early in the game. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//寻找 SHM 共享内存</span><br><span class="line">  &quot;  pushl %eax\n&quot;</span><br><span class="line">  &quot;  pushl %ecx\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  pushl $.AFL_SHM_ENV\n&quot;</span><br><span class="line">  &quot;  call  getenv\n&quot;</span><br><span class="line">  &quot;  addl  $4, %esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  testl %eax, %eax\n&quot;</span><br><span class="line">  &quot;  je    __afl_setup_abort\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  pushl %eax\n&quot;</span><br><span class="line">  &quot;  call  atoi\n&quot;</span><br><span class="line">  &quot;  addl  $4, %esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//shmat参数:SHM ID = getenv(.AFL_SHM_ENV)</span><br><span class="line">  &quot;  pushl $0          /* shmat flags    */\n&quot;</span><br><span class="line">  &quot;  pushl $0          /* requested addr */\n&quot;</span><br><span class="line">  &quot;  pushl %eax        /* SHM ID         */\n&quot;</span><br><span class="line">  &quot;  call  shmat\n&quot;</span><br><span class="line">  &quot;  addl  $12, %esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  cmpl $-1, %eax\n&quot;</span><br><span class="line">  &quot;  je   __afl_setup_abort\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//储存 SHM 地址到 __afl_area_ptr</span><br><span class="line">  &quot;  /* Store the address of the SHM region. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  movl %eax, __afl_area_ptr\n&quot;</span><br><span class="line">  &quot;  movl %eax, %edx\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  popl %ecx\n&quot;</span><br><span class="line">  &quot;  popl %eax\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//__afl_forkserver</span><br><span class="line">  &quot;__afl_forkserver:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  /* Enter the fork server mode to avoid the overhead of execve() calls. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  pushl %eax\n&quot;</span><br><span class="line">  &quot;  pushl %ecx\n&quot;</span><br><span class="line">  &quot;  pushl %edx\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  /* Phone home and tell the parent that we&apos;re OK. (Note that signals with\n&quot;</span><br><span class="line">  &quot;     no SA_RESTART will mess it up). If this fails, assume that the fd is\n&quot;</span><br><span class="line">  &quot;     closed because we were execve()d from an instrumented binary, or because\n&quot; </span><br><span class="line">  &quot;     the parent doesn&apos;t want to use the fork server. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">//将__afl_temp中的4个字节写到提前开好的管道中</span><br><span class="line">  &quot;  pushl $4          /* length    */\n&quot;</span><br><span class="line">  &quot;  pushl $__afl_temp /* data      */\n&quot;</span><br><span class="line">  &quot;  pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;  /* file desc */\n&quot;</span><br><span class="line">  &quot;  call  write\n&quot;</span><br><span class="line">  &quot;  addl  $12, %esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  cmpl  $4, %eax\n&quot;</span><br><span class="line">//jne：不相等跳转，即fail跳转-&gt;__afl_fork_resume</span><br><span class="line">  &quot;  jne   __afl_fork_resume\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//__afl_fork_wait_loop:</span><br><span class="line">  &quot;__afl_fork_wait_loop:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  /* Wait for parent by reading from the pipe. Abort if read fails. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">//不断地从管道中读取内容，假如读取到的字节数不为4就会跳到__afl_die</span><br><span class="line">  &quot;  pushl $4          /* length    */\n&quot;</span><br><span class="line">  &quot;  pushl $__afl_temp /* data      */\n&quot;</span><br><span class="line">  &quot;  pushl $&quot; STRINGIFY(FORKSRV_FD) &quot;        /* file desc */\n&quot;</span><br><span class="line">  &quot;  call  read\n&quot;</span><br><span class="line">  &quot;  addl  $12, %esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  cmpl  $4, %eax\n&quot;</span><br><span class="line">  &quot;  jne   __afl_die\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  /* Once woken up, create a clone of our process. This is an excellent use\n&quot;</span><br><span class="line">  &quot;     case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly\n&quot;</span><br><span class="line">  &quot;     caches getpid() results and offers no way to update the value, breaking\n&quot;</span><br><span class="line">  &quot;     abort(), raise(), and a bunch of other things :-( */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">//fork，判断fork是否成功，如果成功，子进程跳到__afl_fork_resume</span><br><span class="line">  &quot;  call fork\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  cmpl $0, %eax\n&quot;</span><br><span class="line">  &quot;  jl   __afl_die\n&quot;</span><br><span class="line">  &quot;  je   __afl_fork_resume\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">//父进程 write PID to pipe，传给 fuzzer</span><br><span class="line">  &quot;  /* In parent process: write PID to pipe, then wait for child. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  movl  %eax, __afl_fork_pid\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  pushl $4              /* length    */\n&quot;</span><br><span class="line">  &quot;  pushl $__afl_fork_pid /* data      */\n&quot;</span><br><span class="line">  &quot;  pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;      /* file desc */\n&quot;</span><br><span class="line">  &quot;  call  write\n&quot;</span><br><span class="line">  &quot;  addl  $12, %esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">//如果waitpid返回的结果小于等于0，就会跳到afl_die，同时状态传入__afl_temp</span><br><span class="line">  &quot;  pushl $0             /* no flags  */\n&quot;</span><br><span class="line">  &quot;  pushl $__afl_temp    /* status    */\n&quot;</span><br><span class="line">  &quot;  pushl __afl_fork_pid /* PID       */\n&quot;</span><br><span class="line">  &quot;  call  waitpid\n&quot;</span><br><span class="line">  &quot;  addl  $12, %esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  cmpl  $0, %eax\n&quot;</span><br><span class="line">  &quot;  jle   __afl_die\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  /* Relay wait status to pipe, then loop back. */\n&quot;</span><br><span class="line">//状态通过管道传回fuzzer，同时启动新一轮等待</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  pushl $4          /* length    */\n&quot;</span><br><span class="line">  &quot;  pushl $__afl_temp /* data      */\n&quot;</span><br><span class="line">  &quot;  pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;  /* file desc */\n&quot;</span><br><span class="line">  &quot;  call  write\n&quot;</span><br><span class="line">  &quot;  addl  $12, %esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  jmp __afl_fork_wait_loop\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">---</span><br><span class="line">//__afl_fork_resume：</span><br><span class="line">  &quot;__afl_fork_resume:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">//管道关闭，寄存器恢复</span><br><span class="line">  &quot;  /* In child process: close fds, resume execution. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  pushl $&quot; STRINGIFY(FORKSRV_FD) &quot;\n&quot;</span><br><span class="line">  &quot;  call  close\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;\n&quot;</span><br><span class="line">  &quot;  call  close\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  addl  $8, %esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  popl %edx\n&quot;</span><br><span class="line">  &quot;  popl %ecx\n&quot;</span><br><span class="line">  &quot;  popl %eax\n&quot;</span><br><span class="line">//跳转到__afl_store：</span><br><span class="line">  &quot;  jmp  __afl_store\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;__afl_die:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  xorl %eax, %eax\n&quot;</span><br><span class="line">  &quot;  call _exit\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;__afl_setup_abort:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  /* Record setup failure so that we don&apos;t keep calling\n&quot;</span><br><span class="line">  &quot;     shmget() / shmat() over and over again. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  incb __afl_setup_failure\n&quot;</span><br><span class="line">  &quot;  popl %ecx\n&quot;</span><br><span class="line">  &quot;  popl %eax\n&quot;</span><br><span class="line">  &quot;  jmp __afl_return\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;.AFL_VARS:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  .comm   __afl_area_ptr, 4, 32\n&quot;</span><br><span class="line">  &quot;  .comm   __afl_setup_failure, 1, 32\n&quot;</span><br><span class="line">#ifndef COVERAGE_ONLY</span><br><span class="line">  &quot;  .comm   __afl_prev_loc, 4, 32\n&quot;</span><br><span class="line">#endif /* !COVERAGE_ONLY */</span><br><span class="line">  &quot;  .comm   __afl_fork_pid, 4, 32\n&quot;</span><br><span class="line">  &quot;  .comm   __afl_temp, 4, 32\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;.AFL_SHM_ENV:\n&quot;</span><br><span class="line">  &quot;  .asciz \&quot;&quot; SHM_ENV_VAR &quot;\&quot;\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;/* --- END --- */\n&quot;</span><br><span class="line">  &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">/* The OpenBSD hack is due to lahf and sahf not being recognized by some</span><br><span class="line">   versions of binutils: http://marc.info/?l=openbsd-cvs&amp;m=141636589924400</span><br><span class="line"></span><br><span class="line">   The Apple code is a bit different when calling libc functions because</span><br><span class="line">   they are doing relocations differently from everybody else. We also need</span><br><span class="line">   to work around the crash issue with .lcomm and the fact that they don&apos;t</span><br><span class="line">   recognize .string. */</span><br><span class="line"></span><br><span class="line">#ifdef __APPLE__</span><br><span class="line">#  define CALL_L64(str)&quot;call _&quot; str &quot;\n&quot;</span><br><span class="line">#else</span><br><span class="line">#  define CALL_L64(str)&quot;call &quot; str &quot;@PLT\n&quot;</span><br><span class="line">#endif /* ^__APPLE__ */</span><br></pre></td></tr></table></figure><p>特别的，对于llvm模式，代码插桩仅需一个modulepass，对每个 BB 进行 IRB 的辅助插桩即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">for (auto &amp;F : M)</span><br><span class="line">  for (auto &amp;BB : F) &#123;</span><br><span class="line"></span><br><span class="line">    BasicBlock::iterator IP = BB.getFirstInsertionPt();</span><br><span class="line">    IRBuilder&lt;&gt; IRB(&amp;(*IP));</span><br><span class="line"></span><br><span class="line">    if (AFL_R(100) &gt;= inst_ratio) continue;</span><br><span class="line"></span><br><span class="line">    /* Make up cur_loc */</span><br><span class="line"></span><br><span class="line">    unsigned int cur_loc = AFL_R(MAP_SIZE);</span><br><span class="line"></span><br><span class="line">    ConstantInt *CurLoc = ConstantInt::get(Int32Ty, cur_loc);</span><br><span class="line"></span><br><span class="line">    /* Load prev_loc */</span><br><span class="line"></span><br><span class="line">    LoadInst *PrevLoc = IRB.CreateLoad(AFLPrevLoc);</span><br><span class="line">    PrevLoc-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));</span><br><span class="line">    Value *PrevLocCasted = IRB.CreateZExt(PrevLoc, IRB.getInt32Ty());</span><br><span class="line"></span><br><span class="line">    /* Load SHM pointer */</span><br><span class="line">    //shared memory table</span><br><span class="line"></span><br><span class="line">    LoadInst *MapPtr = IRB.CreateLoad(AFLMapPtr);</span><br><span class="line">    MapPtr-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));</span><br><span class="line">    Value *MapPtrIdx =</span><br><span class="line">        IRB.CreateGEP(MapPtr, IRB.CreateXor(PrevLocCasted, CurLoc));</span><br><span class="line"></span><br><span class="line">    /* Update bitmap */</span><br><span class="line"></span><br><span class="line">    LoadInst *Counter = IRB.CreateLoad(MapPtrIdx);</span><br><span class="line">    Counter-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));</span><br><span class="line">    Value *Incr = IRB.CreateAdd(Counter, ConstantInt::get(Int8Ty, 1));</span><br><span class="line">    IRB.CreateStore(Incr, MapPtrIdx)</span><br><span class="line">        -&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));</span><br><span class="line"></span><br><span class="line">    /* Set prev_loc to cur_loc &gt;&gt; 1 */</span><br><span class="line"></span><br><span class="line">    StoreInst *Store =</span><br><span class="line">        IRB.CreateStore(ConstantInt::get(Int32Ty, cur_loc &gt;&gt; 1), AFLPrevLoc);</span><br><span class="line">    Store-&gt;setMetadata(M.getMDKindID(&quot;nosanitize&quot;), MDNode::get(C, None));</span><br><span class="line"></span><br><span class="line">    inst_blocks++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>现在在回到fuzz侧，还记得forksrv的wait状态吗？fuzzer对于wait状态的解除是通过进行用例测试，在fork server启动完成后，一旦需要执行某个测试用例，则fuzzer会调用run_target()方法，在此方法中，便是通过命令管道，通知fork_server准备fork；并通过状态管道，获取子进程pid：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if ((res = write(fsrv_ctl_fd, &amp;prev_timed_out, 4)) != 4) &#123;</span><br><span class="line"></span><br><span class="line">  if (stop_soon) return 0;</span><br><span class="line">  RPFATAL(res, &quot;Unable to request new process from fork server (OOM?)&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ((res = read(fsrv_st_fd, &amp;child_pid, 4)) != 4) &#123;</span><br><span class="line"></span><br><span class="line">  if (stop_soon) return 0;</span><br><span class="line">  RPFATAL(res, &quot;Unable to request new process from fork server (OOM?)&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (child_pid &lt;= 0) FATAL(&quot;Fork server is misbehaving (OOM?)&quot;);</span><br></pre></td></tr></table></figure></p><p>随后，fuzzer再次读取状态管道，获取子进程退出状态，并由此来判断子进程结束的原因，例如正常退出、超时、崩溃等，并进行相应的记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    if ((res = read(fsrv_st_fd, &amp;status, 4)) != 4) &#123;</span><br><span class="line">...</span><br><span class="line">  /* Report outcome to caller. */</span><br><span class="line"></span><br><span class="line">  if (WIFSIGNALED(status) &amp;&amp; !stop_soon) &#123;</span><br><span class="line"></span><br><span class="line">    kill_signal = WTERMSIG(status);</span><br><span class="line"></span><br><span class="line">    if (child_timed_out &amp;&amp; kill_signal == SIGKILL) return FAULT_TMOUT;</span><br><span class="line"></span><br><span class="line">    return FAULT_CRASH;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="Fork-Server（结合上述源码）"><a href="#Fork-Server（结合上述源码）" class="headerlink" title="Fork Server（结合上述源码）"></a>Fork Server（结合上述源码）</h3><ul><li><p>【afl-fuzz.cc:!forksrv_pid】fuzzer进程执行fork()得到fork server进程，然后重定向两个管道作为通信接口，并关闭不必要的管道。其中设置了 SAN。然后执行 target。此为forksrv_init</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   if (!forksrv_pid) &#123;</span><br><span class="line">...</span><br><span class="line">    if (dup2(ctl_pipe[0], FORKSRV_FD) &lt; 0) PFATAL(&quot;dup2() failed&quot;);</span><br><span class="line">    if (dup2(st_pipe[1], FORKSRV_FD + 1) &lt; 0) PFATAL(&quot;dup2() failed&quot;);</span><br><span class="line">...</span><br><span class="line">    close(ctl_pipe[0]);</span><br><span class="line">    close(ctl_pipe[1]);</span><br><span class="line">    close(st_pipe[0]);</span><br><span class="line">    close(st_pipe[1]);</span><br><span class="line">...</span><br><span class="line">    setenv(&quot;ASAN_OPTIONS&quot;, &quot;abort_on_error=1:&quot;</span><br><span class="line">                       &quot;detect_leaks=0:&quot;</span><br><span class="line">                       &quot;symbolize=0:&quot;</span><br><span class="line">                       &quot;allocator_may_return_null=1&quot;, 0);</span><br><span class="line">...</span><br><span class="line">    execv(target_path, argv);</span><br></pre></td></tr></table></figure></li><li><p>对于父进程（fuzzer），则会读取状态管道的信息，如果一切正常，则说明fork server创建完成。</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  fsrv_st_fd  = st_pipe[0]</span><br><span class="line">...</span><br><span class="line">  rlen = read(fsrv_st_fd, &amp;status, 4);</span><br><span class="line">...</span><br><span class="line">  /* If we have a four-byte &quot;hello&quot; message from the server, we&apos;re all set. Otherwise, try to figure out what went wrong. */</span><br><span class="line"></span><br><span class="line">  if (rlen == 4) &#123;</span><br><span class="line">    OKF(&quot;All right - fork server is up.&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>作为fuzzer，AFL并不是像无头苍蝇那样对输入文件无脑地随机变化（其实也支持这种方式，即dumb模式），其最大特点就是会对target进行插桩，以辅助mutated input的生成。具体地，插桩后的target，会记录执行过程中的分支信息；随后，fuzzer便可以根据这些信息，判断这次执行的整体流程和代码覆盖情况。</p><p>AFL使用共享内存，来完成以上信息在fuzzer和target之间的传递。具体地，fuzzer在启动时，会执行setup_shm()方法进行配置。其首先调用shemget()分配一块共享内存，大小MAP_SIZE为64K:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600);</span><br></pre></td></tr></table></figure></p><p>分配成功后，该共享内存的标志符会被设置到环境变量中，从而之后fork()得到的子进程可以通过该环境变量，得到这块共享内存的标志符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shm_str = alloc_printf(&quot;%d&quot;, shm_id);</span><br><span class="line">if (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, 1);</span><br></pre></td></tr></table></figure></p><p>并且，fuzzer本身，会使用变量trace_bits来保存共享内存的地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace_bits = shmat(shm_id, NULL, 0);</span><br></pre></td></tr></table></figure></p><p>在每次target执行之前，fuzzer首先将该共享内容清零：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memset(trace_bits, 0, MAP_SIZE);</span><br></pre></td></tr></table></figure></p><p>接下来，我们再来看看target是如何获取并使用这块共享内存的。相关代码同样也在上面提到的方法__afl_maybe_log()中。首先，会检查是否已经将共享内存映射完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="分支信息的记录"><a href="#分支信息的记录" class="headerlink" title="分支信息的记录"></a>分支信息的记录</h3><p>[warning] AFL 保存的是 edges 执行次数而不是 blocks 执行次数,AFL是根据二元tuple(跳转的源地址和目标地址)来记录分支信息，从而获取target的执行流程和代码覆盖情况，其伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;</span><br><span class="line">shared_mem[cur_location ^ prev_location]++; </span><br><span class="line">prev_location = cur_location &gt;&gt; 1;</span><br></pre></td></tr></table></figure></p><p>其中的代码在上述源码分析中可以找到（包含llvm_pass）</p><h3 id="AFL文件变异"><a href="#AFL文件变异" class="headerlink" title="AFL文件变异"></a>AFL文件变异</h3><p>这一部分先挖坑，因为没有具体阅读源码，只是收集到的资料，源码部分之后会补上</p><h4 id="bitflip"><a href="#bitflip" class="headerlink" title="bitflip"></a>bitflip</h4><ul><li>[自动检测token]: 在进行bitflip 1/1变异时，对于每个byte的最低位(least significant bit)翻转还进行了额外的处理：如果连续多个bytes的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致，那么就把这一段连续的bytes判断是一条token。</li><li>[生成effector map]: 在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在effector map中标记为1，即“有效”的，否则标记为0，即“无效”的。</li></ul><h4 id="arithmetic"><a href="#arithmetic" class="headerlink" title="arithmetic"></a>arithmetic</h4><p>加减</p><h4 id="interest"><a href="#interest" class="headerlink" title="interest"></a>interest</h4><p>特殊语料库的替换</p><h4 id="dictionary"><a href="#dictionary" class="headerlink" title="dictionary"></a>dictionary</h4><h4 id="havoc"><a href="#havoc" class="headerlink" title="havoc"></a>havoc</h4><h4 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h4><h4 id="cycle"><a href="#cycle" class="headerlink" title="cycle"></a>cycle</h4><h3 id="一个AFL优化策略"><a href="#一个AFL优化策略" class="headerlink" title="一个AFL优化策略"></a>一个AFL优化策略</h3><p>引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">为此，我对ELF文件变异和objdump执行路径变异进行了简单的试验，发现许多”数据“bytes被翻</span><br><span class="line">转后，确实能够引起执行路径的变化。但是，这些”数据“bytes往往是一块块分布在文件中的，</span><br><span class="line">而每一块”数据“中的每个bytes被翻转后，执行路径往往是相同的。所以，我们就有了一个朴素</span><br><span class="line">的想法：如果翻转一个byte引起执行路径变化，而且翻转该byte与翻转其前一个byte的执行路</span><br><span class="line">径不同，此时才将其视为“有效”的。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AFL-初探&quot;&gt;&lt;a href=&quot;#AFL-初探&quot; class=&quot;headerlink&quot; title=&quot;AFL 初探&quot;&gt;&lt;/a&gt;AFL 初探&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://barro.github.io/2018/06/afl-fuzz-on-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SmallNote</title>
    <link href="http://p1umer.club/2019/02/20/SmallNote/"/>
    <id>http://p1umer.club/2019/02/20/SmallNote/</id>
    <published>2019-02-20T07:00:54.000Z</published>
    <updated>2019-02-20T09:29:36.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="libfuzzer-build"><a href="#libfuzzer-build" class="headerlink" title="libfuzzer build"></a>libfuzzer build</h2><h3 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h3><p>环境Ubuntu16.04<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Dor1s/libfuzzer-workshop.git</span><br><span class="line">sudo sh checkout_build_install_llvm.sh</span><br><span class="line">sudo apt-get install -ymake autoconf automake libtool pkg-config zlib1g-dev</span><br><span class="line">cd libfuzzer-workshop/libFuzzer</span><br><span class="line">Fuzzer/build.sh</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/Dor1s/libfuzzer-workshop/" target="_blank" rel="noopener">libfuzzer-workship</a></p><h3 id="趁着编译的时候去详细了解一下libfuzzer其中的内存监控算法"><a href="#趁着编译的时候去详细了解一下libfuzzer其中的内存监控算法" class="headerlink" title="趁着编译的时候去详细了解一下libfuzzer其中的内存监控算法"></a>趁着编译的时候去详细了解一下libfuzzer其中的内存监控算法</h3><p><a href="http://clang.llvm.org/docs/AddressSanitizer.html" target="_blank" rel="noopener">AddressSanitizer</a></p><p><a href="https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm" target="_blank" rel="noopener">AddressSanitizer 分析</a></p><p><a href="https://blog.csdn.net/pang241/article/details/76137969" target="_blank" rel="noopener">AddressSanitizer 国产熟肉</a></p><p>The run-time library replaces the malloc and free functions. The memory around malloc-ed regions (red zones) is poisoned. The free-ed memory is placed in quarantine and also poisoned. ==Every memory access in the program is transformed by the compiler in the following way:==</p><p>Before: 变量赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*address = ...;  // or: ... = *address;</span><br></pre></td></tr></table></figure></p><p>After：加上检测<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (IsPoisoned(address)) &#123;</span><br><span class="line">  ReportError(address, kAccessSize, kIsWrite);</span><br><span class="line">&#125;</span><br><span class="line">*address = ...;  // or: ... = *address;</span><br></pre></td></tr></table></figure></p><p>Memory mapping and Instrumentation</p><ul><li>shadwos 和 main memory</li><li>编译器进行了如下插桩<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shadow_address = MemToShadow(address);</span><br><span class="line">if (ShadowIsPoisoned(shadow_address)) &#123;</span><br><span class="line">  Repozhuang&apos;tai&apos;yrtError(address, kAccessSize, kIsWrite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>并且针对shadows的one byte进行了与main memory的状态映射<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">byte *shadow_address = MemToShadow(address);</span><br><span class="line">byte shadow_value = *shadow_address;</span><br><span class="line">if (shadow_value) &#123;</span><br><span class="line">  if (SlowPathCheck(shadow_value, address, kAccessSize)) &#123;</span><br><span class="line">    ReportError(address, kAccessSize, kIsWrite);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Check the cases where we access first k bytes of the qword</span><br><span class="line">// and these k bytes are unpoisoned.</span><br><span class="line">bool SlowPathCheck(shadow_value, address, kAccessSize) &#123;</span><br><span class="line">  last_accessed_byte = (address &amp; 7) + kAccessSize - 1;</span><br><span class="line">  return (last_accessed_byte &gt;= shadow_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>针对全内存，判断poison==0 ：fastpath</p><p>针对非全内存，SlowPathCheck，(last_accessed_byte:最后写入的数据大小；shadow_value：能写入的数据大小)</p><p>针对部分fastpath不能满足的非对齐oob访问，我的想法是干脆放弃fastpath转用slowpath，结果看了issue发现确实是这样，但是有一定的性能损耗，得不偿失。</p><p>研究这部分算法也是得不偿失然鹅。。</p><p>对于栈做了如下插桩：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">  char redzone1[32];  // 32-byte aligned</span><br><span class="line">  char a[8];          // 32-byte aligned</span><br><span class="line">  char redzone2[24];</span><br><span class="line">  char redzone3[32];  // 32-byte aligned</span><br><span class="line">  int  *shadow_base = MemToShadow(redzone1);</span><br><span class="line">  shadow_base[0] = 0xffffffff;  // poison redzone1</span><br><span class="line">  shadow_base[1] = 0xffffff00;  // poison redzone2, unpoison &apos;a&apos;</span><br><span class="line">  shadow_base[2] = 0xffffffff;  // poison redzone3</span><br><span class="line">  ...</span><br><span class="line">  shadow_base[0] = shadow_base[1] = shadow_base[2] = 0; // unpoison all</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="addresssanitize-源码分析："><a href="#addresssanitize-源码分析：" class="headerlink" title="addresssanitize 源码分析："></a>addresssanitize 源码分析：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">bool AddressSanitizerModule::runOnModule(Module &amp;M) &#123;</span><br><span class="line">  C = &amp;(M.getContext());</span><br><span class="line">  int LongSize = M.getDataLayout().getPointerSizeInBits();</span><br><span class="line">  IntptrTy = Type::getIntNTy(*C, LongSize);</span><br><span class="line">  TargetTriple = Triple(M.getTargetTriple());</span><br><span class="line">  Mapping = getShadowMapping(TargetTriple, LongSize, CompileKernel);</span><br><span class="line">  initializeCallbacks(M);</span><br><span class="line"></span><br><span class="line">  if (CompileKernel)</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">  // Create a module constructor. A destructor is created lazily because not all</span><br><span class="line">  // platforms, and not all modules need it.</span><br><span class="line">  std::string VersionCheckName =</span><br><span class="line">      kAsanVersionCheckNamePrefix + std::to_string(GetAsanVersion(M));</span><br><span class="line">  std::tie(AsanCtorFunction, std::ignore) = createSanitizerCtorAndInitFunctions(</span><br><span class="line">      M, kAsanModuleCtorName, kAsanInitName, /*InitArgTypes=*/&#123;&#125;,</span><br><span class="line">      /*InitArgs=*/&#123;&#125;, VersionCheckName);</span><br><span class="line"></span><br><span class="line">  bool CtorComdat = true;</span><br><span class="line">  bool Changed = false;</span><br><span class="line">  // TODO(glider): temporarily disabled globals instrumentation for KASan.</span><br><span class="line">  if (ClGlobals) &#123;</span><br><span class="line">    IRBuilder&lt;&gt; IRB(AsanCtorFunction-&gt;getEntryBlock().getTerminator());</span><br><span class="line">    Changed |= InstrumentGlobals(IRB, M, &amp;CtorComdat);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Put the constructor and destructor in comdat if both</span><br><span class="line">  // (1) global instrumentation is not TU-specific</span><br><span class="line">  // (2) target is ELF.</span><br><span class="line">  if (UseCtorComdat &amp;&amp; TargetTriple.isOSBinFormatELF() &amp;&amp; CtorComdat) &#123;</span><br><span class="line">    AsanCtorFunction-&gt;setComdat(M.getOrInsertComdat(kAsanModuleCtorName));</span><br><span class="line">    appendToGlobalCtors(M, AsanCtorFunction, kAsanCtorAndDtorPriority,</span><br><span class="line">                        AsanCtorFunction);</span><br><span class="line">    if (AsanDtorFunction) &#123;</span><br><span class="line">      AsanDtorFunction-&gt;setComdat(M.getOrInsertComdat(kAsanModuleDtorName));</span><br><span class="line">      appendToGlobalDtors(M, AsanDtorFunction, kAsanCtorAndDtorPriority,</span><br><span class="line">                          AsanDtorFunction);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    appendToGlobalCtors(M, AsanCtorFunction, kAsanCtorAndDtorPriority);</span><br><span class="line">    if (AsanDtorFunction)</span><br><span class="line">      appendToGlobalDtors(M, AsanDtorFunction, kAsanCtorAndDtorPriority);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h3><ul><li>内存监控围绕 RZ 插桩来实现</li><li>对一些内存的状态进行shadow的映射，访问的时候进行状态检测</li></ul><p>libfuzzer貌似编译完了，我去看看</p><h3 id="radamsa"><a href="#radamsa" class="headerlink" title="radamsa"></a>radamsa</h3><p><a href="http://www.cs.tut.fi/tapahtumat/testaus12/kalvot/Wieser_20120606radamsa-coverage.pdf" target="_blank" rel="noopener">radamsa</a></p><h3 id="学习libfuzzer中遇到的种种："><a href="#学习libfuzzer中遇到的种种：" class="headerlink" title="学习libfuzzer中遇到的种种："></a>学习libfuzzer中遇到的种种：</h3><ul><li>有corpus</li><li>LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)的data是随机的，但size需要自己设置 max_len.</li><li><a href="https://clang.llvm.org/docs/SanitizerCoverage.html" target="_blank" rel="noopener">libfuzzer option 指北</a></li><li>编译时用到的参数可以在 clang -help 中查看</li><li>-fsanitize=address： 表示使用 AddressSanitizer</li><li>-fsanitize-coverage=trace-pc-guard: 为 libfuzzer 提供代码覆盖率信息</li><li>Seed: 1608565063 说明这次的种子数据</li><li>-max_len is not provided, using 64 ， -max_len 用于设置最大的数据长度，默认为 64</li><li>ASAN_OPTIONS=symbolize=1 ./first_fuzzer ./crash-id 显示栈</li><li>简单来说，如果我们要 fuzz 一个程序，找到一个入口函数，然后利用LLVMFuzzerTestOneInput就可以完成基本功能，然鹅：</li><li>我发现libfuzzer-interface还有几个接口类似于LLVMFuzzerCustomMutator。</li></ul><h3 id="练习写第一个fuzzer"><a href="#练习写第一个fuzzer" class="headerlink" title="练习写第一个fuzzer"></a>练习写第一个fuzzer</h3><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><p>测试最基本的溢出</p><h4 id="编译选项："><a href="#编译选项：" class="headerlink" title="编译选项："></a>编译选项：</h4><p>【+】 -fsanitize=fuzzer: 代码覆盖率</p><p>【+】 -fsanitize=address：启用 AddressSanitizer</p><p>【+】 -g：详细调试信息</p><h4 id="运行选项："><a href="#运行选项：" class="headerlink" title="运行选项："></a>运行选项：</h4><p>【+】 -seed：制定随机数 </p><p>【+】 -max_len：指定 Data 最大长度</p><p>【+】 +dir: 指定 corpus</p><h3 id="第二个"><a href="#第二个" class="headerlink" title="第二个"></a>第二个</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">constexpr auto kMagicHeader = &quot;ZN_2016&quot;;</span><br><span class="line">constexpr std::size_t kMaxPacketLen = 1024;</span><br><span class="line">constexpr std::size_t kMaxBodyLength = 1024 - sizeof(kMagicHeader);</span><br><span class="line"></span><br><span class="line">bool VulnerableFunction2(const uint8_t* data, size_t size, bool verify_hash) &#123;</span><br><span class="line">  if (size &lt; sizeof(kMagicHeader))</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">  std::string header(reinterpret_cast&lt;const char*&gt;(data), sizeof(kMagicHeader));</span><br><span class="line"></span><br><span class="line">  std::array&lt;uint8_t, kMaxBodyLength&gt; body;</span><br><span class="line"></span><br><span class="line">  if (strcmp(kMagicHeader, header.c_str()))</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">  auto target_hash = data[--size];</span><br><span class="line"></span><br><span class="line">  if (size &gt; kMaxPacketLen)</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">  if (!verify_hash)</span><br><span class="line">    return true;</span><br><span class="line"></span><br><span class="line">  std::copy(data, data + size, body.data());</span><br><span class="line">  auto real_hash = DummyHash(body);</span><br><span class="line">  return real_hash == target_hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fuzzer_code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;vulnerable_functions.h&quot;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) &#123;</span><br><span class="line">  VulnerableFunction2(data, size, true);</span><br><span class="line">  VulnerableFunction2(data, size, false);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有个tip：bool类型的变量太好遍历了，为了覆盖率测试两次就好:)</p><p>但是会如何影响覆盖率呢？是不是覆盖的呢？</p><p>试一试把原函数中return true去掉，fuzzer.cc换成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;vulnerable_functions.h&quot;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) &#123;</span><br><span class="line">  VulnerableFunction2(data, size, false);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>覆盖率25，上一个覆盖率也是25（均crash）</p><p>再去掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (!verify_hash)</span><br></pre></td></tr></table></figure></p><p>覆盖率降为24</p><p>wow很清晰：覆盖率就是整个fuzzer一趟测试触及的 basic-block 总个数。</p><h3 id="第三个"><a href="#第三个" class="headerlink" title="第三个"></a>第三个</h3><p>加了一个&amp; :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constexpr std::size_t kZn2016VerifyHashFlag = 0x0001000;</span><br><span class="line"></span><br><span class="line">bool VulnerableFunction3(const uint8_t* data, size_t size, std::size_t flags) &#123;</span><br><span class="line">  bool verify_hash = flags &amp; kZn2016VerifyHashFlag;</span><br><span class="line">  return VulnerableFunction2(data, size, verify_hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么还是遍历一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) &#123;</span><br><span class="line"></span><br><span class="line">  VulnerableFunction3(data, size, 0x00);</span><br><span class="line">  VulnerableFunction3(data, size, 0x1001);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>crash:)</p><h3 id="第四个"><a href="#第四个" class="headerlink" title="第四个"></a>第四个</h3><p>写到这里想到，写fuzz的目的就是crashcrashcrash，所以尽可能调整fuzz代码达到crash即可，没必要局限于格式。</p><p>开始第四个CVE-2014-0160:</p><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar xzf openssl1.0.1f.tgz</span><br><span class="line">cd openssl1.0.1f/</span><br><span class="line"></span><br><span class="line">./config</span><br><span class="line">make clean</span><br><span class="line">make CC=&quot;clang -O2 -fno-omit-frame-pointer -g -fsanitize=address -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-gep,trace-div&quot; -j$(nproc)</span><br></pre></td></tr></table></figure><p>fuzzer.cc:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// Copyright 2016 Google Inc. All Rights Reserved.</span><br><span class="line">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line">#include &lt;openssl/ssl.h&gt;</span><br><span class="line">#include &lt;openssl/err.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stddef.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef CERT_PATH</span><br><span class="line"># define CERT_PATH</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) &#123;</span><br><span class="line">  SSL_library_init();</span><br><span class="line">  SSL_load_error_strings();</span><br><span class="line">  ERR_load_BIO_strings();</span><br><span class="line">  OpenSSL_add_all_algorithms();</span><br><span class="line">  SSL_CTX *sctx;</span><br><span class="line">  assert (sctx = SSL_CTX_new(TLSv1_method()));</span><br><span class="line">  assert(SSL_CTX_use_certificate_file(sctx, CERT_PATH &quot;server.pem&quot;,</span><br><span class="line">                                      SSL_FILETYPE_PEM));</span><br><span class="line">  assert(SSL_CTX_use_PrivateKey_file(sctx, CERT_PATH &quot;server.key&quot;,</span><br><span class="line">                                     SSL_FILETYPE_PEM));</span><br><span class="line">  SSL *server = SSL_new(sctx);</span><br><span class="line">  BIO *sinbio = BIO_new(BIO_s_mem());</span><br><span class="line">  BIO *soutbio = BIO_new(BIO_s_mem());</span><br><span class="line">  SSL_set_bio(server, sinbio, soutbio);</span><br><span class="line">  SSL_set_accept_state(server);</span><br><span class="line">  BIO_write(sinbio, Data, Size);</span><br><span class="line">  SSL_do_handshake(server);</span><br><span class="line">  SSL_free(server);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ -g openssl_fuzzer.cc -O2 -fno-omit-frame-pointer -fsanitize=address -fsanitize-coverage=trace-pc-guard,trace-cmp,trace-gep,trace-div     -I openssl1.0.1f/include openssl1.0.1f/libssl.a openssl1.0.1f/libcrypto.a     ../../libFuzzer/libFuzzer.a -o openssl_fuzzer</span><br></pre></td></tr></table></figure></p><p>跑出来了好几次 oom 和 leakmem ？</p><ul><li>去掉 leak</li><li>扩大内存<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./openssl_fuzzer -detect_leaks=0 -rss_limit_mb=4096</span><br></pre></td></tr></table></figure></li></ul><p>花了一分钟才跑出来crash，why？？？</p><p>如果把初始化api分开来看呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// Copyright 2016 Google Inc. All Rights Reserved.</span><br><span class="line">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line">#include &lt;openssl/ssl.h&gt;</span><br><span class="line">#include &lt;openssl/err.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stddef.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef CERT_PATH</span><br><span class="line"># define CERT_PATH</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">SSL_CTX *Init() &#123;</span><br><span class="line">  SSL_library_init();</span><br><span class="line">  SSL_load_error_strings();</span><br><span class="line">  ERR_load_BIO_strings();</span><br><span class="line">  OpenSSL_add_all_algorithms();</span><br><span class="line">  SSL_CTX *sctx;</span><br><span class="line">  assert (sctx = SSL_CTX_new(TLSv1_method()));</span><br><span class="line">  /* These two file were created with this command:</span><br><span class="line">      openssl req -x509 -newkey rsa:512 -keyout server.key \</span><br><span class="line">     -out server.pem -days 9999 -nodes -subj /CN=a/</span><br><span class="line">  */</span><br><span class="line">  assert(SSL_CTX_use_certificate_file(sctx, CERT_PATH &quot;server.pem&quot;,</span><br><span class="line">                                      SSL_FILETYPE_PEM));</span><br><span class="line">  assert(SSL_CTX_use_PrivateKey_file(sctx, CERT_PATH &quot;server.key&quot;,</span><br><span class="line">                                     SSL_FILETYPE_PEM));</span><br><span class="line">  return sctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) &#123;</span><br><span class="line">  static SSL_CTX *sctx = Init();</span><br><span class="line">  SSL *server = SSL_new(sctx);</span><br><span class="line">  BIO *sinbio = BIO_new(BIO_s_mem());</span><br><span class="line">  BIO *soutbio = BIO_new(BIO_s_mem());</span><br><span class="line">  SSL_set_bio(server, sinbio, soutbio);</span><br><span class="line">  SSL_set_accept_state(server);</span><br><span class="line">  BIO_write(sinbio, Data, Size);</span><br><span class="line">  SSL_do_handshake(server);</span><br><span class="line">  SSL_free(server);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>五秒钟？？？</p><p>到底是那点会影响 fuzz 效率呢。。。</p><h2 id="llvm-PASS"><a href="#llvm-PASS" class="headerlink" title="llvm PASS"></a>llvm PASS</h2><p>这一段当成是插入的知识，再看 ASAN 源码过程中意识到编写llvm pass 一定会对以后独自编写 fuzzer 框架有用的，因此今天除了接着研究ASAN源码之余要学习一下llvm pass的编写，目标是熟练掌握 ModulePass 以及 FunctionPass。</p><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p><a href="http://www.voidcn.com/article/p-mgwevrjr-brn.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-mgwevrjr-brn.html</a><br><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-modulepass-class" target="_blank" rel="noopener">http://llvm.org/docs/WritingAnLLVMPass.html#the-modulepass-class</a><br><a href="https://zhuanlan.zhihu.com/p/26129264" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26129264</a><br><a href="https://blog.csdn.net/Mr_Megamind/article/details/78896717" target="_blank" rel="noopener">https://blog.csdn.net/Mr_Megamind/article/details/78896717</a></p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git</span><br><span class="line">mkdir LLVM &amp;&amp; cd LLVM</span><br><span class="line">git clone https://github.com/llvm-mirror/llvm.git</span><br><span class="line">cd llvm</span><br><span class="line"></span><br><span class="line">cd tools</span><br><span class="line">git clone https://github.com/llvm-mirror/clang.git</span><br><span class="line">cd ..</span><br><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line"></span><br><span class="line">cd ~</span><br><span class="line">mkdir KLLVM</span><br><span class="line">cd LLVM/llvm/build</span><br><span class="line">cmake -DLLVM_TARGETS_TO_BUILD=host -DCMAKE_INSTALL_PREFIX=~/KLLVM -DCMAKE_BUILD_TYPE=MinSizeRel -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=WebAssembly -DLLVM_INCLUDE_EXAMPLES=OFF -DLLVM_INCLUDE_TESTS=OFF -DCLANG_INCLUDE_TESTS=OFF ..</span><br><span class="line"></span><br><span class="line">cmake --build . --target install -- -j3</span><br></pre></td></tr></table></figure><h3 id="使用clang"><a href="#使用clang" class="headerlink" title="使用clang"></a>使用clang</h3><p>hello.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">  printf(&quot;hello worldn&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>complier it<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang hello.c -o hello</span><br></pre></td></tr></table></figure></p><p>输出llvmbitcode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -O3 -emit-llvm hello.c -c -o hello.bc</span><br></pre></td></tr></table></figure></p><p>-emit-llvm选项可与-S或-c选项一起使用，以分别为代码生成LLVM .ll或.bc文件。两者都是LLVM Bitcode，区别在于前者是可读的文本，后者是不可读的二进制格式。</p><p>使用lli执行.bc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lli hello.bc</span><br></pre></td></tr></table></figure></p><p>使用llvm-dis对.bc反汇编<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llvm-dis &lt; hello.bc</span><br></pre></td></tr></table></figure></p><p>使用llc将.bc生成.s<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc hello.bc -o hello.s</span><br></pre></td></tr></table></figure></p><h4 id="常用的编译选项："><a href="#常用的编译选项：" class="headerlink" title="常用的编译选项："></a>常用的编译选项：</h4><ul><li>-c： 只激活预处理,编译,和汇编,也就是他只把程序做成obj文件</li><li>-S： 只激活预处理和编译，就是指把文件编译成为汇编代码。</li><li>-O+num：优化等级</li><li>-emit-llvm：llvmbitcode 可与-c或-S 一同使用，但不能有链接</li></ul><h3 id="llvm-IR"><a href="#llvm-IR" class="headerlink" title="llvm IR"></a>llvm IR</h3><p><a href="https://releases.llvm.org/2.6/docs/tutorial/JITTutorial1.html" target="_blank" rel="noopener">https://releases.llvm.org/2.6/docs/tutorial/JITTutorial1.html</a><br><a href="https://releases.llvm.org/2.6/docs/LangRef.html" target="_blank" rel="noopener">https://releases.llvm.org/2.6/docs/LangRef.html</a></p><p>这块先挖个坑，过年后填回来。</p><p>我来填坑了：</p><h4 id="Identifiers"><a href="#Identifiers" class="headerlink" title="Identifiers"></a>Identifiers</h4><ul><li>全局变量：@</li><li>局部有命名的变量：%+string</li><li>局部未命名的变量：%+num</li><li>注释：；</li><li>如果计算结果未分配给命名值，则会创建未命名的临时值。</li><li>未命名的临时数据按顺序编号</li></ul><h5 id="High-Level-Structure"><a href="#High-Level-Structure" class="headerlink" title="High Level Structure"></a>High Level Structure</h5><ul><li>Module 是llvm的翻译单元</li><li>每个Module包含functions，全局变量以及符号表</li><li>module可以被llvm-linker操作</li><li>function和全局变量都可以被看作global value</li></ul><h5 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h5><ul><li><p>ret: </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret &lt;type&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret i32 5                       </span><br><span class="line">ret void                        </span><br><span class="line">ret &#123; i32, i8 &#125; &#123; i32 4, i8 2 &#125; ; Return a struct of values 4 and 2</span><br></pre></td></tr></table></figure></li><li><p>br:  </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">br i1 &lt;cond&gt;, label &lt;iftrue&gt;, label &lt;iffalse&gt;</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Test:</span><br><span class="line">  %cond = icmp eq i32 %a, %b</span><br><span class="line">  br i1 %cond, label %IfEqual, label %IfUnequal</span><br><span class="line">IfEqual:</span><br><span class="line">  ret i32 1</span><br><span class="line">IfUnequal:</span><br><span class="line">  ret i32 0</span><br></pre></td></tr></table></figure></li><li><p>switch:  </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch &lt;intty&gt; &lt;value&gt;, label &lt;defaultdest&gt; [ &lt;intty&gt; &lt;val&gt;, label &lt;dest&gt; ... ]</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; Emulate a conditional br instruction</span><br><span class="line"> %Val = zext i1 %value to i32</span><br><span class="line"> switch i32 %Val, label %truedest [ i32 0, label %falsedest ]</span><br><span class="line"></span><br><span class="line"> ; Emulate an unconditional br instruction</span><br><span class="line"> switch i32 0, label %dest [ ]</span><br><span class="line"></span><br><span class="line"> ; Implement a jump table:</span><br><span class="line"> switch i32 %val, label %otherwise [ i32 0, label %onzero</span><br><span class="line">                                     i32 1, label %onone</span><br><span class="line">                                     i32 2, label %ontwo ]</span><br></pre></td></tr></table></figure></li><li><p>invoke： </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = invoke [cconv] [ret attrs] &lt;ptr to function ty&gt; &lt;function ptr val&gt;(&lt;function args&gt;) [fn attrs]</span><br><span class="line">            to label &lt;normal label&gt; unwind label &lt;exception label&gt;</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  %retval = invoke i32 @Test(i32 15) to label %Continue</span><br><span class="line">            unwind label %TestCleanup              ; &#123;i32&#125;:retval set</span><br><span class="line">%retval = invoke coldcc i32 %Testfnptr(i32 15) to label %Continue</span><br><span class="line">            unwind label %TestCleanup              ; &#123;i32&#125;:retval set</span><br></pre></td></tr></table></figure></li></ul><h3 id="熟悉-LLVM-API-使用"><a href="#熟悉-LLVM-API-使用" class="headerlink" title="熟悉 LLVM API 使用"></a>熟悉 LLVM API 使用</h3><p>code1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">using namespace llvm;</span><br><span class="line"></span><br><span class="line">Module* makeLLVMModule() &#123;</span><br><span class="line">  // Module Construction</span><br><span class="line">  Module* mod = new Module(&quot;test&quot;, getGlobalContext());</span><br><span class="line">  Constant* c = mod-&gt;getOrInsertFunction(&quot;mul_add&quot;,</span><br><span class="line">  /*ret type*/                           IntegerType::get(32),</span><br><span class="line">  /*args*/                               IntegerType::get(32),</span><br><span class="line">                                         IntegerType::get(32),</span><br><span class="line">                                         IntegerType::get(32),</span><br><span class="line">  /*varargs terminated with null*/       NULL);</span><br><span class="line">  </span><br><span class="line">  Function* mul_add = cast&lt;Function&gt;(c);</span><br><span class="line">  mul_add-&gt;setCallingConv(CallingConv::C);</span><br><span class="line">  </span><br><span class="line">  Function::arg_iterator args = mul_add-&gt;arg_begin();</span><br><span class="line">  Value* x = args++;</span><br><span class="line">  x-&gt;setName(&quot;x&quot;);</span><br><span class="line">  Value* y = args++;</span><br><span class="line">  y-&gt;setName(&quot;y&quot;);</span><br><span class="line">  Value* z = args++;</span><br><span class="line">  z-&gt;setName(&quot;z&quot;);</span><br><span class="line">  </span><br><span class="line">  BasicBlock* block = BasicBlock::Create(getGlobalContext(), &quot;entry&quot;, mul_add);</span><br><span class="line">  IRBuilder&lt;&gt; builder(block);</span><br><span class="line">  </span><br><span class="line">  Value* tmp = builder.CreateBinOp(Instruction::Mul,</span><br><span class="line">                                   x, y, &quot;tmp&quot;);</span><br><span class="line">  Value* tmp2 = builder.CreateBinOp(Instruction::Add,</span><br><span class="line">                                    tmp, z, &quot;tmp2&quot;);</span><br><span class="line"></span><br><span class="line">  builder.CreateRet(tmp2);</span><br><span class="line">  </span><br><span class="line">  return mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char**argv) &#123;</span><br><span class="line">  Module* Mod = makeLLVMModule();</span><br><span class="line"></span><br><span class="line">  verifyModule(*Mod, PrintMessageAction);</span><br><span class="line"></span><br><span class="line">  PassManager PM;</span><br><span class="line">  PM.add(createPrintModulePass(&amp;outs()));</span><br><span class="line">  PM.run(*Mod);</span><br><span class="line"></span><br><span class="line">  delete Mod;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>code2:</p><p><note>:llvm 有自动的名称唯一性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Module* makeLLVMModule() &#123;</span><br><span class="line">    // constract module</span><br><span class="line">    Module* mod = new Module(&quot;test&quot;, getGlobalContext());</span><br><span class="line">    </span><br><span class="line">    // constract func </span><br><span class="line">    Constant* c = mod-&gt;getOrInsertFunction(&quot;mul_add&quot;,</span><br><span class="line">    /*ret type*/                           IntegerType::get(32),</span><br><span class="line">    /*args*/                               IntegerType::get(32),</span><br><span class="line">                                           IntegerType::get(32),</span><br><span class="line">    /*varargs terminated with null*/       NULL);</span><br><span class="line">    </span><br><span class="line">    // cast this function</span><br><span class="line">    Function* gcd = cast&lt;Function&gt;(c);</span><br><span class="line">    </span><br><span class="line">    //set arg</span><br><span class="line">    Function::arg_iterator args = gcd-&gt;arg_begin();</span><br><span class="line">    Value* x = args++;</span><br><span class="line">    x-&gt;setName(&quot;x&quot;);</span><br><span class="line">    Value* y = args++;</span><br><span class="line">    y-&gt;setName(&quot;y&quot;);</span><br><span class="line">    </span><br><span class="line">    //set basic blocks</span><br><span class="line">    BasicBlock* entry = BasicBlock::Create(getGlobalContext(), (&quot;entry&quot;, gcd);</span><br><span class="line">    BasicBlock* ret = BasicBlock::Create(getGlobalContext(), (&quot;return&quot;, gcd);</span><br><span class="line">    BasicBlock* cond_false = BasicBlock::Create(getGlobalContext(), (&quot;cond_false&quot;, gcd);</span><br><span class="line">    BasicBlock* cond_true = BasicBlock::Create(getGlobalContext(), (&quot;cond_true&quot;, gcd);</span><br><span class="line">    BasicBlock* cond_false_2 = BasicBlock::Create(getGlobalContext(), (&quot;cond_false&quot;, gcd);</span><br><span class="line">    </span><br><span class="line">    //use  IRBuild to fill the &lt;entry&gt; basicblocks</span><br><span class="line">    IRBuilder&lt;&gt; builder(entry);</span><br><span class="line">    </span><br><span class="line">    //fill</span><br><span class="line">    Value* xEqualsY = builder.CreateICmpEQ(x, y, &quot;tmp&quot;);</span><br><span class="line">    builder.CreateCondBr(xEqualsY, ret, cond_false);</span><br><span class="line">    </span><br><span class="line">    //use &lt;SetInsertPoint&gt; to retarget the targetBB</span><br><span class="line">    builder.SetInsertPoint(ret);</span><br><span class="line">    </span><br><span class="line">    //fill</span><br><span class="line">    builder.CreateRet(x);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    builder.SetInsertPoint(cond_true);</span><br><span class="line">    Value* yMinusX = builder.CreateSub(y, x, &quot;tmp&quot;);</span><br><span class="line">    std::vector&lt;Value*&gt; args1;</span><br><span class="line">    args1.push_back(x);</span><br><span class="line">    args1.push_back(yMinusX);</span><br><span class="line">    Value* recur_1 = builder.CreateCall(gcd, args1.begin(), args1.end(), &quot;tmp&quot;);</span><br><span class="line">    builder.CreateRet(recur_1);</span><br><span class="line">    </span><br><span class="line">    builder.SetInsertPoint(cond_false_2);</span><br><span class="line">    Value* xMinusY = builder.CreateSub(x, y, &quot;tmp&quot;);</span><br><span class="line">    std::vector&lt;Value*&gt; args2;</span><br><span class="line">    args2.push_back(xMinusY);</span><br><span class="line">    args2.push_back(y);</span><br><span class="line">    Value* recur_2 = builder.CreateCall(gcd, args2.begin(), args2.end(), &quot;tmp&quot;);</span><br><span class="line">    builder.CreateRet(recur_2);</span><br><span class="line">    </span><br><span class="line">    return mod;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char**argv) &#123;</span><br><span class="line">  Module* Mod = makeLLVMModule();</span><br><span class="line"></span><br><span class="line">  verifyModule(*Mod, PrintMessageAction);</span><br><span class="line"></span><br><span class="line">  PassManager PM;</span><br><span class="line">  PM.add(createPrintModulePass(&amp;outs()));</span><br><span class="line">  PM.run(*Mod);</span><br><span class="line"></span><br><span class="line">  delete Mod;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></note></p><h3 id="环境配置-1"><a href="#环境配置-1" class="headerlink" title="环境配置"></a>环境配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git</span><br><span class="line">mkdir LLVM &amp;&amp; cd LLVM</span><br><span class="line">git clone https://github.com/llvm-mirror/llvm.git</span><br><span class="line">cd llvm</span><br><span class="line"></span><br><span class="line">cd tools</span><br><span class="line">git clone https://github.com/llvm-mirror/clang.git</span><br><span class="line">cd ..</span><br><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line"></span><br><span class="line">cd ~</span><br><span class="line">mkdir KLLVM</span><br><span class="line">cd LLVM/llvm/build</span><br><span class="line">cmake -DLLVM_TARGETS_TO_BUILD=host -DCMAKE_INSTALL_PREFIX=~/KLLVM -DCMAKE_BUILD_TYPE=MinSizeRel -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=WebAssembly -DLLVM_INCLUDE_EXAMPLES=OFF -DLLVM_INCLUDE_TESTS=OFF -DCLANG_INCLUDE_TESTS=OFF ..</span><br><span class="line"></span><br><span class="line">cmake --build . --target install -- -j3</span><br></pre></td></tr></table></figure><h3 id="CMakeList"><a href="#CMakeList" class="headerlink" title="CMakeList"></a>CMakeList</h3><p>使用cmake<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;project dir&gt;/</span><br><span class="line">    |</span><br><span class="line">    CMakeLists.txt</span><br><span class="line">    &lt;pass name&gt;/</span><br><span class="line">        |</span><br><span class="line">        CMakeLists.txt</span><br><span class="line">        Pass.cpp</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><p><project dir="">/CMakeLists.txt:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find_package(LLVM REQUIRED CONFIG)</span><br><span class="line"></span><br><span class="line">add_definitions($&#123;LLVM_DEFINITIONS&#125;)</span><br><span class="line">include_directories($&#123;LLVM_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line">add_subdirectory(&lt;pass name&gt;)</span><br></pre></td></tr></table></figure></project></p><p>cmake1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(NOT DEFINED ENV&#123;LLVM_HOME&#125;)</span><br><span class="line">    message(FATAL_ERROR &quot;$LLVM_HOME is not defined&quot;)</span><br><span class="line">endif()</span><br><span class="line">if(NOT DEFINED ENV&#123;LLVM_DIR&#125;)</span><br><span class="line">    set(ENV&#123;LLVM_DIR&#125; $ENV&#123;LLVM_HOME&#125;/lib/cmake/llvm)</span><br><span class="line">endif()</span><br><span class="line">find_package(LLVM REQUIRED CONFIG)</span><br><span class="line">add_definitions($&#123;LLVM_DEFINITIONS&#125;)</span><br><span class="line">include_directories($&#123;LLVM_INCLUDE_DIRS&#125;)</span><br><span class="line">link_directories($&#123;LLVM_LIBRARY_DIRS&#125;)</span><br><span class="line"> </span><br><span class="line">add_subdirectory(P1umer)  # Use your pass name here.</span><br></pre></td></tr></table></figure></p><p>cmake2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add_library(P1umerPass MODULE</span><br><span class="line">    # List your source files here.</span><br><span class="line">    P1umer.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Use C++11 to compile your pass (i.e., supply -std=c++11).</span><br><span class="line">target_compile_features(P1umerPass PRIVATE cxx_range_for cxx_auto_type)</span><br><span class="line"></span><br><span class="line"># LLVM is (typically) built with no C++ RTTI. We need to match that;</span><br><span class="line"># otherwise, we&apos;ll get linker errors about missing RTTI data.</span><br><span class="line">set_target_properties(P1umerPass PROPERTIES</span><br><span class="line">    COMPILE_FLAGS &quot;-fno-rtti&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="编写一个入门的pass示例"><a href="#编写一个入门的pass示例" class="headerlink" title="编写一个入门的pass示例"></a>编写一个入门的pass示例</h3><p><img src="https://upload-images.jianshu.io/upload_images/1460317-e7593ef3362b5f55.png?imageMogr2/auto-orient/" alt="image"></p><p>p1umer.cpp:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;llvm/Pass.h&quot;</span><br><span class="line">#include &quot;llvm/IR/Function.h&quot;</span><br><span class="line">#include &quot;llvm/Support/raw_ostream.h&quot;</span><br><span class="line">#include &quot;llvm/IR/LegacyPassManager.h&quot;</span><br><span class="line">#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span><br><span class="line">using namespace llvm;</span><br><span class="line"></span><br><span class="line">namespace &#123;</span><br><span class="line">  struct P1umerPass : public FunctionPass &#123;</span><br><span class="line">    static char ID;</span><br><span class="line">    P1umerPass() : FunctionPass(ID) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    virtual bool doInitialization(Module &amp;) override &#123;</span><br><span class="line"></span><br><span class="line">        printf(&quot;11111111111\n&quot;);</span><br><span class="line">return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual bool doFinalization(Module &amp;) &#123; </span><br><span class="line">printf(&quot;22222222222\n&quot;);</span><br><span class="line">return false; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual bool runOnFunction(Function &amp;F) &#123;</span><br><span class="line">      errs() &lt;&lt; &quot;I saw a function called &quot; &lt;&lt; F.getName() &lt;&lt; &quot;!\n&quot;;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char P1umerPass::ID = 0;</span><br><span class="line"></span><br><span class="line">// Automatically enable the pass.</span><br><span class="line">// http://adriansampson.net/blog/clangpass.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static RegisterPass&lt;P1umerPass&gt; X(&quot;P1umer&quot;, &quot;Hello P1umer&quot;);</span><br></pre></td></tr></table></figure></p><p>use it:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang -c -emit-llvm hello.c -o hello.bc</span><br><span class="line">opt -load ./libP1umerPass.so  -P1umer hello.bc</span><br></pre></td></tr></table></figure></p><p>output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11111111111</span><br><span class="line">I saw a function called mul_add!</span><br><span class="line">22222222222</span><br></pre></td></tr></table></figure></p><h3 id="熟悉依照CFG构建代码"><a href="#熟悉依照CFG构建代码" class="headerlink" title="熟悉依照CFG构建代码"></a>熟悉依照CFG构建代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">using namespace llvm;</span><br><span class="line"></span><br><span class="line">Module* makeLLVMModule() &#123;</span><br><span class="line">  // Module Construction</span><br><span class="line">  Module* mod = new Module(&quot;test&quot;, getGlobalContext());</span><br><span class="line">  Constant* c = mod-&gt;getOrInsertFunction(&quot;mul_add&quot;,</span><br><span class="line">  /*ret type*/                           IntegerType::get(32),</span><br><span class="line">  /*args*/                               IntegerType::get(32),</span><br><span class="line">                                         IntegerType::get(32),</span><br><span class="line">                                         IntegerType::get(32),</span><br><span class="line">  /*varargs terminated with null*/       NULL);</span><br><span class="line">  </span><br><span class="line">  Function* mul_add = cast&lt;Function&gt;(c);</span><br><span class="line">  mul_add-&gt;setCallingConv(CallingConv::C);</span><br><span class="line">  </span><br><span class="line">  Function::arg_iterator args = mul_add-&gt;arg_begin();</span><br><span class="line">  Value* x = args++;</span><br><span class="line">  x-&gt;setName(&quot;x&quot;);</span><br><span class="line">  Value* y = args++;</span><br><span class="line">  y-&gt;setName(&quot;y&quot;);</span><br><span class="line">  Value* z = args++;</span><br><span class="line">  z-&gt;setName(&quot;z&quot;);</span><br><span class="line">  </span><br><span class="line">  BasicBlock* block = BasicBlock::Create(getGlobalContext(), &quot;entry&quot;, mul_add);</span><br><span class="line">  IRBuilder&lt;&gt; builder(block);</span><br><span class="line">  </span><br><span class="line">  Value* tmp = builder.CreateBinOp(Instruction::Mul,</span><br><span class="line">                                   x, y, &quot;tmp&quot;);</span><br><span class="line">  Value* tmp2 = builder.CreateBinOp(Instruction::Add,</span><br><span class="line">                                    tmp, z, &quot;tmp2&quot;);</span><br><span class="line"></span><br><span class="line">  builder.CreateRet(tmp2);</span><br><span class="line">  </span><br><span class="line">  return mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char**argv) &#123;</span><br><span class="line">  Module* Mod = makeLLVMModule();</span><br><span class="line"></span><br><span class="line">  verifyModule(*Mod, PrintMessageAction);</span><br><span class="line"></span><br><span class="line">  PassManager PM;</span><br><span class="line">  PM.add(createPrintModulePass(&amp;outs()));</span><br><span class="line">  PM.run(*Mod);</span><br><span class="line"></span><br><span class="line">  delete Mod;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>code2:</p><p><note>:llvm 有自动的名称唯一性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Module* makeLLVMModule() &#123;</span><br><span class="line">    // constract module</span><br><span class="line">    Module* mod = new Module(&quot;test&quot;, getGlobalContext());</span><br><span class="line">    </span><br><span class="line">    // constract func </span><br><span class="line">    Constant* c = mod-&gt;getOrInsertFunction(&quot;mul_add&quot;,</span><br><span class="line">    /*ret type*/                           IntegerType::get(32),</span><br><span class="line">    /*args*/                               IntegerType::get(32),</span><br><span class="line">                                           IntegerType::get(32),</span><br><span class="line">    /*varargs terminated with null*/       NULL);</span><br><span class="line">    </span><br><span class="line">    // cast this function</span><br><span class="line">    Function* gcd = cast&lt;Function&gt;(c);</span><br><span class="line">    </span><br><span class="line">    //set arg</span><br><span class="line">    Function::arg_iterator args = gcd-&gt;arg_begin();</span><br><span class="line">    Value* x = args++;</span><br><span class="line">    x-&gt;setName(&quot;x&quot;);</span><br><span class="line">    Value* y = args++;</span><br><span class="line">    y-&gt;setName(&quot;y&quot;);</span><br><span class="line">    </span><br><span class="line">    //set basic blocks</span><br><span class="line">    BasicBlock* entry = BasicBlock::Create(getGlobalContext(), (&quot;entry&quot;, gcd);</span><br><span class="line">    BasicBlock* ret = BasicBlock::Create(getGlobalContext(), (&quot;return&quot;, gcd);</span><br><span class="line">    BasicBlock* cond_false = BasicBlock::Create(getGlobalContext(), (&quot;cond_false&quot;, gcd);</span><br><span class="line">    BasicBlock* cond_true = BasicBlock::Create(getGlobalContext(), (&quot;cond_true&quot;, gcd);</span><br><span class="line">    BasicBlock* cond_false_2 = BasicBlock::Create(getGlobalContext(), (&quot;cond_false&quot;, gcd);</span><br><span class="line">    </span><br><span class="line">    //use  IRBuild to fill the &lt;entry&gt; basicblocks</span><br><span class="line">    IRBuilder&lt;&gt; builder(entry);</span><br><span class="line">    </span><br><span class="line">    //fill</span><br><span class="line">    Value* xEqualsY = builder.CreateICmpEQ(x, y, &quot;tmp&quot;);</span><br><span class="line">    builder.CreateCondBr(xEqualsY, ret, cond_false);</span><br><span class="line">    </span><br><span class="line">    //use &lt;SetInsertPoint&gt; to retarget the targetBB</span><br><span class="line">    builder.SetInsertPoint(ret);</span><br><span class="line">    </span><br><span class="line">    //fill</span><br><span class="line">    builder.CreateRet(x);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    builder.SetInsertPoint(cond_true);</span><br><span class="line">    Value* yMinusX = builder.CreateSub(y, x, &quot;tmp&quot;);</span><br><span class="line">    std::vector&lt;Value*&gt; args1;</span><br><span class="line">    args1.push_back(x);</span><br><span class="line">    args1.push_back(yMinusX);</span><br><span class="line">    Value* recur_1 = builder.CreateCall(gcd, args1.begin(), args1.end(), &quot;tmp&quot;);</span><br><span class="line">    builder.CreateRet(recur_1);</span><br><span class="line">    </span><br><span class="line">    builder.SetInsertPoint(cond_false_2);</span><br><span class="line">    Value* xMinusY = builder.CreateSub(x, y, &quot;tmp&quot;);</span><br><span class="line">    std::vector&lt;Value*&gt; args2;</span><br><span class="line">    args2.push_back(xMinusY);</span><br><span class="line">    args2.push_back(y);</span><br><span class="line">    Value* recur_2 = builder.CreateCall(gcd, args2.begin(), args2.end(), &quot;tmp&quot;);</span><br><span class="line">    builder.CreateRet(recur_2);</span><br><span class="line">    </span><br><span class="line">    return mod;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char**argv) &#123;</span><br><span class="line">  Module* Mod = makeLLVMModule();</span><br><span class="line"></span><br><span class="line">  verifyModule(*Mod, PrintMessageAction);</span><br><span class="line"></span><br><span class="line">  PassManager PM;</span><br><span class="line">  PM.add(createPrintModulePass(&amp;outs()));</span><br><span class="line">  PM.run(*Mod);</span><br><span class="line"></span><br><span class="line">  delete Mod;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></note></p><h3 id="编写一个稍复杂的pass"><a href="#编写一个稍复杂的pass" class="headerlink" title="编写一个稍复杂的pass"></a>编写一个稍复杂的pass</h3><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">官方文档</a></p><p>code1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">using namespace llvm;</span><br><span class="line"></span><br><span class="line">namespace &#123;</span><br><span class="line">  </span><br><span class="line">  struct IterInsideBB : public FunctionPass &#123;</span><br><span class="line">    static char ID; // Pass identification, replacement for typeid</span><br><span class="line">    IterInsideBB() : FunctionPass(ID) &#123;&#125;  </span><br><span class="line"></span><br><span class="line">    bool runOnFunction(Function &amp;F) override &#123;</span><br><span class="line">    errs() &lt;&lt; &quot;Function name: &quot;;</span><br><span class="line">    errs() &lt;&lt; F.getName() &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    for(Function::iterator bb = F.begin(), e = F.end(); bb!=e; bb++)</span><br><span class="line">    &#123;</span><br><span class="line">    errs()&lt;&lt;&quot;BasicBlock name = &quot;&lt;&lt; bb-&gt;getName() &lt;&lt;&quot;\n&quot;;</span><br><span class="line">    errs()&lt;&lt;&quot;BasicBlock size = &quot;&lt;&lt; bb-&gt;size() &lt;&lt; &quot;\n\n&quot;;</span><br><span class="line"></span><br><span class="line">    for(BasicBlock::iterator i = bb-&gt;begin(), i2 = bb-&gt;end(); i!=i2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    outs()&lt;&lt;&quot;    &quot;&lt;&lt; *i &lt;&lt;&quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char IterInsideBB::ID = 0;</span><br><span class="line">static RegisterPass&lt;IterInsideBB&gt; X(&quot;IterInsideBB&quot;, &quot;Iterate inside basicblocks inside a Function&quot;);</span><br></pre></td></tr></table></figure></p><p>code2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">namespace &#123;</span><br><span class="line">  </span><br><span class="line">  struct UseDef : public FunctionPass &#123;</span><br><span class="line">    static char ID; // Pass identification, replacement for typeid</span><br><span class="line">    UseDef() : FunctionPass(ID) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    bool runOnFunction(Function &amp;F) override &#123;</span><br><span class="line"></span><br><span class="line">    errs() &lt;&lt; &quot;Function name: &quot;;</span><br><span class="line">    errs() &lt;&lt; F.getName() &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    for(Function::iterator bb = F.begin(), e = F.end(); bb!=e; bb++)</span><br><span class="line">    &#123;</span><br><span class="line">    for(BasicBlock::iterator i = bb-&gt;begin(), i2 = bb-&gt;end(); i!=i2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">                Instruction * inst = dyn_cast&lt;Instruction&gt;(i);</span><br><span class="line">                if(inst-&gt;getOpcode() == Instruction::Add)</span><br><span class="line">                &#123;</span><br><span class="line">                    for(Use &amp;U: inst -&gt; operands())</span><br><span class="line">                    &#123;</span><br><span class="line">                        Value * v = U.get();</span><br><span class="line">                        outs()&lt;&lt; *v &lt;&lt;&quot;\n&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char UseDef::ID = 0;</span><br><span class="line">static RegisterPass&lt;UseDef&gt; X(&quot;UseDef&quot;, &quot;This is use-def Pass&quot;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;libfuzzer-build&quot;&gt;&lt;a href=&quot;#libfuzzer-build&quot; class=&quot;headerlink&quot; title=&quot;libfuzzer build&quot;&gt;&lt;/a&gt;libfuzzer build&lt;/h2&gt;&lt;h3 id=&quot;编译流程&quot;&gt;&lt;a href
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>P1umer 今天又咸鱼了吗</title>
    <link href="http://p1umer.club/2018/12/27/P1umer-%E4%BB%8A%E5%A4%A9%E5%8F%88%E5%92%B8%E9%B1%BC%E4%BA%86%E5%90%97/"/>
    <id>http://p1umer.club/2018/12/27/P1umer-今天又咸鱼了吗/</id>
    <published>2018-12-27T13:49:42.000Z</published>
    <updated>2019-03-19T17:40:28.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="27-12-2018"><a href="#27-12-2018" class="headerlink" title="27/12/2018"></a>27/12/2018</h1><p>昨晚重新做了个 ubuntu 虚拟机用来跑 libfuzzer，经过了几天的探索感觉对libfuzzer有点初步的认识了，然而意识到写libfuzzer最重要的还是熟悉对应代码的api，于是下一步打算好好看一看chrome ipc里面的函数调用关系(TODO)。但还是先从阅读chrome自带的ned-fuzzer。</p><h3 id="appcache-fuzzer-cc-结构"><a href="#appcache-fuzzer-cc-结构" class="headerlink" title="appcache_fuzzer.cc 结构"></a>appcache_fuzzer.cc 结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">namespace content&#123;</span><br><span class="line"></span><br><span class="line">    namespace&#123;</span><br><span class="line">    ···</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //注册</span><br><span class="line">    DEFINE_BINARY_PROTO_FUZZER(const fuzzing::proto::Session&amp; session)</span><br><span class="line">    &#123;</span><br><span class="line">        //Some Initialization</span><br><span class="line">        ···</span><br><span class="line">        //fuzzer?</span><br><span class="line">        for(commend:session)</span><br><span class="line">        &#123;</span><br><span class="line">            switch(commend)&#123;</span><br><span class="line">                case kRegisterHost:&#123;__some__commend&#125;;</span><br><span class="line">                case kUnregisterHost:&#123;__some__commend&#125;;</span><br><span class="line">                case ...;</span><br><span class="line">                case ...;</span><br><span class="line">                ...</span><br><span class="line">        &#125;</span><br><span class="line">        //初始化host</span><br><span class="line">        host.reset()</span><br><span class="line">        SingletonEnv().thread_bundle.RunUntilIdle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这个逻辑看上去很简单的样子，也没有什么特别的算法，无非就是:</p><ul><li>定义了一些模拟通讯过程的函数</li><li>注册 fuzzer</li><li>通过proto产生的随机Session的session.commands()作为commend来针对commend进行fuzz</li><li>每次执行完commend进行host状态的初始化</li></ul><p>这个 fuzz 的结构貌似就是这样，但是我还没有搞明白:</p><ul><li>proto产生的数据是什么样的</li><li>commend的作用</li><li>以及最重要的：前面的函数定义</li><li>最最重要的，为什么选择 commend 这一层面去fuzz</li></ul><h3 id="所以第一条，先弄明白-google-proto-是怎么工作的"><a href="#所以第一条，先弄明白-google-proto-是怎么工作的" class="headerlink" title="所以第一条，先弄明白 google-proto 是怎么工作的"></a>所以第一条，先弄明白 google-proto 是怎么工作的</h3><p>【+】<a href="src/content/browser/appcache/appcache_fuzzer.proto">文件在这</a></p><p>【+】看一段 <a href="https://colobu.com/2015/01/07/Protobuf-language-guide/" target="_blank" rel="noopener">proto 中文引导</a></p><p>在研究proto之前，很有趣的一点是： <a href="https://cs.chromium.org/chromium/src/out/Debug/gen/content/browser/appcache/appcache_fuzzer.pb.h?g=0" target="_blank" rel="noopener">appcache_fuzzer.pb.h</a> 和 <a href="https://cs.chromium.org/chromium/src/out/Debug/gen/content/browser/appcache/appcache_fuzzer.pb.cc?g=0" target="_blank" rel="noopener">appcache_fuzzer.pb.cc</a> 中都存在:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Generated by the protocol buffer compiler.  DO NOT EDIT!</span><br><span class="line">// source: appcache_fuzzer.proto</span><br></pre></td></tr></table></figure></p><p>啊哈！也就是说我们只要弄明白 <a href="https://cs.chromium.org/chromium/src/content/browser/appcache/appcache_fuzzer.proto?g=0" target="_blank" rel="noopener">appcache_fuzzer.proto</a> 是怎么回事就好了。</p><p>但我还是先来研究一下 proto 是什么（回到 开头）。</p><p>emmmm，所以这是一个比较【方便的消息格式】，可以编译为c++的类以及类的实现代码。</p><p>so，来看一下 <a href="https://cs.chromium.org/chromium/src/content/browser/appcache/appcache_fuzzer.proto?g=0" target="_blank" rel="noopener">appcache_fuzzer.proto</a> QaQ</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">message Session &#123;</span><br><span class="line">  repeated Command commands = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Based on content::AppCacheBackend interface</span><br><span class="line">// See content/common/appcache_interfaces.h</span><br><span class="line">message Command &#123;</span><br><span class="line">  oneof command &#123;</span><br><span class="line">    RegisterHost register_host = 1;</span><br><span class="line">    UnregisterHost unregister_host = 2;</span><br><span class="line">    SelectCache select_cache = 3;</span><br><span class="line">    SetSpawningHostId set_spawning_host_id = 4;</span><br><span class="line">    SelectCacheForSharedWorker select_cache_for_shared_worker = 5;</span><br><span class="line">    MarkAsForeignEntry mark_as_foreign_entry = 6;</span><br><span class="line">    GetStatus get_status = 7;</span><br><span class="line">    StartUpdate start_update = 8;</span><br><span class="line">    SwapCache swap_cache = 9;</span><br><span class="line">    GetResourceList get_resource_list = 10;</span><br><span class="line">    DoRequest do_request = 11;</span><br><span class="line">    RunUntilIdle run_until_idle = 12;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// We only need a few hosts to encapsulate all the logic</span><br><span class="line">enum HostId &#123;</span><br><span class="line">  HOST_N2 = -2;</span><br><span class="line">  HOST_N1 = -1;</span><br><span class="line">  HOST_0 = 0;</span><br><span class="line">  HOST_1 = 1;</span><br><span class="line">  HOST_2 = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Caches are created more quickly so we want more of them</span><br><span class="line">enum CacheId &#123;</span><br><span class="line">  CACHE_N1 = -1;</span><br><span class="line">  CACHE_0 = 0;</span><br><span class="line">  CACHE_1 = 1;</span><br><span class="line">  CACHE_2 = 2;</span><br><span class="line">  CACHE_3 = 3;</span><br><span class="line">  CACHE_4 = 4;</span><br><span class="line">  CACHE_5 = 5;</span><br><span class="line">  CACHE_6 = 6;</span><br><span class="line">  CACHE_7 = 7;</span><br><span class="line">  CACHE_8 = 8;</span><br><span class="line">  CACHE_9 = 9;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RegisterHost &#123;</span><br><span class="line">  required HostId host_id = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message UnregisterHost &#123;</span><br><span class="line">  required HostId host_id = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SelectCache &#123;</span><br><span class="line">  required HostId host_id = 1;</span><br><span class="line">  required HostId from_id = 2;</span><br><span class="line">  required Url document_url = 3;</span><br><span class="line">  required Url opt_manifest_url = 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum HttpCode &#123;</span><br><span class="line">  RESPONSE_100 = 100;</span><br><span class="line">  RESPONSE_200 = 200;</span><br><span class="line">  RESPONSE_206 = 206;</span><br><span class="line">  RESPONSE_301 = 301;</span><br><span class="line">  RESPONSE_302 = 302;</span><br><span class="line">  RESPONSE_303 = 303;</span><br><span class="line">  RESPONSE_304 = 304;</span><br><span class="line">  RESPONSE_307 = 307;</span><br><span class="line">  RESPONSE_308 = 308;</span><br><span class="line">  RESPONSE_401 = 401;</span><br><span class="line">  RESPONSE_403 = 403;</span><br><span class="line">  RESPONSE_404 = 404;</span><br><span class="line">  RESPONSE_500 = 500;</span><br><span class="line">  RESPONSE_501 = 501;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message DoRequest &#123;</span><br><span class="line">  required HttpCode http_code = 1;</span><br><span class="line">  required bool do_not_cache = 2;</span><br><span class="line">  required ManifestResponse manifest_response = 3;</span><br><span class="line">  required Url url = 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ManifestResponse &#123;</span><br><span class="line">  repeated Url urls = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Make sure to test logic when fetching more than the max concurrent allowed.</span><br><span class="line">enum UrlTestCaseIndex &#123;</span><br><span class="line">  EMPTY = 0;</span><br><span class="line">  PATH_1 = 1;</span><br><span class="line">  PATH_2 = 2;</span><br><span class="line">  PATH_3 = 3;</span><br><span class="line">  PATH_4 = 4;</span><br><span class="line">  PATH_5 = 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// In order to efficiently fuzz the appcache logic, we don&apos;t want</span><br><span class="line">// to worry about all the possible url parsing. For this reason,</span><br><span class="line">// we generate either an empty GURL or one of up to 5 paths,</span><br><span class="line">// http://localhost/[1-5]. We can update this if in the future</span><br><span class="line">// more coverage can be achieved.</span><br><span class="line">// We represent this with a UrlTestCaseIndex enum. The 0 value is</span><br><span class="line">// a special case representing an empty string or GURL().</span><br><span class="line">// If not empty, we just append the int value of the UrlTestCaseIndex</span><br><span class="line">// enum to &quot;http://localhost/&quot;. Using an enum in this way makes</span><br><span class="line">// mutations more efficient.</span><br><span class="line">message Url &#123;</span><br><span class="line">  required UrlTestCaseIndex url_test_case_idx = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RunUntilIdle &#123;&#125;</span><br><span class="line"></span><br><span class="line">message SetSpawningHostId &#123;</span><br><span class="line">  required HostId host_id = 1;</span><br><span class="line">  required HostId spawning_host_id = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SelectCacheForSharedWorker &#123;</span><br><span class="line">  required HostId host_id = 1;</span><br><span class="line">  required CacheId cache_document_was_loaded_from = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message MarkAsForeignEntry &#123;</span><br><span class="line">  required HostId host_id = 1;</span><br><span class="line">  required Url document_url = 2;</span><br><span class="line">  required CacheId cache_document_was_loaded_from = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message GetStatus &#123;</span><br><span class="line">  required HostId host_id = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message StartUpdate &#123;</span><br><span class="line">  required HostId host_id = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SwapCache &#123;</span><br><span class="line">  required HostId host_id = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message GetResourceList &#123;</span><br><span class="line">  required HostId host_id = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上包含message的嵌套关系以及部分字段的取值范围</li><li>所以大概明白了proto产生的数据类型就是类似与上述嵌套关系产生的 message，用来作为注册fuzz时的随即数据接口，该随机数据的语法为proto的message定义。</li></ul><h3 id="所以第二个问题就是，commend的含义？"><a href="#所以第二个问题就是，commend的含义？" class="headerlink" title="所以第二个问题就是，commend的含义？"></a>所以第二个问题就是，commend的含义？</h3><h1 id="28-12-2018"><a href="#28-12-2018" class="headerlink" title="28/12/2018"></a>28/12/2018</h1><h3 id="回到了昨天的问题，所以各个commend具体是什么含义？"><a href="#回到了昨天的问题，所以各个commend具体是什么含义？" class="headerlink" title="回到了昨天的问题，所以各个commend具体是什么含义？"></a>回到了昨天的问题，所以各个commend具体是什么含义？</h3><p>一共有这些 commend：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">message Command &#123;</span><br><span class="line">  oneof command &#123;</span><br><span class="line">    RegisterHost register_host = 1;</span><br><span class="line">    UnregisterHost unregister_host = 2;</span><br><span class="line">    SelectCache select_cache = 3;</span><br><span class="line">    SetSpawningHostId set_spawning_host_id = 4;</span><br><span class="line">    SelectCacheForSharedWorker select_cache_for_shared_worker = 5;</span><br><span class="line">    MarkAsForeignEntry mark_as_foreign_entry = 6;</span><br><span class="line">    GetStatus get_status = 7;</span><br><span class="line">    StartUpdate start_update = 8;</span><br><span class="line">    SwapCache swap_cache = 9;</span><br><span class="line">    GetResourceList get_resource_list = 10;</span><br><span class="line">    DoRequest do_request = 11;</span><br><span class="line">    RunUntilIdle run_until_idle = 12;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>oh，像这样的类型均为message类型，在<a href="https://cs.chromium.org/chromium/src/content/browser/appcache/appcache_fuzzer.proto?g=0" target="_blank" rel="noopener">appcache_fuzzer.proto</a>下面均有定义，但我们现在关注的是每个 commend 对应的 renders 到 browser 的具体 IPC 过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Based on content::AppCacheBackend interface</span><br><span class="line">// See content/common/appcache_interfaces.h</span><br></pre></td></tr></table></figure><p>SO，继续研究 <a href="https://cs.chromium.org/chromium/src/content/common/appcache_interfaces.h?q=appcache_interfaces.h&amp;g=0&amp;l=1" target="_blank" rel="noopener">appcache_interfaces.h</a> ，此处是 renders 联系 browser 的接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;base/files/file_path.h&quot;</span><br><span class="line">#include &quot;content/common/appcache.mojom.h&quot;</span><br><span class="line">#include &quot;content/public/common/appcache_info.h&quot;</span><br><span class="line">#include &quot;mojo/public/cpp/system/message_pipe.h&quot;</span><br></pre></td></tr></table></figure><p>好，先来弄明白 mojo</p><h4 id="mojo"><a href="#mojo" class="headerlink" title="mojo"></a>mojo</h4><p>【+】<a href="https://zhuanlan.zhihu.com/p/40774312" target="_blank" rel="noopener">mojo 简介</a></p><p>【+】<a href="https://chromium.googlesource.com/chromium/src/+/master/mojo/public/tools/bindings/README.md" target="_blank" rel="noopener">Mojom IDL and Bindings Generator</a></p><p>【+】<a href="https://chromium.googlesource.com/chromium/src/+/master/mojo/public/cpp/bindings/README.md" target="_blank" rel="noopener">Mojo C++ Bindings API</a> </p><p>得到的信息:</p><ul><li>Generator 根据 mojom 文件生成了两个 Interface</li><li>InterfacePtr：是发送消息的端点，一旦绑定到一个消息管道的端点，就可以马上序列化要发送的消息，并写入管道</li><li>InterfaceRequest：是接受消息的端点，本质上仅仅是一个持有消息管道端点的容器，本身不会做任何事情，需要传递到直到绑定了实现了mojom文件接口的类，才能读取消息</li><li><p>定义 pipe :</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;sample/logger.mojom.h&quot;</span><br><span class="line"></span><br><span class="line">mojo::MessagePipe pipe;</span><br><span class="line">sample::mojom::LoggerPtr logger(</span><br><span class="line">    sample::mojom::LoggerPtrInfo(std::move(pipe.handle0), 0));</span><br><span class="line">sample::mojom::LoggerRequest request(std::move(pipe.handle1));</span><br></pre></td></tr></table></figure></li><li><p>MOJO C++ Bindings library 给出了对应的接口:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sample::mojom::LoggerPtr logger;</span><br><span class="line">auto request = mojo::MakeRequest(&amp;logger);</span><br></pre></td></tr></table></figure></li><li><p>此时管道已经完备，但是 LoggerRequest 端并未对消息进行处理。</p></li><li>request 作为参数初始化 LoggerImpl</li><li>Binding 接受 request 和消息类进行对Mojo-pipe的监控</li><li>监听和反序列化均由 Binding 完成</li><li>Binding 调用 Logger 类的 Log 输出/处理消息</li><li>最终可以在 Impl 类的一端看到 Logger 发送的消息</li></ul><h1 id="31-12-2018"><a href="#31-12-2018" class="headerlink" title="31/12/2018"></a>31/12/2018</h1><h3 id="抱歉"><a href="#抱歉" class="headerlink" title="抱歉"></a>抱歉</h3><p>这两天亲戚来北京，然后陪玩了一段时间，学习耽搁了不少。</p><p>今天要做的是看 <a href="https://mp.weixin.qq.com/s/qFh47YY-JJIMUrJXUKfNAQ" target="_blank" rel="noopener">35c3</a> 的有关 fuzz 的talk，顺便做一些笔记，确定一下之后要写什么样的 fuzz。</p><h3 id="TALK-1"><a href="#TALK-1" class="headerlink" title="TALK-1"></a><a href="https://www.youtube.com/watch?v=WbuGMs2OcbE" target="_blank" rel="noopener">TALK-1</a></h3><p>【+】<a href="https://github.com/MozillaSecurity/dharma" target="_blank" rel="noopener">dharma</a></p><p>【+】<a href="https://github.com/mozilla/rr" target="_blank" rel="noopener">rr</a></p><p>【+】<a href="https://github.com/tunz/js-vuln-db/tree/master/v8" target="_blank" rel="noopener">TODO</a></p><h3 id="TALK-2-BY-ned"><a href="#TALK-2-BY-ned" class="headerlink" title="TALK-2 BY ned"></a><a href="https://media.ccc.de/v/35c3-9579-attacking_chrome_ipc#t=2605" target="_blank" rel="noopener">TALK-2 BY ned</a></h3><p>【+】没看完，等看完了写个总结</p><p>继续看 mojo，卡在了 line_.back() 那里，可能我思路闭塞了</p><p>然而明天要看加密与解密了。。</p><p>等到周末继续看这一块吧</p><h1 id="31-1-2018"><a href="#31-1-2018" class="headerlink" title="31/1/2018"></a>31/1/2018</h1><p>时隔一个月重新开始笔记</p><p>从今天开始重新开始一点一点完整写 libfuzzer，计划假期结束能熟练编写libfuzzer，另外最好可以编写一个简单的 llvm pass :)</p><p>[+] 写了基本的 libfuzzer，复习了一些编译以及运行选项</p><p>[+] 顺道学习了下 shell 脚本的开发</p><p>[+] tip：可以在单步fuzz中遍历某些可选项的值，即使用的是同一个 Data 字符串</p><h1 id="1-2-2019"><a href="#1-2-2019" class="headerlink" title="1/2/2019"></a>1/2/2019</h1><p>[+] 起床看了会神经网络，知道最基本流程该怎么写了</p><p>[+] 修改了一下心脏滴血fuzzer，发现了好多问题，比如 fsanitize=fuzzer 和 fsannitize-coverage=balabala 的区别，比如一些函数在fuzzer内部定义和在外部定义为什么测试会有差别，以及经过修改的fuzzer再更改了一些选项后跑出来 mem-leak &amp; oom…有待解决</p><p>[+] 详细研究了ASan的算法，在 llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp 里面研究了 Global Variable &amp; Stack Variable &amp; Heap Variable 的插桩过程以及相应的算法</p><h1 id="2-2-2019"><a href="#2-2-2019" class="headerlink" title="2/2/2019"></a>2/2/2019</h1><p>[+] 在看 ASAN 源码过程中意识到学会编写 llvm pass 一定会对以后独自编写 fuzzer 框架有用的，因此今天除了接着研究ASAN源码之余要学习一下llvm pass的编写，目标是熟练掌握 ModulePass 以及 FunctionPass</p><p>[+] 配了 llvm 环境 &amp; 熟悉了一下基本的操作</p><p>[+] 还在看怎么写 pass…（并没有看完，明天接着看）</p><h1 id="3-2-2019"><a href="#3-2-2019" class="headerlink" title="3/2/2019"></a>3/2/2019</h1><p>[+] 弄清楚了注册并使用 pass 的流程</p><p>[+] 抄了下入门 pass &amp;&amp; 简单的看了下 llvm IR（挖坑，过了年来填）</p><p>[+] 下午在看番（逃</p><h1 id="13-2-2019"><a href="#13-2-2019" class="headerlink" title="13/2/2019"></a>13/2/2019</h1><p>[+] 整理一下这段时间看的 llvm 相关笔记</p><p>[+] 看了遍 llvm 的 IR</p><p>[+] 找了些 pass 来看，发现有很多的 api 不知道怎么用orz</p><h1 id="14-2-2019"><a href="#14-2-2019" class="headerlink" title="14/2/2019"></a>14/2/2019</h1><p>[+] 特殊的节日，就抽空看了下 34c3 的一篇演讲 <a href="https://www.youtube.com/watch?v=Zt74lOuU6zc&amp;pbjreload=10" target="_blank" rel="noopener">Implementing an LLVM based Dynamic Binary Instrumentation framework</a></p><h1 id="15-2-2019"><a href="#15-2-2019" class="headerlink" title="15/2/2019"></a>15/2/2019</h1><p>[+] 重新看了一遍 Asan 源码，对比一下前段时间看的 llvm 的一些点，加深印象</p><p>[+] 继续学 libfuzzer 写法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;27-12-2018&quot;&gt;&lt;a href=&quot;#27-12-2018&quot; class=&quot;headerlink&quot; title=&quot;27/12/2018&quot;&gt;&lt;/a&gt;27/12/2018&lt;/h1&gt;&lt;p&gt;昨晚重新做了个 ubuntu 虚拟机用来跑 libfuzzer，经过了几天的
      
    
    </summary>
    
    
      <category term="Diary" scheme="http://p1umer.club/tags/Diary/"/>
    
  </entry>
  
  <entry>
    <title>IR&#39;s Journey</title>
    <link href="http://p1umer.club/2018/09/03/IR&#39;s-Journey/"/>
    <id>http://p1umer.club/2018/09/03/IR&#39;s-Journey/</id>
    <published>2018-09-03T15:43:55.000Z</published>
    <updated>2018-10-23T10:53:58.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="From-Quads-to-Graphs-An-Intermediate-Representation’s-Journey"><a href="#From-Quads-to-Graphs-An-Intermediate-Representation’s-Journey" class="headerlink" title="From Quads to Graphs: An Intermediate Representation’s Journey"></a>From Quads to Graphs: An Intermediate Representation’s Journey</h2><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180904/gggeJJi5HJ.png" alt="mark"></p><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h3><p>中间语言不是凭空产生的。中间语言是程序员的表述到具体的机器代码的转换辅助，而且必须弥合大量的语义差异，例如从一个 fortran 90 的机器码操作到一个三地址码表述的 add 语句。在高级语言到机器语言的转化过程中，一个优化编译器会执行很多次的 pass 来优化 IR 。使用者希望优化编译器能把这一过程执行的迅速而又准确；而编译器的编写者则希望优化代码能够尽可能的简单易懂且便于维护。我们的目标是设计轻量级的 IR 来使得简单语句可以得到快速优化。</p><p>本文讲述了中间语言从 quad-based form 到 graph-based form 的转化历程。转化的最终格式类似于(当然不是完全相同)一个 operator-level 的 Program Dependence Graph 或者说是 Gated Single Assignment。最终的形式包含执行程序所需要的所有信息。更重要的是，这种图表形式明确地包含 use-def 信息，分析过程中可以直接使用此信息而无需计算。分析过程中 Transformation 会直接在 IR 的基础上修改 use-def 信息，而无需额外的步骤。这种形式的的 graph 是一维的结构，而不是像 CFG 包含两个维度（分别是 basic blocks 和 instructions）。<br>这种一维结构可以在我们的算法中体现出来。</p><p>使编译器快速运行的一个原则是尽可能早地完成尽可能多的工作。这引导我们在 one-pass 的前端加入强大的窥孔优化。我们设计的 IR 允许施行窥孔优化，在某种情况下，这种做法可以和 pessimistic conditional constant propagation 起到相同的效果。</p><p>【窥孔优化】：</p><ul><li>一种很局部的优化方式，编译器仅仅在一个基本块或者多个基本块中，针对已经生成的代码，结合CPU自己指令的特点，通过一些认为可能带来性能提升的转换规则，或者通过整体的分析，通过指令转换，提升代码性能。</li></ul><p>【稀疏有条件的常数传播】：</p><ul><li>稀疏有条件的常数传播（sparse conditional constant propagation）是一个优化的技术，常用在以静态单赋值形式（SSA）进行最佳化的编译器，它可以移除 dead code elimination 以及进行 constant propagation。</li></ul><p>【常数传播】：</p><ul><li>编译原理课上的常数替换优化</li></ul><p>本文不是关于如何写成一个完整的编译器，而是分享一种设计思路，可以从传统的 IR 过渡到 graph-based IR。</p><h4 id="1-1-Pessimistic-vs-Optimistic"><a href="#1-1-Pessimistic-vs-Optimistic" class="headerlink" title="1.1 Pessimistic-vs-Optimistic"></a>1.1 Pessimistic-vs-Optimistic</h4><p>我们将分析（和转换）分为两大类：Pessimistic &amp; Optimistic。Pessimistic analyses 假设了一种最坏的状况（conservatively correct）并且尝试去证明，而 Optimistic analyses 假设了一种最好地状况。处理“循环”外的情形中，这两种技术产生的结果相同。而在处理“循环”的过程中，Optimistic analyses 会假设一些从循环的 back edge 中产生的“fact”成立，在之后的步骤中可能会得到证明；而 Pessimistic techniques 则在循环进行中不产生任何假设，只使用已经确定的条件。这可能不能产生 do not already have 的事实。</p><p>举个栗子，在常数传播*(上面介绍过)的过程中，optimistic analysis 先假设循环 back edge 上的一些 def_value 等价于 constant，如果假设被证明成立，则可以进行一次 constant propagation。如果假设不成立，也没有害处啊2333…循环体只需要结合更加保守的 information 进行重新分析就可以了。</p><p>而针对 Pessimistic analysis，循环 back-edge 的 def_values 都被看作为变量，当这些所谓的“变量”与 loop 中的常量合并时，根据已有的信息分析器只能确定该个变量是个变量，符合了一开始的假设，因此这种分析无法找到更多的常量。</p><p>但是，如果没有循环，两种分析都可以访问包含所有已有 fact 的代码，也就是说，两种分析都可以找到一组等价的 facts。为了有效地做到这一点，分析需要按拓扑顺序访问代码；且关于特定值的信息必须在使用该值之前收集。如果无序访问代码，则一些分析必须在没有所有相关 fact 的情况下进行。在这种情况下，我们发现 Pessimistic analysis 可以在 one-pass 算法中可以 usefully proceed，因为缺少信息的条件下编译器做出的假设（或者说是具体的优化）会较为保守，而针对 Optimistic analysis 我们必须反复 visit 该块无序代码来验证那些较为积极但“危险”的假设。</p><h4 id="1-2-Optimizations-in-the-Front-End"><a href="#1-2-Optimizations-in-the-Front-End" class="headerlink" title="1.2 Optimizations-in-the-Front-End"></a>1.2 Optimizations-in-the-Front-End</h4><p>由于我们可以在 one-pass 算法中进行 Pessimistic analysis ，因此我们可以在 Parseing 时执行此操作。当前端解析表达式时，分析器会为表达式指定一个保守值，并尝试根据以前解析的表达式来产生更好的 Parse 结果。只要解析器以拓扑顺序 Parse 代码，Pessimistic analysis 就像 optimistic analysis 一样好。我们观察到 Parser 按照拓扑顺序访问使用 if / then / else 结构构建的代码，在循环头或非结构化代码中，Pessimistic analysis 做出了保守正确的假设，这是非常令人开心的。</p><p>Pessimistic analysis 只需要我们在 Parse 代码时收集的 use-def 信息。编译器查看（并更改）包含某段 IR 的固定 region，在该块 region 外的区域代码在前者的产生和优化（transform）过程中不受影响。region 内的 IR 的转换同样也不依靠其他 IR_region 的信息。类似于窥孔优化的加强版。</p><p>通过在 Parse 中加入 Pessimistic analysis ，我们降低了整个程序的大小，而且减轻了后续优化阶段的工作量。（程序大小的缩减是因为我们通过 Pessimistic analysis 用一些新指令替换了原有的指令，后续优化阶段工作量的减少是由于我们提前完成了）</p><p>【use-def】：</p><ul><li>links at a value’s use site to the value’s definition sites</li></ul><h4 id="1-3-Overview"><a href="#1-3-Overview" class="headerlink" title="1.3 Overview"></a>1.3 Overview</h4><ul><li>Section 2：从带有基本指令块的传统CFG开始；</li><li>Section 3：将这种表示适配到有明确的 use-def 信息的 SSA 格式</li><li>Section 4：再在其中加入控制依赖（control dependencies）</li><li>Section 5：使用C++的继承为我们的指令提供更多结构并加速其创建和删除</li><li>Section 6：完全放弃CFG，取而代之的是处理 control 的指令</li><li>Section 7：增强的窥孔优化</li><li>Section 8：讨论如何处理各种 problematic 的指令特性（effect chain &amp; memory dependence 以后有时间总结）</li><li>Section 9：删除所有 control 信息</li><li>Section A：lookat 基于终态 IR 的强大的 optimistic transformations </li></ul><p>当我们在“进化”IR 时，我们也要“进化” pessimistic transformation technique，而且它最终会变成一种极其简单高效的优化技术，仅仅在分析循环和非结构化代码时较弱于 optimistic analysis。</p><h3 id="2-In-the-Beginning"><a href="#2-In-the-Beginning" class="headerlink" title="2 In-the-Beginning"></a>2 In-the-Beginning</h3><p>让我们来具体看看CFG。CFG 是一个有向图，其节点是 basic blocks，边表示 control flow。Figure 1 表示了基本块的实现，是一个双层壳结构。CFG 包含了两个特殊块分别是没有输入的 Start block 和没有输出的 Stop block。每个 Basic block 包含有序的 instr 列表。每条指令都是一个四元组：opcode、目标变量和两个源变量。当然有时候源变量数量可能是 0~3 不等（这种情况就不叫四元组了）。四元组的实现在 Figure 2 中，是一个单维结构：</p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180828/cAbBEbe455.png" alt="mark"></p><p>在四元组指令的具体表示中，opcode 通常占用 1~4 个字节。每个变量都被重命名为一个相当密集的 machine integer，作为符号表的索引。源变量和操作码一起称为表达式。该四元组可能还包含指向当前 Basic Blocks 的下一个四元组的指针。</p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180828/aBkdmi6H5h.png" alt="mark"></p><p>粗略地说，基本块的语义如下所示</p><ul><li>每条指令都是按顺序执行的</li><li>指令的执行包括：<ul><li>解析所有源变量</li><li>在这些源上执行 opcode 指定的原语</li><li>将结果赋给目标变量</li></ul></li><li>Basic block 的最后一条指令，不是写入目标变量，而是读取条件代码寄存器，并决定下面几个基块中的哪一个要执行（Jump condition）。</li><li>Stop 块的最后一条指令必须包含 Return_opcode。</li><li>start 块的第一条指令可以使用程序外部指定的 source（程序的输入）。</li></ul><p>其余 IR 拓展功能按需添加。特别是子程序调用、内存（Load，Store）和 I/O 等等将进一步处理。</p><h4 id="2-1-Pessimistic-Transformations-on-Quads"><a href="#2-1-Pessimistic-Transformations-on-Quads" class="headerlink" title="2.1 Pessimistic Transformations on Quads"></a>2.1 Pessimistic Transformations on Quads</h4><p>到目前为止，四元组仍然缺少所有的 use-def 信息，即：A 指令中用到的变量由哪条指令进行赋值？在应用 use-def 信息之前，窥孔优化仅仅依赖于一个固定大小的指令窗口来检查和转换。该技术非常薄弱，因为其依赖【指令顺序】来”确保”变量的使用接近于变量定义，这是不严谨的。所有现代的编译技术都依赖于 use-def 信息，无论是局部（在基本块中）还是全局（在过程中）。</p><p>我们可以考虑将 Parse（甚至四元组的 generate ）和 pessimistic optimizations 进行融合。During Parse，前端生成 basic blocks 和 instr。在生成 instr_A 时，前端立即在此 Block 中的前一个指令的上下文中检查指令，并立即进行窥孔优化，在 context window 中执行 instructions transform。Figure 3 展示了一种 during-parse 的窥孔优化。加入 use-def 信息等效于 context window 的拓展，允许非相邻代码的该类优化。</p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180828/g4Ga4ja0jj.png" alt="mark"></p><h4 id="2-2-Use-Def-Information"><a href="#2-2-Use-Def-Information" class="headerlink" title="2.2 Use-Def Information"></a>2.2 Use-Def Information</h4><p>显然，use-def 信息将极大地改善我们的窥视孔优化。不仅如此，Use-def 信息对许多其他类型的优化也很有用。use-def 信息没必要和 source 变量名一起储存，仅依靠源变量名信息就足以生成 use-def chains。我们只需要在四元组中向后搜索就能找到 def 指令。但是，向后搜索可能很慢（程序大小呈线性）。更糟糕的是，向后搜索可能得到模糊的结果，因为程序中可能存在多种 def 可以 reach 相同的 use。为了解决这个问题，我们引入 SSA。</p><h3 id="3-Static-Single-Assignment"><a href="#3-Static-Single-Assignment" class="headerlink" title="3 Static Single Assignment"></a>3 Static Single Assignment</h3><p>适配 SSA 可以消除模糊的目标定义。在一个普通的程序中，一个变量可以沿着不同的控制路径（control path），或者说在不同的 basic block 中被多次定义。而在被转换为 SSA 形式时，某些 basic blocks 的头部会插入 Φ-function （在 4.1 中会具体描述），然后对所有的变量进行重命名。 Φ-function 被当作普通的的 instr 执行；且 Φ-function 的 opcode 与其他函数不同。Figure 4 展示了符合 SSA 的示例代码：</p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180828/Aah29LHBDG.png" alt="mark"></p><p>在重命名步骤之后，每个变量都精确地分配一次。且由于表达式只出现在赋值的右边，所以每个表达式都与一个变量（左值）相关联。也就是说，变量和表达式之间存在一对一的关联。因此，变量名可以当作“定义它的表达式”的直接映射（direct map）。 在我们的实现中，我们希望这种映射（mapping）越快越好。</p><p>在指令的具体实现中，我们会设计一个 field 用来存储源变量的名称（已经表示为 machine integers）。为了加快变量到定义的映射，我们用“指向变量定义指令的指针”（一个指向 instr 数据结构的指针）替换变量名。现在，执行从变量名到定义指令的映射需要单个指针，在这种方式下，use-def 链是显式编码的。Figure 5 展示了这种新的指令格式：</p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180828/h9cEELbIki.png" alt="mark"></p><p>我们现在有一个从变量和表达式到指令的来回抽象映射。这意味着我们不需要额外的指令来对已经定义的变量名进行编码——转而使用上述的映射关系即可。因此可以删除 dst 字段（优化的时候不再需要具体的左值信息，仅依赖于 use-def ）。但是，During Parsing，前端也需要从变量名称到指令的映射（前端的变量名称表现为 machine integet）。于是需要 vn 到 instr 的映射表（parse 过程）。考虑到已经存在 vn -&gt; integer 的映射，我们需要构建一个 integer -&gt; instr 的映射。每次窥孔优化后我们都会更新该 map。</p><p>Figure 6 展示了新的 Parser 接口。由于现在我们使用的是 use-def 信息而不是 context window，因此我们不再需要 prev 指针。</p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180828/32DeFkF7fc.png" alt="mark"></p><p>【note】这里的 dst &amp; src 都是 integer ，并且对 instr 隔离。</p><h4 id="3-1-Building-SSA-Form"><a href="#3-1-Building-SSA-Form" class="headerlink" title="3.1 Building SSA Form"></a>3.1 Building SSA Form</h4><p>我们现在使用相对保守的方法来构建 SSA。我们的方法不需要分析整个程序，当然，在我们仍在 Parse 程序时这也是不可行的。变量的每个定义都被重命名为定义指令的地址（vn-&gt;instr | line 5），而且每个原始变量都映射到一个 integer 索引（vn:integer | line 3&amp;4），我们在索引的基础上使用一个简单数组来映射 def（ ==arr_of_mapping==[integer]=def | line 3&amp;4）。当我们找到现有变量的新定义时，我们更新 ==arr_of_mapping==.</p><p>在每个 Basic Block 的开头，如果我们将要处理同一个变量的两个定义时，我们就会插入 Φ-function。在嵌套的 if / then / else 结构中，我们将解析所有通向 merge point 的路径。然后检查所有变量以更改定义并且按照需求插入 Φ-function。在 loop head 和 labels 位置，我们必须先假设所有变量都定义在我们尚未解析的路径上，这造成我们需要插入很多冗杂的 Φ-function 。但该算法依然很快。</p><h4 id="3-2-Pessimistic-Optimizations-with-Use-Def-Information"><a href="#3-2-Pessimistic-Optimizations-with-Use-Def-Information" class="headerlink" title="3.2 Pessimistic Optimizations with Use-Def Information"></a>3.2 Pessimistic Optimizations with Use-Def Information</h4><p>现在 use-def 信息已经嵌入到 IR 中。有了这些信息，我们就可以分析相关指令，而不管它们的顺序如何（也就是可以放弃context window ？maybe），而且这种分析会比以往更加有效。Figure 7 展示了我们使用 use-def 信息的一个窥孔优化实例：</p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180829/mlBea4jjh5.png" alt="mark"></p><p>【参考 Figure 5 加速理解】</p><p>（during codegen当一条指令的状态是 unused （not codegen），我们总是返回一些 replace指令。replacement_instr 可以是之前定义的指令（可以理解为use original def ）。使用以前定义的指令而不是创建一个新的指令会缩小我们的代码大小（好像同时也会减轻优化的工作量）。我们下面列举了一下优化：</p><ul><li>Removing copies: 直接使用原始值而不是 copy。</li><li>Adding two constants：通常来说，只要原语的 source 均为constant，那么在编译时就可以把结果直接优化为 constant，也就是依靠计算机的机器指令来优化。</li><li>Adding a zero: not add，use original</li><li>Value-numbering: value 编码会帮我们删除一些等效表达式，like line 5_if。所使用的方法是哈希表查找，其中 key 是从 data-input（or src）和 opcode 中计算出来的。因为我们 instr 结构中没有任何 control-data，我们可能会得到两个等价的但是毫不相关的表达式（不同的 control-path）。这种情况下，简单的 replace 就颇为不妥。为了修复这个问题，我们需要在每个 Basic Block 的末尾都刷新一遍 hash table。</li><li>Subtracting equal inputs:</li></ul><h4 id="3-3-Progress"><a href="#3-3-Progress" class="headerlink" title="3.3 Progress"></a>3.3 Progress</h4><p>我们取得了很大的进展，不仅从instr_format中删除了 dst 字段，而且收集了 use-def 信息以供以后的 passes，并加强、加速了窥孔优化。然而，我们可以 do better。对于基本块中的指令，我们仍然有一个固定的顺序，操作逻辑还是依赖于 ==next== field。然而，当一个 Basic Blocks 被执行时，块中的所有指令都被执行。而对于超标量或 data-flow 机器，只要它们的 input dependencies 得到满足，就应该允许以任何顺序执行指令。 要纠正这一点，我们需要考虑指令是如何排序的。</p><h3 id="4-Control-Flow-Dependence"><a href="#4-Control-Flow-Dependence" class="headerlink" title="4 Control-Flow-Dependence"></a>4 Control-Flow-Dependence</h3><p>在到目前为止描述的 IR 中，基本块包含有序的指令列表。在某种意义上，这代表了 def-use 控制信息。basic block 从某种程度上 define 了control-flow，然后 instr uses that control。我们需要做的是抛开 basic block 这种隐式 control flow，转而为每一个 instr 建立相应的 control data。消除串行化控制依赖关系允许在 Block 中的 instr 可以不按顺序执行，只要它们的其他数据依赖关系得到满足即可。此外，我们希望这种数据关系与我们的依赖表示保持一致，并显式地使用 use-def 信息而不是 def-use 信息。</p><p>基本块中指令的有序列表被表示为 linked list 形式。每条指令都包含指向下一条指令的指针。我们用一个指向 Basci Blocks 结构本身的指针替换这个 next pointer，并将此指针视为指令的另一个 source of input：the control source。此时，每条指令都有 0~3 个数据输入和一个 control input。Figure 8 描述了这种新的结构。在该示例中，我们仅展示了一个基本块，但其中的 data inputs 可以位于任何基本块。</p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180829/a4CaLi2f1c.png" alt="mark"></p><p>【左侧指针代表 control】</p><h4 id="4-1-More-on-Φ-Functions"><a href="#4-1-More-on-Φ-Functions" class="headerlink" title="4.1 More-on-Φ-Functions"></a>4.1 More-on-Φ-Functions</h4><p>首先明确什么是 Φ-Functions。举个栗子：<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180829/Dj9iF2ecia.png" alt="mark"><br>这是一个适配了 SSA 的 CFG。现在面临的问题是：</p><ul><li>W2 &amp; Z1 的 Y_source是那条路经上的？</li></ul><p>因此我们引入 Φ-Functions ：这个函数将分析控制流信息，通过选择y1或y2来生成y的新定义y3。</p><p>也就是这样：<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180829/ei0lGHljaI.png" alt="mark"></p><p>—介绍结束</p><p>我们依然需要 CFG 的 edges 来帮助判断“模糊节点”并在其中加入 Φ-Functions。我们需要将来自相应基本块的 control input 与 Φ-instr 的每个 data input 相关联。这样做意味着 Φ-instr 将具有一组 input pair（two element）：分别是 control dependence 和 data dependence。这种具有复杂语义的结构显得很笨拙。下面我们看一种全新的结构。</p><p>我们将 Φ-instr 拆分成<strong>一组</strong> Select 指令和<strong>一个</strong> Compose 指令，每个指令都有简单的语义。Select 有两个 input： control dependence 和 data dependence。Select 计算的结果取决于 control。如果 control source 没有被执行，也就是说对应的 Basic Block 没有被 exec，那么不产生任何 value 结果。否则，data value 将被 pass up（自造词组2333）。紧接着，Compose 将 Select 的所有结果作为 input，并且 pass up 产生 value 的 Select 的结果。如 Figure 9 所示：</p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180829/3ddHG2dF5f.png" alt="mark"></p><p>WARMMING!!!这些指令（Select &amp; so on）没有 Run-time 操作,而且它们不是机器指令。它们的存在仅是为了帮助编译器理解程序语义。当最终的机器代码被fully generated，Select / Compose序列将被 folded back 回 basic blocks &amp; CFG。</p><h4 id="4-2-Cleanup"><a href="#4-2-Cleanup" class="headerlink" title="4.2 Cleanup"></a>4.2 Cleanup</h4><p>此时我们的 instr 已经较为完美了，其 use-def 信息包含了 data 和 control（针对use-def-of-control，可以理解为常规控制流图反过来的逻辑链）。另外，我们还有足够的信息保证 IR 的可加工性（<del>因此很容易修改，例如，merge dead path</del>）。但是，我们现有的的 Inst 类很难很好的抽象出各种不同的指令。我们将在下一节中讨论这个问题。</p><h3 id="5-Engineering-Concerns"><a href="#5-Engineering-Concerns" class="headerlink" title="5 Engineering-Concerns"></a>5 Engineering-Concerns</h3><p>我们注意到我们可以有好多不同的指令，每一种指令都有不同数量的 input。像 Compose 指令，可能有任意数量的输入；Negate 指令只有一个 input；而 Constant 指令（定义 one simple int）需要保存正在定义的 constant 的值，且没有其他的 input。为了处理所有这些差异，我们将 instrument 的定义分解为单独的、继承自基类 Inst的 class。 Figure 展示了了新的基类和一些继承的类。</p><p>我们使用的是函数式编程风格。我们创建并初始化了所有对象，但从未修改过。为了获得编译器对这种编程风格的支持，我们在类定义中插入了适当的 const 限定符。</p><ul><li>【NOTE】 纯函数式编程中的变量不是命令式编程中的变量，而是存储状态的单元，是不可变的（immutable）。也就是说不允许像命令式编程语言中那样多次给一个变量赋值。</li></ul><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180830/J4Im5mLa8h.png" alt="mark"></p><h4 id="5-1-Virtual-Optimizations"><a href="#5-1-Virtual-Optimizations" class="headerlink" title="5.1 Virtual-Optimizations"></a>5.1 Virtual-Optimizations</h4><p>在 Figure 7 中的窥孔优化实例函数中，c++ 代码对每个对象类唯一的 opcode field 进行 switch。但在一个完整的实现中，switch 语句会变得相当巨大。另外，单个 opcode 的语义将被分为不同的 sections；一个 section 用于类定义，另一个用于窥孔优化。但我们更喜欢将 opcode 的所有语义放在一个地方:类成员函数。在 Figure 11 中，我们将 peephole function 分割成针对特定 opcode 的 virtual functions。</p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180830/J7aIcE9GbF.png" alt="mark"></p><p>要使哈希表起作用，我们必须能够 hash instr 和比较指令。不同的类封装指令具有不同的哈希函数和不同的比较语义。举个栗子：ADD 的source value 无论顺序如何其整体散列值应该一致。Figure 12 展示了 virtual hash 和 compare functions。</p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180830/GbbEg1ibcg.png" alt="mark"></p><h4 id="5-2-Faster-Malloc"><a href="#5-2-Faster-Malloc" class="headerlink" title="5.2 Faster-Malloc"></a>5.2 Faster-Malloc</h4><p>每次执行新指令时，我们都会调用操作符 new 来获得存储空间。但他反过来又会调用 malloc，可能相当耗时。此外，窥孔优化经常删除新创建的对象，需要调用 free。我们通过为 Instr 类 hook 特定于<strong>类</strong>的操作符 new 和 delete 来加速这些频繁的操作。首先我们需要为这种 replace operate 分配一个 arena。Arenas 中包含具有相似生存周期的堆分配对象（instrs）。生存周期结束后，我们会 delete 整个 arena，从而快速地 free 掉内含的所有 object。如图13所示：</p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180830/D4cj0f6dmj.png" alt="mark"></p><p>++// arena-&gt;next = pre_arena++</p><p>Allocation 会检查当前 Arena 的空间大小。如果 Arena 没有足够的空间，则会在其中添加另一块内存。如果对象 fits，则返回对象地址的当前 hwm ，具体看代码。整体的 GC 风格是用<strong>内存指针的移动代替实际的内存分配释放</strong>。其中 Arena 的扩充以及 chunk chain 的释放算是唯二耗时的内存操作。</p><h4 id="5-3-Control-Flow-Issues"><a href="#5-3-Control-Flow-Issues" class="headerlink" title="5.3 Control-Flow-Issues"></a>5.3 Control-Flow-Issues</h4><p>通过上述这些更改，我们的 IR 的整体设计终于变得清晰起来。每条指令都是一个独立的C++  object，其中包含确定 instr 如何与其周围的程序交互所需的所有信息。instr 的主要字段是 opcode。opcode_class 决定指令如何传播常量、处理代数恒等式并找到与其他指令一致的地方。为了使 IR 适配一种新的操作，我们需要定义一个新的 opcoded 和类——该类需要采集 data field 作为 intr’s input，而且需要提供窥孔优化以及 value-numbering 接口（hash），而不需要对窥孔或 value-numbering 本身进行任何更改。所以现在的 IR 具有相当强的可维护性。</p><h3 id="6-Two-Tiers-to-One"><a href="#6-Two-Tiers-to-One" class="headerlink" title="6 Two-Tiers-to-One"></a>6 Two-Tiers-to-One</h3><p>我们的 IR 有两个不同的 level：top_level，CFG 包含 Basic Blocks；bottom level，Basic Blocks包含 instr。过去，这种 seperate 对于 concerns 的分离很有用—— CFG 处理 conrtol flow，基本块处理 data flow。但是，我们希望用相同的机制处理这两种 dependence，因此我们需要消除这种壁垒。</p><p>先来看看 instr 怎么处理。抽象点来说，每个 instr 都可以当作一个 node 。 instr 的每个 input 都表示从定义指令的节点（def）到该指令的节点（use）的一条边（def -&gt; use 边）。<br>edge 的方向正好和 instr 中的 input_pointer（use-def chain）的方向相反。这并不矛盾：我们恰好正在定义这样一个 abstract graph。像 Figure 14 所描述的那样，这个 “graph”的具体实现是从 sink<br>到 source (use to def) 的 edge 遍历，而不是从 source 到 sink (def to use)。 </p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180831/EfLAca2k0C.png" alt="mark"></p><p>为了确定何时执行，每个 instr 都要从 Basic Blocks 获取一个 control input。如果 input 是抽象图中的一条边，那么基本块必须是抽象图中的一个节点。所以，我们定义一个 Region instr 来替换基本块。 Region 指令将来自每个predecessor block 的 control 作为输入，并产生 merged control 作为输出。</p><p>由于 Region instr 作用是合并 control inputs，因此不局限于 separate control input 来确定何时执行。因此 control input 字段就可以移动到具体的 class-specific instr_class。Figure 15 展示了这种变化：</p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180831/I6khdE66B8.png" alt="mark"></p><p>如果basic blocks 以条件指令结尾，我们就把条件指令换作 IF。Figure 16 展示了 IF_instr<br>是如何工作的。</p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180831/1mjGE1Kmb4.png" alt="mark"></p><p>左侧是这样的逻辑：predicate 提供 condition 判断语句，branch 将 control-flow 引导至不同的 block。然鹅通过显式的 control edge，IF instr 接受 control input 和 predicate 输入，然后产生 out-control 传递给不同的 Region。</p><p>【NOTE】这种转化后，其实该 graph 还是双层网状结构，只不过操作逻辑变成单一维度。</p><h4 id="6-1-A-Model-of-Execution"><a href="#6-1-A-Model-of-Execution" class="headerlink" title="6.1 A-Model-of-Execution"></a>6.1 A-Model-of-Execution</h4><p>在放弃基本块和 CFG 之后，我们的执行模型是什么？我们从中间表示的设计历史中获取线索。其实和四元组一样，我们的 IR 模型还是有两个分开的部分。就像 Figure 15 源码所述，我们只是在操作逻辑相同的单个 graph 中嵌入了两层 representation 维度。也就是说，我们的优化操作并不将这两层 subgraphs 区分开来，只是针对不同的 opcode 有不同的接口。</p><p><strong>control subgraph</strong> 使用 <a href="https://zh.wikipedia.org/zh-hans/Petri%E7%BD%91" target="_blank" rel="noopener">Petri net 模型</a>。 随着 exec 的进行，control token 在节点之间移动。这反映了 CFG 的工作方式：control flow 即 Basic block exec 顺序。control token 只存在于 Region / If / Start 指令中。Start 基本块被替换为产生初始 control token 的 Start 指令。随着指令的 exec，control token 也会随之前进。如果该 token 遇到了 STOP 指令，则执行停止。由于我们是使用 CFG 构造了当前 graph，所以我们确保在当前指令的所有传出边（control out）上只存在 Region / If / Stop 。</p><p><strong>data subgraph</strong> 不使用基于 token 的语义。 data node 的输出是其 input 和 function（opcode）的直接反映。因为没有记录状态的 token 存在，因此就不存在 Petri net。在每个 out edge 上，data value的数量都是无限的。直观地说，当一条指令需要 data instr 的值时，它会沿着 use-def 追溯到该 instrs，并读取存储在那里的值。在无环图中，这种根到叶的变化波动非常快。当数据值的传播趋于稳定时，control token 移动到下一个 Region 或 If 指令。Graph 中不可能只包含 data node ，每个循环都有 Compose / Region 指令</p><p>两个 subgraph 在两种不同的指令类型中混合：Compose/Select 指令和 If 指令。Compose / Select 组合读入 data 和 control ，并输出 data value。Select 不使用 control token，但会检查是否存在 control token。Select 的out 只有两种，一种是 data input 的拷贝，另一种就是 no-value。这当然取决于 control token 的存在与否。 Compose 输出它们的 previous value 或 present value。</p><p>IF 指令同时接受 data 和 control token ，并持有 True/False control token。两个可能的后继 region 只有一个能起到作用。在 Section 8.1，我们修改了 If 指令，使其行为更像其他 control handling 指令：给与两个后继，只有一个接收 control token。【图 9 和图 16 可以结合】</p><p>Figure 17 展示了一个简单的循环。Region 指令代替 Basic Blocks 作为 head 来处理该 loop 的 control-flow。Region &amp; If 构成 loop 的简易 control 框架；Select &amp; Compose 用来处理 SSA 形式下的变量混淆，接受的 control 参数分别为开始时的 Start 和 经历了 loop 的 If-false-control-out，对应的 data input 分别为 i0 和 i2。注意判断语句是作为 If_input 的 predicate ，outer 为 data。 </p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180901/J02BHK3f1D.png" alt="mark"></p><h4 id="6-2-Control-Based-Optimizations"><a href="#6-2-Control-Based-Optimizations" class="headerlink" title="6.2 Control-Based-Optimizations"></a>6.2 Control-Based-Optimizations</h4><p>把 control 信息作为显式输入意味着我们可以在优化中使用它。一个具有 Constant test 的 IF 语句只能产出两个 control outs 中的一个，其中“live”边的 control out 就是 If 的 control in 的拷贝，而 If 则会在 dead 边的 head 部分输出 NULL（dead-out）。在我们讨论如何处理 If 的两个不同输出之后，图 24 提供了执行此操作的代码。（现在不急）</p><p>在做针对 ADD 的窥孔优化时，我们可以检查我们正在 Parse 的代码是否已经处于 dead 状态并立即将其删除。例如，当 DEBUG code 被编译出来，程序员将常量值传递给各种 flag 位时，可能存在某些选项 flag 为 0 的状况。然后相应地，If 产生 dead out，之后的 code 通过判断 dead out 将相应的 instr 删除（包括但不局限于 ADD）。 如 Figure 18。</p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180901/D7mfJ8JkJF.png" alt="mark"></p><p>注意，我们返回 NULL 作为 unreachable instr 的定义指令。这意味着任何优化 unreachable instr 的尝试都将使用 NULL，fail 无疑。这种直觉是正确的：无法访问的代码永远不会执行，所以我们永远不应该尝试使用这样的代码。为了简洁起见，我们将在以后的示例中跳过对于 control inputs 是否为 Null 的检测。使用这些 NULL data values 的 Select 指令的 control inputs 同样为 Null（Null data 存在于 dead-path），因此也是 unreachable 的（从 control-flow 角度）。Compose instr 检测来自 Select 的 input：如果为 Dead，则直接移除。</p><p>Region 和 Compose 指令可以以类似的方式进行优化。Null input（dead-path）可以直接移除。如果 Region 和 Compose 的 input 是单一的，那么可以直接移除该 instrs（control token 均为拷贝）。在 Parse 过程中进行这些优化需要前端确认之后没有其他的 control path 可以到达 merge points。针对 if / then / else 这种结构化代码对应的 merge points，与其有关的所有 control-path 都是已知的。在解析完到达 merge points 的所有路径之后，可以优化 Region 和 Compose 指令。<del>而针对 label 对应的 merge point，前端只有在全部解析完 label 所在的 scope 才会进行优化。</del></p><h4 id="6-3-Value-Numbering-and-Control"><a href="#6-3-Value-Numbering-and-Control" class="headerlink" title="6.3 Value-Numbering-and-Control"></a>6.3 Value-Numbering-and-Control</h4><p>如果我们把 control input 信息嵌入到 value numbering’s hash 和 key-compare functions 中，那么我们就可以避免位于不同基本块的等价 instr 的混淆，因此也就不需要再每个基本块结尾进行 hash table 的 flush。然鹅，这依然还只是本地的 value numbering。放弃 control 并且做到全局的 value numbering 我们将在 Section 9 中介绍。</p><h4 id="6-4-A-Uniform-Representation"><a href="#6-4-A-Uniform-Representation" class="headerlink" title="6.4 A-Uniform-Representation"></a>6.4 A-Uniform-Representation</h4><p>现在，我们使用了相同的 Inst 类来表示整个程序。control 和 data flow 统一表示为图中节点之间的边。从现在开始，我们会对 graph 进行细化，但我们不会对其进行任何重大更改。</p><p>在完成四元组到 graph 的转换之后，我们得到了什么？在下一节中，我们将看到有关窥孔优化的通用代码。此代码适用于所有指令类型，添加新的指令类型（或操作码）也不需要对其做任何更改。其工作包含：value-numbering ，constant folding 和 eliminating unreachable code.</p><h3 id="7-Types-and-Pessimistic-Optimizations"><a href="#7-Types-and-Pessimistic-Optimizations" class="headerlink" title="7 Types-and-Pessimistic-Optimizations"></a>7 Types-and-Pessimistic-Optimizations</h3><p>我们以前的 vpeephole 结合了 constant folding 和 identity-function（对相同函数进行优化）。在 Section 10 中，conditional constant propagation 不能使用 identity-function 优化而且只需要 constant-finding 代码。所以我们 break up 原本 vpeephole 中的优化函数，将其分为两种：进行 constsnt folding 的 <strong>Compute</strong> 以及进行 identity-function 的 <strong>Identity</strong>。Compute 产生的 constant 被储存在 type 结构中。</p><p>type 就是一组值。我们感兴趣的是在 run-time 中的 value 以及类型。其结构如下：</p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180902/DHljKmK6DI.png" alt="mark"></p><p>上下两个符号与 control flow 相关联，分别代表  control 的 unreachable 和 reachable but not constant。</p><p>identity-function 优化和 Compute 的代码如图 20 所示：<br><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180902/d9l8h4hIIa.png" alt="mark"></p><p>如果 Identity 判断指令 x-instr 是某个其他指令 y-instr 的等效函数，则删除 x 并返回 y 来作为 x 的替代。删除 x-instr 并返回 y-instr 的操作仅在其他地方没有针对 x-instr 的引用的情况下有效（否则我们有空指针指向 x）。 因此，只有在我们最近在 Parse 期间创建了 x 时才能使用 Identity 代码。由于我们的目标是 during parsing 的优化，因此无伤大雅。</p><p>// 如果 instr 的 src 的 type.height 其中一个为 TOP，则<strong>无法</strong>继续常量折叠； 如果 instr 的 src 的 type.height 其中一个为 bottom，则<strong>无需</strong>继续常量折叠 </p><h4 id="7-1-Putting-it-Together-Pessimistic-Optimizations"><a href="#7-1-Putting-it-Together-Pessimistic-Optimizations" class="headerlink" title="7.1 Putting it Together: Pessimistic Optimizations"></a>7.1 Putting it Together: Pessimistic Optimizations</h4><p>我们的下一个窥视孔优化器的工作原理如下：</p><ul><li>为每个 instr 进行 Compute Type</li><li>如果指令的类型是常量，则用 Constant 指令替换掉。先删后填使 new 和 delete 可以重复使用内存。这也意味着我们需要在删除之前保存相关的常量。</li><li>对 instr 进行 Value-numbering，尝试寻找以前存在的可替换的指令。我们在 old instr 上无需使用 Identity-function 优化，因为在其进入哈希表之前肯定经历过该类优化。</li><li>identity-function 优化。</li><li>如果我们没有找到替换指令，我们必须计算一个 hash value，并将其插入 hash table。</li><li>返回 optimized instruction</li></ul><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180902/cF0CE1jgBa.png" alt="mark"></p><h4 id="7-2-Defining-Multiple-Values"><a href="#7-2-Defining-Multiple-Values" class="headerlink" title="7.2 Defining Multiple Values"></a>7.2 Defining Multiple Values</h4><p>我们已经实现了我们的设计目标之一：使窥孔优化的代码简单和直接。根据我们的经验，这个窥孔优化将程序峰值内存大小（和运行时间）减少了一半。</p><p>然鹅，在我们现在的 IR 中对 IF 的处理还不够完善。IF 产生两个 seperate result。 If 的 user 被分为两组，具体的访问取决于他们可以得到的 result。到现在为止，没有任何一个非 If instr 具有这样的指令行为。在下一节中，我们将介绍几种产生多个值的指令类型，并尝试找到一种统一的解决方案来选择该类 instr 的 result。</p><h3 id="8-More-Engineering-Concerns"><a href="#8-More-Engineering-Concerns" class="headerlink" title="8 More Engineering Concerns"></a>8 More Engineering Concerns</h3><p>在最初的基于四元组的实现中，有好几种定义多个 value 的 instr。 例如，设置条件代码寄存器以及计算结果（即减法）和子程序调用（至少设置结果寄存器，条件代码和内存）的指令。以前，这些指示是在特别的 basis 上处理的，而如今我们要使用更正式的方法。</p><p>单个指令，例如 If ，产生多个不同的值（ true/false control-out ）是一件很令人头疼的问题。当我们引用这样的一条指令时，指的是哪个输出呢？我们通过引入“单个元组值（tuple）”来统一代替这样的 multi-defining 指令产生的 outs 来解决这个问题。然后我们使用 Projection 指令去掉我们想去掉的 piece of the tuple。每个 Projection 指令从 defining instruction 中获取 tuple 并生成一个简单 value。</p><p>Projection instr 没有 run-time 操作，换句话说，其运行在 zero cycles。如果都用 machine code 表示的话，tuple-producing 指令就是一个产生多个 result 的 machine code。而 Projection 仅仅是为不同的 result 指定不同的名称。</p><p>tuple-producer 的工作之一就是为 Projection <strong>Compute</strong> a new <strong>Type</strong>。该 Projection 指令的 Compute 代码通过将 Projection 传递给 tuple-producer 的 Compute，让 tuple-producer 确定 Projection 的 Type 并且使用该结果。由于 non-tuple-producing 指令永远不会成为 Projection 的目标，因此默认值是一个 ERROR，如图 22 所示。Identity 的处理是类似的。</p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180903/9CJ807CL4L.png" alt="mark"></p><h4 id="8-1-If-Instructions"><a href="#8-1-If-Instructions" class="headerlink" title="8.1 If Instructions"></a>8.1 If Instructions</h4><p>If 指令接收 predicate 和 control input，并产生 true/false 两个 control out。分配给<br>True/False-Projection 并插入 Region 作为后继。示意图和代码如下：</p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180903/l90DlEiJ8a.png" alt="mark"></p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180903/5CmHg8jfhh.png" alt="mark"></p><h4 id="8-2-Projection-Instructions"><a href="#8-2-Projection-Instructions" class="headerlink" title="8.2 Projection Instructions"></a>8.2 Projection Instructions</h4><p>通过对 Projection 的定义，填补了我们模型中的一个主要空白。我们现在有关于 peepholer 如何查找和删除 unreachable code 的具体代码。到目前为止，每个 data 指令都包含一个 control input ，该 input 从本质上定义了指令属于哪个基本块。但在许多情况下，我们并不关心指令被放置在哪个块中，只要它在数据依赖关系得到满足和任何 uses 之前被执行即可。下一节中，我们就要删除 control input。</p><h3 id="9-Removing-Control-Information"><a href="#9-Removing-Control-Information" class="headerlink" title="9 Removing Control Information"></a>9 Removing Control Information</h3><p>在我们的模型中，我们要求每个数据计算都有一个 control input ，以确定数据计算什么时候应该执行。事实上我们可以从数据计算中删除 control input ，并且完全依赖于 data dependence 。当然，这样做优缺点并存。优点是：</p><ul><li>图中较少的 edge 意味着较小的图形、较少的构建和操作工作。</li><li>value numbering 的工作原理是找到congruent（一致性的）sub-graph 段，其中 congruent （一致性）被定义为“一致性输入上的相等函数”。而一旦失去了 control input ，hash 就难以保证来源的差异性。所以 pessimistic value numbering 就要和 global value numbing 一样强。</li><li>缺少控制输入时，只剩下数据输入。计算中不再有”所属的基本块”的概念。跨基本块执行代码移动的调度器不需要知道指令有多大的自由度；<del>这些信息是显式的。</del></li></ul><p>缺点是：</p><ul><li>好无聊啊不想写2333</li></ul><h3 id="10-Optimistic-Transformations"><a href="#10-Optimistic-Transformations" class="headerlink" title="10 Optimistic Transformations"></a>10 Optimistic Transformations</h3><p>Optimistic transformations，例如稀疏条件常数传播（Sparse Conditional Constant Propagation），会在优化过程中做出 optimistic assumptions 并尝试证明，有时可能需要分析整个程序以进行验证一个猜测。因此，我们需要在每条指令中保留有关当前 assumptions 的一些信息。该信息存储在 Type 字段中， Type 字段由前面定义的 Compute 设置。</p><p>我们依靠 <strong>pessimistic analysis</strong> 避免的这种 global analysis 的另一个条件就是需要就是 def-use edges。到目前为止，我们所有的优化都只能在给定一个 instr 和它的直接 uses 成分（即给定 use–&gt;def edges） 条件下执行。对于 <strong>optimistic transformations</strong> ，我们假设所有指令都是 undefined 以及所有的 code 都是 unreachable 。然后从 Start 开始，我们开始逐步验证并修改这些假设。当我们发现一条指令定义了除 “top” 以外的值时，我们就必须 inspect 所有使用该值的指令的 assumptions。因此我们需要 def-use edge。</p><p>因为我们需要全局(批处理)算法的 def-use edges，所以我们要一次性找到它们并将 single insruction 的 def-use edges 按照顺序放入一个大数组中。 要访问 该 instr 的 edges，我们需要指令中的 start 和 length 部分。因此我们为 instrument 引入了两个新的 field ：def_use_edge 和 def_use_cnt（count）。</p><p>我们通过遍历 graph 的 use-def edges 来找到 def-use edge。要进行图形遍历，我们需要一个 visit flag，一个 use-def edge 计数器，以及一个通过 index 访问 use-def edges 的函数。新构建的 instr 如下图所示：</p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180903/dAbFCBd86m.png" alt="mark"></p><p>我们在图 27 中构建了def-use edge。我们需要使用 Stop 指令和 use-def edge 的数量作为输入以及构建一个空数组来保存 def-use edges。首先通过对 Graph 的一次遍历 pass，count 每个 Inst 的 def-use edges。在此步骤中，我们还将所有 Type 初始化为 “Top”。在第二次 pass ，我们将 edge value 存储到数组中，将数组部分的开始部分存储到 Inst 里去。因为我们从 Stop 指令开始所有的遍历并且只沿着 use-def edges 行进，所以我们不会访问到 dead code。也就是说，我们也不会将其将其表示出来。这就等同是在 SCCP 之前进行了一次 dead code elimination。</p><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180903/JfmkJf33m4.png" alt="mark"></p><p>接下来,我们运行 SCCP。我们把 start 指令放在 worklist 上。然后我们进入一个简单的循环：我们从 worklist 中提取一条指令，为其 compute 一个新的 Type ，如果与默认值不同，则将该指令的所有 uses 放回 worklist 中。当该 list 清空时，工作就完成了。</p><h4 id="10-1-The-Payoff"><a href="#10-1-The-Payoff" class="headerlink" title="10.1 The Payoff"></a>10.1 The Payoff</h4><p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180903/gHbflbFjEK.png" alt="mark"></p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>为了得到更快的 optimiser，我们决定在 front-end 做一些工作。我们推断，在 Parse 过程中进行的窥孔优化将减少 IR 的大小和后期优化阶段的开销。</p><p>我们以SSA形式进行了前端构建。因为我们在 Parsing 时无法分析整个程序，所以必须插入很多的 Φ-Functions 。我们注意到 variable names 是程序表达式的一对一映射。，因此我们用 instr-pointer 来进行替换。此时表达式中的 name 字段就显得毫无用处，因此我们果断的进行 dst 的删除。我们还观察到了 basic blocks 内的隐式控制流，我们对此进行了显式控制（因此需要进行优化）。我们还发现，在尝试编写 unreachable code elimination 的窥孔优化时，我们的模型是 non-compositional（分离操作的属性，可进行显式的操作），我们通过在 Φ-Functions 中引入 control 并将其分解为 Select 和 Compose 两条指令来解决这一问题。</p><p>紧接着我们利用了c++ 的继承机制，并将 Insts 重新构造为单独的类以用于每一种 instr。我们还插入了专门的 new 和 delete 功能。</p><p>这时候我们注意到 Basic Block 结构只包含了一些 typical dependence，这和一个典型的 instr 没有什么两样，因此我们直接将其替换为 Region 。因此我们一直使用的窥孔优化现在允许我们除常规的 constant fold 和  value numbering 之外进行 unreachable code elimination。</p><p>我们将每条指令的 peephole 分解为 constant folding（compute）和 identity-function 优化。其中的 constant folding 在 global opt 中被使用。</p><p>最后我们优化了SCCP。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;From-Quads-to-Graphs-An-Intermediate-Representation’s-Journey&quot;&gt;&lt;a href=&quot;#From-Quads-to-Graphs-An-Intermediate-Representation’s-Journ
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>V8 Iginition Interpreter</title>
    <link href="http://p1umer.club/2018/07/10/V8-Iginition-Interpreter/"/>
    <id>http://p1umer.club/2018/07/10/V8-Iginition-Interpreter/</id>
    <published>2018-07-10T06:45:19.000Z</published>
    <updated>2019-01-30T11:35:20.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是字节码解释器？"><a href="#什么是字节码解释器？" class="headerlink" title="什么是字节码解释器？"></a>什么是字节码解释器？</h2><p>解释器是一种顺序执行源代码的引擎。<br>在过去的V8中，源代码被立即编译到汇编程序并执行，但与之不同，解释器将源代码转换为高级字节指令并按顺序执行字节指令。感觉就像一个 高级汇编程序。</p><h2 id="Ignition概要"><a href="#Ignition概要" class="headerlink" title="Ignition概要"></a>Ignition概要</h2><p>Ignition是一个基于寄存器的字节码解释器。与Java的堆栈基础不同，它实际上将值分配给CPU的寄存器并执行它们。在Ignition中，预先生成一个名为BytecodeHandler的字节码处理函数，从字节码中获取数组索引，<br>并将生成的处理函数分配给索引，一个接一个地循环Bytecode数组，并使用相应索引的函数执行调用代码。<br>简化版本的js代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var Bytecodes = [0,1,2,3,4,5];</span><br><span class="line">var index = 0;</span><br><span class="line">function dispatch(next) &#123;BytecodeHandlers[next]();&#125;</span><br><span class="line">const BytecodeHandlers = &#123;</span><br><span class="line">  [&apos;0&apos;]() &#123;...; dispatch(Bytecodes[index++])&#125;,</span><br><span class="line">  [&apos;1&apos;]() &#123;...; dispatch(Bytecodes[index++])&#125;,</span><br><span class="line">  [&apos;2&apos;]() &#123;...; dispatch(Bytecodes[index++])&#125;,</span><br><span class="line">  [&apos;3&apos;]() &#123;...; dispatch(Bytecodes[index++])&#125;,</span><br><span class="line">  [&apos;4&apos;]() &#123;...; dispatch(Bytecodes[index++])&#125;,</span><br><span class="line">  [&apos;5&apos;]() &#123;...; dispatch(Bytecodes[index++])&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Ignition结构"><a href="#Ignition结构" class="headerlink" title="Ignition结构"></a>Ignition结构</h2><h3 id="字节码生成的函数调用"><a href="#字节码生成的函数调用" class="headerlink" title="字节码生成的函数调用"></a>字节码生成的函数调用</h3><p>Ignition 从Javascript AST 生成 bytecodes</p><p>我们将检查这个bytecodes生成步骤。</p><ol><li>由于BytecodeGenerator实现了AstVisitor，我们将在Javascript AST中运行时创建相应的字节码。 </li><li>BytecodeGenerator位于src / interpreter / bytecode - generator.h中</li><li>字节码生成方法是BytecodeGenerator :: GenerateBytecode。</li><li>InterpreterCompilationJob :: ExecuteJobImpl（src / interpreter / interpreter.cc）中调用BytecodeGenerator :: GenerateBytecode。</li><li>InterpreterCompilationJob :: ExecuteJobImpl由静态Interpreter :: NewCompilationJob执行。</li></ol><p>Interpreter :: NewCompilationJob的层次结构如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Interpreter::NewCompilationJob</span><br><span class="line">|</span><br><span class="line">InterpreterCompilationJob::ExecuteJobImpl</span><br><span class="line">|</span><br><span class="line">BytecodeGenerator::GenerateBytecode</span><br></pre></td></tr></table></figure></p><p>由于这个静态Interpreter :: NewCompilationJob是一个在编译器管道中生成作业的方法，让我们看一下compiler.cc（src / compiler.cc）。<br>compiler.cc（src / compiler.cc）有一个非常复杂且难以理解的调用层次结构，并且与可选的设置解析器设置一起读取也很困难。<br>调用堆栈直到调用静态Interpreter :: NewCompilationJob如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ScriptCompiler::Compile</span><br><span class="line">|</span><br><span class="line">ScriptCompiler::CompileUnboundInternal</span><br><span class="line">|</span><br><span class="line">Compiler::GetSharedFunctionInfoForScript</span><br><span class="line">|</span><br><span class="line">Compiler::CompileToplevel</span><br><span class="line">|</span><br><span class="line">CompileUnoptimizedCode(compiler.cc)</span><br><span class="line">|</span><br><span class="line">CompileUnoptimizedInnerFunctions</span><br><span class="line">|</span><br><span class="line">GenerateUnoptimizedCode</span><br><span class="line">|</span><br><span class="line">GetUnoptimizedCompilationJob</span><br><span class="line">|</span><br><span class="line">---- Iginitionオプションによってfullcodegenと分岐</span><br><span class="line">| |</span><br><span class="line">Interpreter::NewCompilationJob</span><br><span class="line">  |</span><br><span class="line">  FullCodeGenerator::NewCompilationJob</span><br></pre></td></tr></table></figure></p><p>ScriptCompiler :: Compile是V8的Javascript编译器的入口点，并按顺序调用该函数，最后创建Job of Interpreter。</p><p>到最终的BytecodeGenerator :: GenerateBytecode的调用堆栈如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ScriptCompiler::Compile</span><br><span class="line">|</span><br><span class="line">ScriptCompiler::CompileUnboundInternal</span><br><span class="line">|</span><br><span class="line">Compiler::GetSharedFunctionInfoForScript</span><br><span class="line">|</span><br><span class="line">Compiler::CompileToplevel</span><br><span class="line">|</span><br><span class="line">CompileUnoptimizedCode(compiler.cc)</span><br><span class="line">|</span><br><span class="line">CompileUnoptimizedInnerFunctions</span><br><span class="line">|</span><br><span class="line">GenerateUnoptimizedCode</span><br><span class="line">|</span><br><span class="line">GetUnoptimizedCompilationJob</span><br><span class="line">|</span><br><span class="line">---- Branch with fullcodegen by Iginition option</span><br><span class="line">| |</span><br><span class="line">| FullCodeGenerator::NewCompilationJob</span><br><span class="line">|</span><br><span class="line">Interpreter::NewCompilationJob</span><br><span class="line">|</span><br><span class="line">InterpreterCompilationJob::ExecuteJobImpl</span><br><span class="line">|</span><br><span class="line">BytecodeGenerator::GenerateBytecode</span><br></pre></td></tr></table></figure><h3 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h3><p>现在我们知道调用层次结构，我们将看看如何生成字节码。<br>由于字节码生成继承自前面编写的AstVisitor，因此有Visit必要实现各种方法。<br>你应该能够通过查看各种实现来了解您正在做的事情。或者直接通过trace_bytecode来运行d8查看输出。</p><p>JavaScript代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br></pre></td></tr></table></figure></p><p>字节码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">0  [generating bytecode for function: ]</span><br><span class="line">1  Parameter count 1</span><br><span class="line">2  Frame size 32</span><br><span class="line">3           0x3f5e20aafdf6 @    0 : 09 00             LdaConstant [0]</span><br><span class="line">4           0x3f5e20aafdf8 @    2 : 1f f9             Star r1</span><br><span class="line">5           0x3f5e20aafdfa @    4 : 02                LdaZero</span><br><span class="line">6           0x3f5e20aafdfb @    5 : 1f f8             Star r2</span><br><span class="line">7           0x3f5e20aafdfd @    7 : 20 fe f7          Mov &lt;closure&gt;, r3</span><br><span class="line">8           0x3f5e20aafe00 @   10 : 55 aa 01 f9 03    CallRuntime [DeclareGlobalsForInterpreter], r1-r3</span><br><span class="line">9      0 E&gt; 0x3f5e20aafe05 @   15 : 92                StackCheck</span><br><span class="line">10   116 S&gt; 0x3f5e20aafe06 @   16 : 09 01             LdaConstant [1]</span><br><span class="line">11          0x3f5e20aafe08 @   18 : 1f f9             Star r1</span><br><span class="line">12          0x3f5e20aafe0a @   20 : 02                LdaZero</span><br><span class="line">13          0x3f5e20aafe0b @   21 : 1f f8             Star r2</span><br><span class="line">14          0x3f5e20aafe0d @   23 : 03 01             LdaSmi [1]</span><br><span class="line">15          0x3f5e20aafe0f @   25 : 1f f7             Star r3</span><br><span class="line">16          0x3f5e20aafe11 @   27 : 55 ab 01 f9 03    CallRuntime [InitializeVarGlobal], r1-r3</span><br><span class="line">17          0x3f5e20aafe16 @   32 : 04                LdaUndefined</span><br><span class="line">18   118 S&gt; 0x3f5e20aafe17 @   33 : 96                Return</span><br><span class="line">19 Constant pool (size = 2)</span><br><span class="line">20 0x3f5e20aafda1: [FixedArray]</span><br><span class="line">21  - map = 0x1cfd2a282309 &lt;Map(FAST_HOLEY_ELEMENTS)&gt;</span><br><span class="line">22  - length: 2</span><br><span class="line">23            0: 0x3f5e20aafd71 &lt;FixedArray[4]&gt;</span><br><span class="line">24            1: 0x2315b1a87ef9 &lt;String[1]: a&gt;</span><br></pre></td></tr></table></figure></p><p>你得到这个结果。</p><p>这里，函数名称输入到函数字节码中。</p><p><code>0  [generating bytecode for function: ]</code></p><p>这是堆栈的参数数量。<br>这个字节码是全局的，所以忽略它。</p><p><code>1  Parameter count 1</code></p><p>FrameSize是已分配寄存器的数量*指针大小<br>指针大小大致相同，32位为4字节，64位为8字节。<br>在这种情况下，由于分配的寄存器数是4 64位环境，因此指针大小为8字节<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 * 8 = 32。</span><br><span class="line">2  Frame size 32</span><br></pre></td></tr></table></figure></p><p>每个字节串是当前地址的偏移字节码的数字字节码名称操作数。<br><code>3  0x3f5e20aafdf6 @    0 : 09 00             LdaConstant [0]</code><br>这是常量值池的内容。<br>在此示例中，汇总了变量名称a。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">19 Constant pool (size = 2)</span><br><span class="line">20 0x3f5e20aafda1: [FixedArray]</span><br><span class="line">21  - map = 0x1cfd2a282309 &lt;Map(FAST_HOLEY_ELEMENTS)&gt;</span><br><span class="line">22  - length: 2</span><br><span class="line">23            0: 0x3f5e20aafd71 &lt;FixedArray[4]&gt;</span><br><span class="line">24            1: 0x2315b1a87ef9 &lt;String[1]: a&gt;</span><br></pre></td></tr></table></figure></p><p>现在，让我们先看看基于这些信息的源代码和字节码。<br>以下部分可能会被扫除。 因为这是编译准备。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3           0x3f5e20aafdf6 @    0 : 09 00             LdaConstant [0]</span><br><span class="line">4           0x3f5e20aafdf8 @    2 : 1f f9             Star r1</span><br><span class="line">5           0x3f5e20aafdfa @    4 : 02                LdaZero</span><br><span class="line">6           0x3f5e20aafdfb @    5 : 1f f8             Star r2</span><br><span class="line">7           0x3f5e20aafdfd @    7 : 20 fe f7          Mov &lt;closure&gt;, r3</span><br><span class="line">8           0x3f5e20aafe00 @   10 : 55 aa 01 f9 03    CallRuntime [DeclareGlobalsForInterpreter], r1-r3</span><br><span class="line">9      0 E&gt; 0x3f5e20aafe05 @   15 : 92                StackCheck</span><br></pre></td></tr></table></figure></p><p>从这里真正的produce</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//将常量池中索引1（变量名a）的值加载到累加器中。</span><br><span class="line">10 116 S&gt; 0x3f5e20aafe06 @ 16:09 01 LdaConstant [1]</span><br><span class="line">11 //将累加器的值（变量名a）加载到r1寄存器中。</span><br><span class="line">12 0x3f5e20aafe08 @ 18：1f f9 Star r1</span><br><span class="line">13 //加载累加器0。</span><br><span class="line">14 0x3f5e20aafe0a @ 20:02 LdaZero</span><br><span class="line">15 //将值从累加器（0）加载到r2寄存器中。</span><br><span class="line">16 0x3f5e20aafe0b @ 21：1 f f 8 Star r 2</span><br><span class="line">17 //将立即值1加载到累加器中。</span><br><span class="line">18 0x3f5e20aafe0d @ 23:03 01 Lda Smi [1]</span><br><span class="line">19 //将累加器（1）的值加载到r3寄存器中。</span><br><span class="line">20 0x3f5e20aafe0f @ 25：1 f f 7 Star r 3</span><br><span class="line">21 //使用r1寄存器中的r3寄存器值（a，0,1）调用InitializeVarGlobal运行时。</span><br><span class="line">22 0x3f5e20aafe11 @ 27:55 ab 01 f9 03 CallRuntime [InitializeVarGlobal]，r1-r3</span><br><span class="line">23 //将undefined设置为accumulator</span><br><span class="line">24 0x3f5e20aafe16 @ 32:04  LdaUndefined</span><br><span class="line">25 / /完成</span><br><span class="line">26 118 S&gt; 0x3f5e20aafe17 @ 33:96 Return</span><br></pre></td></tr></table></figure><p>顺便说一下，在CallRuntime的情况下，需要为每个运行时确定调用约定，因此有必要相应地分配寄存器。</p><p>InitializeVarGlobal运行时调用需要以下寄存器。</p><ul><li>r0 =要绑定的变量名称</li><li>r1 = LaunguageMode SLOPPY（正常）STRICT（严格模式）LAUNGUAGE_END（未知）</li><li>r2 =要绑定的值</li></ul><p>因此，上面的代码:</p><ul><li>将值加载到累加器中</li><li>将值加载到寄存器中</li><li>loop</li></ul><h3 id="字节码执行"><a href="#字节码执行" class="headerlink" title="字节码执行"></a>字节码执行</h3><h4 id="BytecodeHandler"><a href="#BytecodeHandler" class="headerlink" title="BytecodeHandler"></a>BytecodeHandler</h4><p>字节码处理由BytecodeHandler完成。<br>BytecodeHandler在v8初始化时将被生成。</p><p>以下是BytecodeHandler的示例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IGNITION_HANDLER(LdaZero, InterpreterAssembler) &#123;</span><br><span class="line">  Node* zero_value = NumberConstant(0.0);</span><br><span class="line">  SetAccumulator(zero_value);</span><br><span class="line">  Dispatch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在BytecoeHandler load zero的过程中，将累加器设置为0。<br>实际上，每组字节码都将有一个这样的BytecodeHandler。<br>每个BytecodeHandler通过depatch直接调用下一个BytecodeHandler。</p><p>下图显示了BytecodeHandler的生成<br><img src="http://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180809/5EKEACljA5.png" alt="mark"></p><h4 id="InterpreterEntryTrampoline"><a href="#InterpreterEntryTrampoline" class="headerlink" title="InterpreterEntryTrampoline"></a>InterpreterEntryTrampoline</h4><p>在Ignition终于生成了BytecodeArray之后，从使用InterpreterEntryTrampoline代码构建的代码中点燃DispatchTable of Ignition，<br>它从BytecodeArray中检索字节码并执行相应DispatchTable的处理并转发。</p><p>下图显示了Ignition的执行方式</p><p><img src="http://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180809/LD4DkmKggA.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是字节码解释器？&quot;&gt;&lt;a href=&quot;#什么是字节码解释器？&quot; class=&quot;headerlink&quot; title=&quot;什么是字节码解释器？&quot;&gt;&lt;/a&gt;什么是字节码解释器？&lt;/h2&gt;&lt;p&gt;解释器是一种顺序执行源代码的引擎。&lt;br&gt;在过去的V8中，源代码被立即编译到
      
    
    </summary>
    
      <category term="Browser Explore" scheme="http://p1umer.club/categories/Browser-Explore/"/>
    
      <category term="Edge" scheme="http://p1umer.club/categories/Browser-Explore/Edge/"/>
    
    
      <category term="Browser Explore" scheme="http://p1umer.club/tags/Browser-Explore/"/>
    
  </entry>
  
  <entry>
    <title>V8 Environmental Configuration</title>
    <link href="http://p1umer.club/2018/07/01/V8-Environmental-Configuration/"/>
    <id>http://p1umer.club/2018/07/01/V8-Environmental-Configuration/</id>
    <published>2018-07-01T09:35:44.000Z</published>
    <updated>2019-01-01T19:05:36.941Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180904/19ALGmIhjG.png" alt="mark"></p><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><h3 id="Pre-Work"><a href="#Pre-Work" class="headerlink" title="Pre Work"></a>Pre Work</h3><ul><li><p>Install Git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git</span><br></pre></td></tr></table></figure></li><li><p>Install depot_tools</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://chromium.googlesource.com/chromium/tools/depot_tools</span><br><span class="line">export PATH=`pwd`/depot_tools:&quot;$PATH&quot;</span><br></pre></td></tr></table></figure><a id="more"></a></li></ul><h3 id="Key-Step"><a href="#Key-Step" class="headerlink" title="Key Step"></a>Key Step</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gclient</span><br><span class="line">mkdir v8</span><br><span class="line">cd v8</span><br><span class="line">fetch v8</span><br><span class="line">-</span><br><span class="line">tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C out.gn/x64.debug</span><br></pre></td></tr></table></figure>此时编译的是最新版本的v8若想切换分支，在(-)处执行以下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard +hash</span><br><span class="line">tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C out.gn/x64.debug</span><br></pre></td></tr></table></figure></code></pre><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h3 id="Prework"><a href="#Prework" class="headerlink" title="Prework"></a>Prework</h3><ul><li>Visual Studio 2017</li><li><a href="https://chromium.googlesource.com/new-password" target="_blank" rel="noopener">设置 git cookie</a> </li><li><a href="https://link.zhihu.com/?target=https%3A//go.microsoft.com/fwlink/p/%3FLinkId%3D845298" target="_blank" rel="noopener">Windows SDK</a></li></ul><h3 id="Key-STAP"><a href="#Key-STAP" class="headerlink" title="Key STAP"></a>Key STAP</h3><ul><li>打开适用于 VS 2017 的 X64 本机工具命令提示框</li><li>再次确认上一步已完成，注意不是cmd窗口<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line"></span><br><span class="line">&gt;SET depot_tools 环境变量，将其放在存有python.exe的环境变量前或者直接置顶</span><br><span class="line"></span><br><span class="line">&gt;set DEPOT_TOOLS_WIN_TOOLCHAIN=0</span><br><span class="line"></span><br><span class="line">&gt;set GYP_MSVS_VERSION=2017</span><br><span class="line"></span><br><span class="line">&gt;mkdir v8 &amp;&amp; cd v8</span><br><span class="line"></span><br><span class="line">&gt;fetch v8</span><br><span class="line"></span><br><span class="line">&gt;cd v8</span><br><span class="line"></span><br><span class="line">&gt;gn gen --ide=vs out.gn\x64_solution</span><br><span class="line"></span><br><span class="line">&gt;python tools\dev\v8gen.py x64.release</span><br><span class="line"></span><br><span class="line">&gt;ninja -C out.gn\x64.release</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://sakura-1252236262.cos.ap-beijing.myqcloud.com/blog/180904/19ALGmIhjG.png&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;linux&quot;&gt;&lt;a href=&quot;#linux&quot; class=&quot;headerlink&quot; title=&quot;linux&quot;&gt;&lt;/a&gt;linux&lt;/h2&gt;&lt;h3 id=&quot;Pre-Work&quot;&gt;&lt;a href=&quot;#Pre-Work&quot; class=&quot;headerlink&quot; title=&quot;Pre Work&quot;&gt;&lt;/a&gt;Pre Work&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Install Git&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;apt-get install git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Install depot_tools&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone https://chromium.googlesource.com/chromium/tools/depot_tools&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export PATH=`pwd`/depot_tools:&amp;quot;$PATH&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Browser Explore" scheme="http://p1umer.club/categories/Browser-Explore/"/>
    
      <category term="V8" scheme="http://p1umer.club/categories/Browser-Explore/V8/"/>
    
    
      <category term="Browser Explore" scheme="http://p1umer.club/tags/Browser-Explore/"/>
    
  </entry>
  
</feed>
